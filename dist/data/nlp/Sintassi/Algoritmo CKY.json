{
  "title": "üß† Algoritmo di Cocke-Kasami-Younger (CKY)",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n/* Blocchi di codice sempre visibili */\n.code-visible {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    background: #f9fafb;\n    margin: 16px 0;\n}\n.code-visible .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<p>L&rsquo;algoritmo <strong>Cocke-Kasami-Younger (CKY)</strong> √® una tecnica di parsing fondamentale nel campo dell&rsquo;elaborazione del linguaggio naturale e dell&rsquo;analisi sintattica. Si tratta di un approccio <strong>bottom-up</strong> che sfrutta la <strong>programmazione dinamica</strong> per verificare se una frase (cio√® una sequenza di parole) pu√≤ essere generata da una grammatica <strong>libera dal contesto</strong>, a condizione che quest‚Äôultima sia espressa in <strong>Forma Normale di Chomsky (CNF)</strong>. </p>\n<p>Esiste anche una versione probabilistica del CKY üëâ <a href=\"/theory/nlp/Sintassi/Algoritmo di CKY Probabilistico\" class=\"text-blue-600 hover:underline\">Algoritmo di CKY Probabilistico</a>.</p>\n<h2 id=\"cose-la-forma-normale-di-chomsky\">üìå Cos&rsquo;√® la Forma Normale di Chomsky?</h2>\n<p>Una <a href=\"/theory/nlp/Sintassi/Grammatiche Formali\" class=\"text-blue-600 hover:underline\">grammatica</a> √® in <strong>Forma Normale di Chomsky</strong> quando tutte le sue produzioni rispettano uno dei seguenti due schemi:\n- $A \\rightarrow BC$ dove $A$, $B$, e $C$ sono non-terminali (con $B$ e $C$ che non sono il simbolo iniziale).\n- $A \\rightarrow a$ dove $a$ √® un terminale, ovvero una parola del vocabolario.</p>\n<p>Questa forma consente di semplificare il parsing grazie a una struttura uniforme delle regole.</p>\n<h2 id=\"struttura-della-tabella-di-parsing\">üìê Struttura della tabella di parsing</h2>\n<p>Per analizzare una frase composta da $n$ parole, l&rsquo;algoritmo utilizza una <strong>tabella triangolare superiore</strong> (una matrice concettuale) di dimensioni $(n+1) \\times (n+1)$, chiamata $table$.</p>\n<ul>\n<li>Ogni cella $table[i][j]$ contiene <strong>l&rsquo;insieme dei simboli non-terminali</strong> che possono generare la sottostringa compresa tra le posizioni $i$ e $j$ (esclusa $j$).</li>\n<li>La cella pi√π in alto a sinistra, $table[0][n]$, rappresenta la frase intera.</li>\n<li>Se il simbolo iniziale della grammatica $S$ √® presente in $table[0][n]$, allora la frase pu√≤ essere generata dalla grammatica.</li>\n</ul>\n<h3 id=\"esempio\">Esempio</h3>\n<p>Consideriamo la frase: &ldquo;John loves Mary&rdquo;. Supponiamo di avere la seguente grammatica in CNF:</p>\n$$\n\\begin{align*}\nS  &\\rightarrow NP \\ VP \\\\\nNP &\\rightarrow John \\mid Mary \\\\\nVP &\\rightarrow VP NP\\\\\nV  &\\rightarrow loves\n\\end{align*}\n$$\n<p>La tabella $table$ di dimensione $4 \\times 4$ (poich√© $n = 3$) sar√†:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0 (S)</th>\n<th>1 (John)</th>\n<th>2 (loves)</th>\n<th>3 (Mary)</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td></td>\n<td>{NP}</td>\n<td></td>\n<td>{S}</td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td></td>\n<td></td>\n<td>{V}</td>\n<td>{VP}</td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td>{NP}</td>\n</tr>\n<tr>\n<td><strong>3</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<ul>\n<li>$table[0][1] = \\{NP\\}$ perch√© $NP \\rightarrow John$.</li>\n<li>$table[1][2] = \\{V\\}$ perch√© $V \\rightarrow loves$.</li>\n<li>$table[2][3] = \\{NP\\}$ perch√© $NP \\rightarrow Mary$.</li>\n<li>$table[1][3] = \\{VP\\}$ perch√© $V \\in table[1][2]$ e $NP \\in table[2][3]$ con la regola $VP \\rightarrow V\\ NP$.</li>\n<li>$table[0][3] = \\{S\\}$ perch√© $NP \\in table[0][1]$ e $VP \\in table[1][3]$ con la regola $S \\rightarrow NP\\ VP$.</li>\n</ul>\n<p>Dato che $table[0][3] = \\{S\\}$, la frase puo essere generata dalla grammatica.</p>\n<h2 id=\"meccanismo-di-base-costruzione-delle-strutture-sintattiche\">üí° Meccanismo di base: costruzione delle strutture sintattiche</h2>\n<p>L‚Äôalgoritmo si basa su un principio di composizione: se una regola grammaticale afferma che $A \\rightarrow B\\ C$, e se riusciamo a suddividere una sottostringa in due parti tali che:\n- $B$ genera la prima parte, cio√® $B \\in table[i][k]$\n- $C$ genera la seconda parte, cio√® $C \\in table[k][j]$</p>\n<p>allora possiamo concludere che:\n- $A$ genera l‚Äôintera sottostringa, quindi $A \\in table[i][j]$</p>\n<p>Questo approccio √® ripetuto per tutte le possibili partizioni della frase, permettendo la costruzione incrementale delle strutture sintattiche.</p>\n<h2 id=\"procedura-di-riempimento-della-tabella\">üìã Procedura di riempimento della tabella</h2>\n<ol>\n<li><strong>Inizializzazione (lunghezza 1)</strong>: Per ogni parola nella frase, si aggiungono i non-terminali che possono generare direttamente quella parola (tramite regole del tipo $A \\rightarrow a$).</li>\n<li><strong>Espansione (lunghezze maggiori)</strong>: Si analizzano sottostringhe di lunghezza crescente, esaminando tutte le possibili partizioni in due sottosequenze contigue. Per ogni partizione, si cercano coppie di simboli non-terminali gi√† presenti nella tabella che possano essere combinate secondo le regole della grammatica.</li>\n</ol>\n<p>Questo processo √® eseguito in maniera bottom-up, iniziando dalle sottostringhe pi√π piccole e costruendo via via strutture pi√π complesse.</p>\n<h2 id=\"pseudocodice-dellalgoritmo-cky\">üîÅ Pseudocodice dell&rsquo;algoritmo CKY</h2>\n<p>Di seguito √® riportato uno pseudocodice che illustra il funzionamento dell&rsquo;algoritmo CKY. L&rsquo;input √® una lista di parole <code>words</code> e una grammatica in CNF, mentre l&rsquo;output √® una tabella $table$ che descrive come la frase pu√≤ essere derivata.</p>\n$$\n\\begin{array}{l}\n\\textbf{function } \\text{CKY-Parse(words, grammar)} \\rightarrow \\text{return table} \\\\[1em]\n\\qquad \\textbf{for } j = 1 \\text{ to } \\texttt{length(words)} \\text{ do} \\\\\n\\qquad \\quad \\textbf{for all rules } \\{A \\mid A \\rightarrow \\texttt{words}[j] \\in \\text{grammar}\\} \\text{ do} \\\\\n\\qquad \\quad\\quad \\texttt{table}[j-1][j] \\leftarrow \\texttt{table}[j-1][j] \\cup \\{A\\} \\\\[1em]\n\n\\qquad \\quad \\textbf{for } i = j - 2 \\text{ down to } 0 \\text{ do} \\\\\n\\qquad \\quad\\quad \\textbf{for } k = i + 1 \\text{ to } j - 1 \\text{ do} \\\\\n\\qquad \\quad\\quad\\quad \\textbf{for all rules } \\{A \\mid A \\rightarrow B\\ C  \\in \\text{grammar}\\} \\text{ do} \\\\\n\\qquad \\quad\\quad\\quad\\quad \\textbf{if } B \\in \\texttt{table}[i][k] \\text{ and } C \\in \\texttt{table}[k][j] \\text{ then} \\\\\n\\qquad \\quad\\quad\\quad\\quad\\quad \\texttt{table}[i][j] \\leftarrow \\texttt{table}[i][j] \\cup \\{A\\} \\\\[1em]\n \n\\qquad \\textbf{return } \\texttt{table}\n\\end{array}\n$$\n<h3 id=\"spiegazione\">Spiegazione</h3>\n<p>Per ogni indice $i = 0$ a $n-1$ (dove $n$ √® la lunghezza della frase), eseguiamo due fasi:</p>\n<h4 id=\"fase-1-parola-singola-math_inline_80\">üß© Fase 1 ‚Äî parola singola $w_i$</h4>\n<ul>\n<li>Consideriamo la <strong>sottostringa di lunghezza 1</strong> $w_i$</li>\n<li>Per ogni regola terminale della grammatica:\n  $$\n  A \\rightarrow w_i\n  $$\n  se $w_i$ √® il terminale a destra, allora aggiungiamo $A$ in:\n  $$\n  table[i][i+1] \\gets table[i][i+1] \\cup \\{A\\}\n  $$</li>\n</ul>\n<p>‚ú® Questa fase classifica ogni parola singola nella sua possibile <strong>categoria grammaticale</strong>.</p>\n<h4 id=\"fase-2-sottostringhe-piu-lunghe-che-terminano-in-math_inline_84\">üß± Fase 2 ‚Äî sottostringhe pi√π lunghe che terminano in $w_i$</h4>\n<ul>\n<li>Per ogni lunghezza $\\ell = 2$ fino a $i+1$:</li>\n<li>Consideriamo la sottostringa:\n    $$\n    w_{i - \\ell + 1} \\dots w_i\n    $$<ul>\n<li>Questa sottostringa corrisponde a:\n  $$\n      table[i - \\ell + 1][i+1]\n      $$</li>\n</ul>\n</li>\n<li>Per ogni punto di divisione interno $k$ con:\n    $$\n    i - \\ell + 1 < k < i+1\n    $$\n    analizziamo le due sottostringhe:\n    $$\n    table[i - \\ell + 1][k], \\quad table[k][i+1]\n    $$<ul>\n<li>Per ogni regola binaria della grammatica:\n  $$\n      A \\rightarrow B\\,C\n      $$\n  se $B \\in table[i - \\ell + 1][k]$ e $C \\in table[k][i+1]$, allora:\n  $$\n      A \\in table[i - \\ell + 1][i+1]\n      $$</li>\n</ul>\n</li>\n</ul>\n<p>In pratica, a ogni passo combiniamo <strong>strutture pi√π piccole</strong> gi√† calcolate, fino a costruire tutte le sottostrutture sintattiche che terminano in $w_i$.</p>\n<h3 id=\"intuizione-dellalgoritmo-cky\">üß† Intuizione dell&rsquo;algoritmo CKY</h3>\n<p>L‚Äôalgoritmo CKY pu√≤ sembrare inizialmente complicato, ma √® in realt√† un procedimento <strong>molto logico e sistematico</strong> per capire se una frase pu√≤ essere generata da una grammatica.</p>\n<p>Dato che stiamo assumendo una grammatica in CNF, ogni nodo non terminale avr√† al massimo due figli. Quindi, possiamo utilizzare una matrice per descrivere la struttura dell&rsquo;albero.</p>\n<h4 id=\"obiettivo\">üîπ Obiettivo</h4>\n<p>Costruire una tabella dove ogni cella $table[i][j]$ contiene l&rsquo;insieme dei simboli non-terminali che possono generare la sottostringa di parole da posizione $i$ a $j$ (escluso $j$). Quindi la cella che rappresenta la frase intera √® $table[0][n]$ (solo se √® presente il simbolo iniziale alla fine dell&rsquo;algoritmo).</p>\n<h4 id=\"fase-1-riempimento-della-diagonale-lunghezza-1\">üîπ Fase 1: Riempimento della diagonale (lunghezza = 1)</h4>\n<p>Per ogni parola $w_i$ nella frase:</p>\n<ul>\n<li>Cerchiamo tutte le regole del tipo:<br />\n  $$\n  A \\rightarrow w_i\n  $$</li>\n<li>Se la troviamo, mettiamo $A$ nella cella $table[i][i+1]$, perch√© $A$ √® in grado di generare la parola $w_i$.</li>\n</ul>\n<p>‚ú® Questa fase identifica la <strong>categoria grammaticale</strong> di ogni parola.</p>\n<h4 id=\"fase-2-costruzione-della-tabella-lunghezze-1\">üîπ Fase 2: Costruzione della tabella (lunghezze &gt; 1)</h4>\n<p>Per ogni sottostringa di lunghezza $\\geq 2$, consideriamo tutte le possibili divisioni della sottostringa in due parti. Per ogni divisione:</p>\n<ol>\n<li>\n<p>Supponiamo che:\n   $$\n   B \\in table[i][k] \\quad \\text{e} \\quad C \\in table[k][j]\n   $$\n   cio√® che le due parti possano essere generate da $B$ e $C$.</p>\n</li>\n<li>\n<p>Se esiste una regola della grammatica:\n   $$\n   A \\rightarrow B\\ C\n   $$\n   allora possiamo dire che:\n   $$\n   A \\in table[i][j]\n   $$\n   perch√© $A$ √® in grado di generare l&rsquo;intera sottostringa da $i$ a $j$.</p>\n</li>\n</ol>\n<p>‚öôÔ∏è Questa fase <strong>combina strutture pi√π piccole</strong> in strutture pi√π grandi, secondo le regole grammaticali.</p>\n<h4 id=\"verifica-finale\">üîö Verifica finale</h4>\n<p>Alla fine, controlliamo se il simbolo iniziale $S$ si trova in $table[0][n]$. Se s√¨, allora la frase pu√≤ essere generata dalla grammatica.</p>\n$$\nS \\in table[0][n] \\Rightarrow \\text{Frase grammaticalmente corretta}\n$$\n<h3 id=\"metafora-intuitiva\">ü™Ñ Metafora intuitiva</h3>\n<p>Immagina di avere una <strong>torre di blocchi LEGO</strong>, dove ogni blocco √® una parola. CKY ti dice come puoi incastrare i blocchi tra loro, seguendo <strong>regole di incastro</strong> (grammatica), per costruire una <strong>torre completa</strong> (la frase intera).</p>\n<p>Se riesci a costruire la torre partendo dai singoli pezzi, significa che la frase ha senso secondo la grammatica.</p>\n<p>‚úîÔ∏è Ecco perch√© √® cos√¨ potente: <strong>non indovina</strong> il significato della frase, ma ti dice se la frase √® <strong>formalmente corretta</strong>!</p>\n<h2 id=\"esempio_1\">üìò Esempio</h2>\n<p><strong>&ldquo;Book the flight through Houston&rdquo;</strong></p>\n<p>Dopo la tokenizzazione e normalizzazione:\n$$\nw = [ \\text{book}, \\text{the}, \\text{flight}, \\text{through}, \\text{houston} ]\n$$</p>\n<h3 id=\"tabella-cky-struttura-iniziale\">üìê Tabella CKY ‚Äì struttura iniziale</h3>\n<p>Costruiamo una tabella triangolare superiore $table[i][j]$ con $n = 5$ parole:</p>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>0</th>\n<th>1</th>\n<th>2</th>\n<th>3</th>\n<th>4</th>\n<th>5</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>0</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>1</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>2</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>3</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>4</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>5</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"fase-1-inizializzazione-con-terminali-lunghezza-1\">üß± Fase 1 ‚Äì Inizializzazione con terminali (lunghezza 1)</h3>\n<p>Riempimento della diagonale con regole $A \\rightarrow a$</p>\n<h4 id=\"parola-math_inline_112\">Parola $w_0 = \\text{book}$</h4>\n<ul>\n<li>$\\text{Verb} \\rightarrow \\text{book} \\Rightarrow \\text{Verb} \\in table[0][1]$</li>\n<li>$\\text{VP} \\rightarrow \\text{book} \\Rightarrow \\text{VP} \\in table[0][1]$</li>\n<li>$\\text{Noun} \\rightarrow \\text{book} \\Rightarrow \\text{Noun} \\in table[0][1]$</li>\n<li>$\\text{Nominal} \\rightarrow \\text{book} \\Rightarrow \\text{Nominal} \\in table[0][1]$</li>\n</ul>\n$$\ntable[0][1] = \\{ \\text{S}, \\text{Verb}, \\text{VP}, \\text{Nominal}, \\text{Noun} \\}\n$$\n<h4 id=\"parola-math_inline_117\">Parola $w_1 = \\text{the}$</h4>\n<ul>\n<li>$\\text{Det} \\rightarrow \\text{the} \\Rightarrow \\text{Det} \\in table[1][2]$</li>\n</ul>\n$$\ntable[1][2] = \\{ \\text{Det} \\}\n$$\n<h4 id=\"parola-math_inline_119\">Parola $w_2 = \\text{flight}$</h4>\n<ul>\n<li>$\\text{Noun} \\rightarrow \\text{flight} \\Rightarrow \\text{Noun} \\in table[2][3]$</li>\n<li>$\\text{Nominal} \\rightarrow \\text{flight} \\Rightarrow \\text{Nominal} \\in table[2][3]$</li>\n</ul>\n$$\ntable[2][3] = \\{ \\text{Noun}, \\text{Nominal} \\}\n$$\n<h4 id=\"parola-math_inline_122\">Parola $w_3 = \\text{through}$</h4>\n<ul>\n<li>$\\text{Preposition} \\rightarrow \\text{through} \\Rightarrow \\text{Preposition} \\in table[3][4]$</li>\n</ul>\n$$\ntable[3][4] = \\{ \\text{Preposition} \\}\n$$\n<h4 id=\"parola-math_inline_124\">Parola $w_4 = \\text{houston}$</h4>\n<ul>\n<li>$\\text{Proper{-}Noun} \\rightarrow \\text{houston} \\Rightarrow \\text{Proper{-}Noun} \\in table[4][5]$</li>\n<li>$\\text{NP} \\rightarrow \\text{houston} \\Rightarrow \\text{NP} \\in table[4][5]$</li>\n</ul>\n$$\ntable[4][5] = \\{ \\text{Proper{-}Noun}, \\text{NP} \\}\n$$\n<h3 id=\"tabella-cky-dopo-la-fase-1-produzioni-terminali\">üìê Tabella CKY ‚Äî Dopo la Fase 1 (Produzioni Terminali)</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>book</th>\n<th>the</th>\n<th>flight</th>\n<th>through</th>\n<th>houston</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>book</strong></td>\n<td>{S,Verb, VP, Nominal, Noun}</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>the</strong></td>\n<td></td>\n<td>{Det}</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>flight</strong></td>\n<td></td>\n<td></td>\n<td>{Nominal Noun}</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td><strong>through</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td>{Preposition}</td>\n<td></td>\n</tr>\n<tr>\n<td><strong>houston</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>{Proper-Noun, NP}</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"fase-2-costruzione-bottom-up-lunghezze-crescenti\">üß± Fase 2 ‚Äì Costruzione bottom-up (lunghezze crescenti)</h3>\n<h4 id=\"lunghezza-2-diagonale-partendo-da-colonna-2\">Lunghezza = 2 (diagonale partendo da colonna 2)</h4>\n<p><strong>Sottostringa ([0, 2]): &ldquo;book the&rdquo;</strong></p>\n<ul>\n<li>$\\text{Verb} \\in table[0][1], \\text{Det} \\in table[1][2]$</li>\n<li>Regola: Nessuna regola che combina $\\{ \\text{Verb}, \\text{VP}, \\text{Noun}, \\text{Nominal} \\}$ e $\\{Det\\}$.</li>\n</ul>\n$$\ntable[0][2] = \\emptyset\n$$\n<p><strong>Sottostringa ([1, 3]): &ldquo;the flight&rdquo;</strong></p>\n<ul>\n<li>$\\text{Det} \\in table[1][2], \\text{Nominal} \\in table[2][3]$</li>\n<li>Regola: $NP \\rightarrow Det\\ Nominal \\Rightarrow NP \\in table[1][3]$</li>\n</ul>\n$$\ntable[1][3] = \\{ \\text{NP} \\}\n$$\n<p><strong>Sottostringa ([2, 4]): &ldquo;flight through&rdquo;</strong></p>\n<ul>\n<li>$table[2][3] = \\{\\text{Nominal}, \\text{Noun}\\}, \\text{Preposition} \\in table[3][4]$</li>\n<li>Regola: Nessuna regola che combina $\\text{Nominal} \\mid \\text{Noun}$ e $\\text{Preposition}$.</li>\n</ul>\n$$\ntable[2][4] = \\emptyset\n$$\n<p><strong>Sottostringa ([3, 5]): &ldquo;through houston&rdquo;</strong></p>\n<ul>\n<li>$\\text{Preposition} \\in table[3][4], \\text{NP} \\in table[4][5]$</li>\n<li>Regola: $PP \\rightarrow Preposition\\ NP \\Rightarrow PP \\in table[3][5]$</li>\n</ul>\n$$\ntable[3][5] = \\{ \\text{PP} \\}\n$$\n<h4 id=\"lunghezza-3-diagonale-partendo-da-colonna-3\">Lunghezza = 3 (diagonale partendo da colonna 3)</h4>\n<p><strong>Sottostringa ([0, 3]): &ldquo;book the flight&rdquo;</strong></p>\n<p>Confrontiamo le celle $table[0][1]$ e $table[1][3]$.</p>\n<ul>\n<li>$\\text{Verb} \\in table[0][1], \\text{NP} \\in table[1][3]$</li>\n<li>Regola: $S \\rightarrow Verb\\ NP \\Rightarrow S \\in table[0][3]$</li>\n<li>Regola: $VP \\rightarrow Verb\\ NP \\Rightarrow VP \\in table[0][3]$</li>\n<li>Regola: $X2 \\rightarrow Verb\\ NP \\Rightarrow X2 \\in table[0][3]$</li>\n</ul>\n<p>Confrontiamo le celle $table[0][2]$ e $table[2][3]$.</p>\n<ul>\n<li>$table[0][2] = \\emptyset$, $table[2][3] = \\{ \\text{Nominal, Noun} \\}$</li>\n<li>Regola: Nessuna regola che combina $\\emptyset$ e $\\text{Nominal} \\mid \\text{Noun}$.</li>\n</ul>\n$$\ntable[0][3] = \\{ \\text{S}, \\text{VP}, \\text{X2} \\}\n$$\n<p><strong>Sottostringa ([1, 4]): &ldquo;the flight trough&rdquo;</strong></p>\n<p>Confrontiamo le celle $table[1][2]$ e $table[2][4]$.</p>\n<ul>\n<li>$table[1][2] = \\{Det\\}$, $table[2][4] = \\emptyset$</li>\n<li>Regola: Nessuna regola che combina $\\{Det\\}$ e $\\emptyset$.</li>\n</ul>\n<p>Confrontiamo le celle $table[1][3]$ e $table[3][4]$.</p>\n<ul>\n<li>$table[1][3] = \\{ \\text{NP} \\}$, $table[3][4] = \\{ \\text{Preposition} \\}$</li>\n<li>Regola: Nessuna regola che combina $\\{ \\text{NP} \\}$ e $\\{ \\text{Preposition} \\}$.</li>\n</ul>\n<p><em>Da notare che $PP \\rightarrow Preposition\\ NP$ √® diverso da $PP \\rightarrow NP\\ Preposition$</em>.</p>\n$$\ntable[1][4] = \\emptyset\n$$\n<p><strong>Sottostringa ([2, 5]): &ldquo;flight through houston&rdquo;</strong></p>\n<ul>\n<li>$\\text{Nominal} \\in table[2][3], \\text{PP} \\in table[3][5]$</li>\n<li>Regola: $Nominal \\rightarrow Nominal\\ PP \\Rightarrow Nominal \\in table[2][5]$</li>\n<li>$table[2][4] = \\emptyset$, $table[3][5] = \\{ \\text{NP}, \\text{Proper-Noun} \\}$</li>\n<li>Regola: Nessuna regola che combina $\\emptyset$ e $\\{ \\text{NP}, \\text{Proper-Noun} \\}$.</li>\n</ul>\n$$\ntable[2][5] = \\{ \\text{Nominal} \\}\n$$\n<h3 id=\"lunghezza-4\">Lunghezza = 4</h3>\n<p><strong>Sottostringa ([0, 4]): &ldquo;the flight through houston&rdquo;</strong></p>\n<p>Confrontiamo le celle $table[0][1]$ e $table[1][4]$.</p>\n<ul>\n<li>$table[0][1] = \\{\\text{S}, \\text{VP}, \\text{Nominal}, \\text{Noun}, \\text{Verb}\\}$, $table[1][4] = \\emptyset$</li>\n<li>Regola: Nessuna regola che combina $\\{\\text{S}, \\text{VP}, \\text{Nominal}, \\text{Noun}, \\text{Verb}\\}$ e $\\emptyset$.</li>\n</ul>\n<p>Confrontiamo le celle $table[0][2]$ e $table[2][4]$.</p>\n<ul>\n<li>$table[0][2] = \\emptyset$, $table[2][4] = \\emptyset$</li>\n<li>Regola: Nessuna regola che combina $\\emptyset$ e $\\emptyset$.</li>\n</ul>\n<p>Confrontiamo le celle $table[0][3]$ e $table[3][4]$.</p>\n<ul>\n<li>$table[0][3] = \\{\\text{S}, \\text{VP}, \\text{X2}\\}$, $table[3][4] = \\{ \\text{Preposition} \\}$</li>\n<li>Regola: Nessuna regola che combina $\\{\\text{S}, \\text{VP}, \\text{X2}\\}$ e $\\{ \\text{Preposition} \\}$.</li>\n</ul>\n$$\ntable[0][4] = \\emptyset\n$$\n<p><strong>Sottostringa ([1, 5]): &ldquo;flight through houston&rdquo;</strong></p>\n<p>Confrontiamo le celle $table[1][2]$ e $table[2][5]$.\n- $table[1][2] = \\text{Det}$, $table[2][5] = \\text{Nominal}$\n- Regola: $NP \\rightarrow Det \\ Nominal \\Rightarrow NP \\in table[1][5]$.</p>\n<p>Confrontiamo le celle $table[1][3]$ e $table[3][5]$.</p>\n<ul>\n<li>$table[1][3] = \\{ \\text{NP} \\}$, $table[3][5] = \\{ \\text{PP}\\}$</li>\n<li>Regola: Nessuna regola che combina $\\{ \\text{NP} \\}$ e $\\{ \\text{PP}\\}$.</li>\n</ul>\n<p>Confrontiamo le celle $table[1][4]$ e $table[4][5]$.</p>\n<ul>\n<li>$table[1][4] = \\emptyset$, $table[4][5] = \\{ \\text{NP}, \\text{Proper-Noun} \\}$</li>\n<li>Regola: Nessuna regola che combina $\\emptyset$ e $\\text{NP} \\mid \\text{Proper-Noun}$.</li>\n</ul>\n$$\ntable[1][5] = \\{ \\text{NP} \\}\n$$\n<h3 id=\"lunghezza-5\">Lunghezza = 5</h3>\n<p><strong>Sottostringa ([0, 5]): &ldquo;book the flight through houston&rdquo;</strong></p>\n<ul>\n<li>$Verb \\in table[0][1]$, $table[1][5] = \\{NP\\}$</li>\n<li>Regola: $S \\rightarrow Verb\\ NP \\Rightarrow S \\ (S_1) \\in table[0][4]$</li>\n<li>Regola: $VP \\rightarrow Verb\\ NP \\Rightarrow VP \\in table[0][4]$</li>\n<li>Regola: $X2 \\rightarrow Verb\\ NP \\Rightarrow X2 \\in table[0][4]$</li>\n<li>$table[0][2] = \\emptyset$, $table[2][5] = \\{\\text{Nominal}\\}$</li>\n<li>Regola: Nessuna regola che combina $\\emptyset$ e $\\{\\text{Nominal}\\}$.</li>\n<li>$\\text{VP} \\in table[0][3], \\text{PP} \\in table[3][5]$</li>\n<li>Regola: $S \\rightarrow VP\\ PP \\Rightarrow S \\ (S_2) \\in table[0][5]$</li>\n<li>Regola: $VP \\rightarrow VP\\ PP \\Rightarrow VP \\in table[0][5]$</li>\n<li>$\\text{X2} \\in table[0][3], \\text{PP} \\in table[3][5]$</li>\n<li>Regola: $S \\rightarrow X2\\ PP \\Rightarrow S \\ (S_3) \\in table[0][5]$</li>\n<li>Regola: $VP \\rightarrow X2\\ PP \\Rightarrow VP \\in table[0][5]$</li>\n</ul>\n$$\ntable[0][5] = \\{ \\text{S}_1, \\text{VP}, \\text{X2}, \\text{S}_2, \\text{S}_3 \\}\n$$\n<h3 id=\"tabella-cky-dopo-la-fase-2-stato-finale\">üìê Tabella CKY ‚Äî Dopo la Fase 2 (stato finale)</h3>\n<table>\n<thead>\n<tr>\n<th></th>\n<th>book</th>\n<th>the</th>\n<th>flight</th>\n<th>through</th>\n<th>houston</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>book</strong></td>\n<td>{S, Verb, VP, Nominal, Noun}</td>\n<td>‚àÖ</td>\n<td>{S, VP, X2}</td>\n<td>‚àÖ</td>\n<td>{S‚ÇÅ, S‚ÇÇ, S‚ÇÉ, VP, X2}</td>\n</tr>\n<tr>\n<td><strong>the</strong></td>\n<td></td>\n<td>{Det}</td>\n<td>{NP}</td>\n<td>‚àÖ</td>\n<td>{NP}</td>\n</tr>\n<tr>\n<td><strong>flight</strong></td>\n<td></td>\n<td></td>\n<td>{Nominal, Noun}</td>\n<td>‚àÖ</td>\n<td>{Nominal}</td>\n</tr>\n<tr>\n<td><strong>through</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td>{Preposition}</td>\n<td>{PP}</td>\n</tr>\n<tr>\n<td><strong>houston</strong></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td>{Proper-Noun, NP}</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"conclusione\">‚úÖ Conclusione</h3>\n<p>Poich√© il simbolo iniziale $S \\in table[0][5]$, la frase:</p>\n$$\n\\text{\"book the flight through houston\"}\n$$\n<p><strong>√® grammaticalmente corretta</strong> secondo la grammatica fornita.</p>\n<p>‚úîÔ∏è <strong>Frase accettata!</strong></p>\n<h3 id=\"ricaviamo-lalbero-di-derivazione\">Ricaviamo l&rsquo;albero di derivazione</h3>\n<p>Basta partire ora dalla prima $S_i$ trovata per costruire l&rsquo;albero di derivazione:</p>\n<p><img src=\"/images/tikz/8de168a4143ee4725cd1a0829334cf31.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>\n<h2 id=\"limiti-dellalgoritmo-cky\">Limiti dell&rsquo;algoritmo CKY</h2>\n<p>L&rsquo;algoritmo CKY (Cocke-Kasami-Younger) presenta alcune limitazioni pratiche che √® importante considerare quando si applica a problemi reali di parsing sintattico:</p>\n<ul>\n<li><strong>Necessit√† di grammatica in Forma Normale di Chomsky (CNF)</strong><br />\n  CKY richiede che la grammatica sia espressa in CNF, ovvero tutte le produzioni devono avere la forma:</li>\n<li>$A \\rightarrow BC$ (dove $B$ e $C$ sono simboli non terminali)</li>\n<li>$A \\rightarrow a$ (dove $a$ √® un simbolo terminale)</li>\n</ul>\n<p>Questa trasformazione pu√≤ essere problematica:\n  - <strong>Complica l&rsquo;analisi semantica</strong>, specialmente nei sistemi in cui la struttura sintattica guida l‚Äôinterpretazione del significato (syntax-driven semantic analysis).</p>\n<ul>\n<li><strong>Soluzione praticabile</strong><br />\n  Una strategia per superare questa difficolt√† consiste nel <strong>conservare abbastanza informazioni</strong> durante la conversione in CNF, in modo da poter <strong>ricostruire gli alberi sintattici originali</strong> una volta completato il parsing.</li>\n</ul>\n<p>Alcuni esempi:\n  - √à <strong>facile</strong> trattare regole trasformate come:<br />\n    $A \\rightarrow BCw \\Rightarrow X \\rightarrow BC$, $A \\rightarrow Xw$<br />\n    dove si introduce un simbolo intermedio $X$ durante la conversione.\n  - √à invece <strong>pi√π complesso</strong> gestire le <strong>produzioni unitarie</strong> come:<br />\n    $A \\rightarrow B$</p>\n<p>In sintesi, anche se CKY √® teoricamente solido e garantisce completezza per grammatiche in CNF, il costo pratico della trasformazione grammaticale e la perdita di struttura semantica originale rappresentano ostacoli da affrontare con attenzione.</p>\n<h2 id=\"conclusione_1\">‚úÖ Conclusione</h2>\n<p>L‚Äôalgoritmo CKY rappresenta un approccio sistematico e rigoroso per determinare la <strong>derivabilit√† di una frase</strong> da una grammatica in CNF. Grazie all‚Äôuso della programmazione dinamica, consente di evitare ridondanze computazionali, garantendo una complessit√† polinomiale di $O(n^3 \\cdot |G|)$, dove $n$ √® la lunghezza della frase e $|G|$ √® il numero di regole della grammatica.</p>"
}