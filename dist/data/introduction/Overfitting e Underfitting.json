{
  "title": "Overfitting e Underfitting",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<p>L&rsquo;<strong>overfitting</strong> e l&rsquo;<strong>underfitting</strong> sono due problemi comuni nell&rsquo;addestramento di modelli di machine learning. Questi fenomeni si verificano quando un modello non riesce a generalizzare bene ai dati, portando a prestazioni scarse sia sui dati di training che su quelli di test. Di seguito esploriamo in dettaglio questi concetti, le loro cause e come evitarli.</p>\n<h2 id=\"introduzione\">Introduzione</h2>\n<p>Quando inferiamo una funzione (un elemento di uno spazio infinito-dimensionale) da un insieme finito di campioni di training, ci sono necessariamente regioni del dominio non coperte dai campioni. In queste regioni, non abbiamo alcuna informazione sul comportamento della funzione (è qui che entrano in gioco i <strong>prior</strong>). Tuttavia, vorremmo che la funzione appresa approssimi bene la funzione vera in generale, non solo sui dati di training, cioè che sia il più generale possibile, anche se questo significa non adattarsi perfettamente ai dati di training.</p>\n<h2 id=\"definizioni\">Definizioni</h2>\n<h3 id=\"overfitting\">Overfitting</h3>\n<p>L&rsquo;<strong>overfitting</strong> si verifica quando il modello è troppo complesso e si adatta eccessivamente ai dati di training, catturando anche il rumore presente nei dati. Questo porta a un errore basso sui dati di training, ma a un errore elevato sui dati di validazione. Il modello, quindi, generalizza male a nuovi dati.</p>\n<p><img alt=\"Underfitting e Overfitting\" src=\"/images/posts/underfitting-overfitting.jpg?resize=1024%2C576&amp;ssl=1\" /></p>\n<h3 id=\"underfitting\">Underfitting</h3>\n<p>L&rsquo;<strong>underfitting</strong> si verifica quando il modello è troppo semplice per catturare la complessità dei dati. Questo porta a un errore elevato sia sui dati di training che sui dati di validazione. In altre parole, il modello non è in grado di rappresentare adeguatamente la relazione tra le variabili indipendenti e la variabile dipendente.</p>\n<h2 id=\"rilevamento-di-underfitting-e-overfitting\">Rilevamento di Underfitting e Overfitting</h2>\n<p>Esiste un modo relativamente semplice per rilevare se stiamo facendo underfitting o overfitting:</p>\n<ol>\n<li><strong>Separazione dei dati</strong>: Dividi i dati noti in due insiemi: il <strong>training set</strong> e il <strong>validation set</strong>.</li>\n<li><strong>Stima dei parametri</strong>: Stima i parametri del modello sul training set in modo da minimizzare la funzione di perdita sui dati di training.</li>\n<li><strong>Underfitting</strong>: Se la perdita è grande sul training set, allora stiamo facendo underfitting, poiché il modello non è in grado di rappresentare bene i dati di training.</li>\n<li><strong>Overfitting</strong>: Se la perdita è piccola sul training set, potremmo essere in overfitting. Per verificarlo, calcola la funzione di perdita sul validation set.</li>\n<li><strong>Conferma dell&rsquo;overfitting</strong>: Se la perdita è grande sul validation set, allora stiamo facendo overfitting, poiché il modello generalizza male su nuovi dati.</li>\n</ol>\n<p>In sintesi:\n- <strong>Underfitting</strong>: Perdita elevata sia sul training set che sul validation set.\n- <strong>Overfitting</strong>: Perdita bassa sul training set ma elevata sul validation set.</p>\n<h2 id=\"k-fold-cross-validation\"><strong>k-Fold Cross-Validation</strong></h2>\n<p>Per difenderci da underfitting e overfitting, uno dei meccanismi più semplici e comunemente utilizzati è la <strong>k-fold cross-validation</strong>.</p>\n<h3 id=\"funzionamento-della-k-fold-cross-validation\">Funzionamento della k-Fold Cross-Validation</h3>\n<p>Il punto chiave della k-fold cross-validation è che non vogliamo overfittare neanche sul validation set. Per evitare ciò, suddividiamo il training set in $k$ sottoinsiemi, chiamati <strong>folds</strong>. Poi, addestriamo il modello su $k-1$ folds e validiamo sul fold rimanente, ripetendo questo processo per ciascun fold (cioè $k$ volte). In questo modo, otteniamo l&rsquo;MSE per ciascun fold e possiamo calcolare la media. Se il modello ottiene un buon punteggio medio su tutti i folds, allora possiamo dire che il modello è buono. Altrimenti, potrebbe essere necessario cambiare il modello.</p>\n<p><img alt=\"Example\" src=\"/images/posts/1zyVG5Y3DCanGQlLS_CbpiQ.png\" /></p>\n<p>Ad esempio, nella regressione polinomiale, possiamo eseguire la k-fold cross-validation più volte con diversi gradi del polinomio e scegliere il grado che produce il più piccolo MSE medio.</p>\n<h2 id=\"conclusione\">Conclusione</h2>\n<p>L&rsquo;underfitting e l&rsquo;overfitting sono problemi critici nell&rsquo;addestramento dei modelli di machine learning. La k-fold cross-validation è uno strumento efficace per mitigare questi problemi, specialmente quando si lavora con modelli complessi come la regressione polinomiale. Tuttavia, è importante considerare altre tecniche e approcci per migliorare la generalizzazione del modello, come la regolarizzazione e l&rsquo;incorporazione di conoscenze aggiuntive.</p>\n<h2 id=\"collegamenti-correlati\">Collegamenti Correlati</h2>\n<ul>\n<li><a href=\"/theory/supervised-learning/Non-Linear Models/Regressione Polinomiale\" class=\"text-blue-600 hover:underline\">Regressione Polinomiale</a></li>\n<li><a href=\"/theory/math-for-ml/Ottimizzazione/Minimi Quadrati Ordinari\" class=\"text-blue-600 hover:underline\">Minimi Quadrati Ordinari</a></li>\n<li><span class=\"text-gray-600\">Teorema di Stone-Weierstrass</span></li>\n<li><span class=\"text-gray-600\">Selezione del Modello</span></li>\n<li><a href=\"/theory/introduction/Regolarizzazione\" class=\"text-blue-600 hover:underline\">Regolarizzazione</a></li>\n</ul>"
}