{
  "title": "Smoothing nei Modelli Linguistici",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<h2 id=\"introduzione\">Introduzione</h2>\n<p>Lo <strong>smoothing</strong> è una tecnica fondamentale per gestire il problema dei <strong>dati sparsi</strong> nei modelli di linguaggio. Senza smoothing:<br />\n- Gli <strong>n-grammi non osservati</strong> nel training ricevono probabilità zero, portando a <strong>perplessità infinita</strong> durante il test.<br />\n- Il modello non può generalizzare a sequenze plausibili ma mai viste.  </p>\n<p>L&rsquo;idea è <strong>ridistribuire la massa di probabilità</strong> dagli n-grammi frequenti a quelli rari o assenti (&ldquo;Rubare ai ricchi per dare ai poveri&rdquo;).  </p>\n<p>In alcune tecniche, viene utilizzato il concetto di sconto (discounting), che ora illustreremo.</p>\n<h3 id=\"discounting\">Discounting</h3>\n<p>Uno <strong>sconto</strong> (discount) è una tecnica usata per ridurre la massa di probabilità di un evento, riconoscendo che il conteggio osservato in un corpus limitato potrebbe essere sottostimato rispetto alla reale probabilità che quell&rsquo;evento si verifichi in un corpus più grande. Formalmente, per un n-gramma con conteggio $c$ si definisce il conteggio ridistribuito $c^*$ come:</p>\n$$\nc^* = c - d \\quad \\text{con } d \\in [0, c],\n$$\n<p>dove $d$ è il valore dello sconto. Il fattore di sconto relativo è quindi:</p>\n$$\nd_c = \\frac{c^*}{c}.\n$$\n<p>Quando calcoliamo la probabilità di un n-gramma (dato un contesto $h$), usiamo il conteggio ridistribuito al posto del conteggio grezzo:</p>\n$$\nP(w|h) = \\frac{c^*}{N(h)},\n$$\n<p>dove $N(h)$ è la somma totale dei conteggi degli n-grammi osservati per quel contesto.  </p>\n<p>Questo approccio ha due scopi fondamentali:<br />\n1. <strong>Ridurre la sovrastima</strong> degli n-grammi osservati frequentemente.<br />\n2. <strong>Riservare parte della massa probabilistica</strong> per quegli n-grammi non osservati, i quali potranno essere poi distribuiti uniformemente (o secondo qualche altra strategia) tra tutti gli eventi &ldquo;mai visti&rdquo; per garantire che ricevano probabilità non nulle.</p>\n<h3 id=\"un-esempio-pratico\">Un Esempio Pratico</h3>\n<p>Immaginiamo un contesto $h$ in cui abbiamo i seguenti n-grammi con i relativi conteggi:</p>\n<table>\n<thead>\n<tr>\n<th>n-gramma</th>\n<th>Conteggio $c$</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$w_1$</td>\n<td>10</td>\n</tr>\n<tr>\n<td>$w_2$</td>\n<td>5</td>\n</tr>\n<tr>\n<td>$w_3$</td>\n<td>2</td>\n</tr>\n<tr>\n<td>$w_4$</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>Supponiamo di impostare uno sconto $d = 0.5$ per ciascun n-gramma osservato.<br />\nI conteggi ridistribuiti $c^*$ diventeranno:  </p>\n<ul>\n<li>Per $w_1$: $c^* = 10 - 0.5 = 9.5$  </li>\n<li>Per $w_2$: $c^* = 5 - 0.5 = 4.5$  </li>\n<li>Per $w_3$: $c^* = 2 - 0.5 = 1.5$  </li>\n<li>$w_4$, che non è mai stato osservato, non subisce discounting: la sua probabilità sarà determinata tramite la massa di probabilità riservata agli eventi non visti.</li>\n</ul>\n<p>La probabilità degli n-grammi osservati diventa quindi:</p>\n$$\nP(w|h) = \\frac{c - d}{N(h)},\n$$\n<p>con $N(h) = 10 + 5 + 2 = 17$ (somma dei conteggi dei n-grammi osservati).</p>\n<p>Per gli n-grammi non osservati (ad esempio $w_4$), si calcola una probabilità separata utilizzando la massa di probabilità riservata, che è la somma degli sconti applicati:</p>\n$$\n\\text{Massa riservata} = \\frac{d \\cdot N_{\\text{unici}}(h)}{N(h)},\n$$\n<p>dove $N_{\\text{unici}}(h)$ è il numero di n-grammi visti almeno una volta per quel contesto. In questo esempio $N_{\\text{unici}}(h) = 3$.</p>\n<p>Quindi, la probabilità per un n-gramma non osservato potrebbe essere distribuita in base a questa massa:</p>\n$$\nP(w_{\\text{non-osservato}}|h) = \\frac{0.5 \\times 3}{17}.\n$$\n<h3 id=\"conclusioni\">Conclusioni</h3>\n<p>Il processo di discounting consente di:\n- <strong>Normalizzare</strong> la probabilità complessiva mantenendo la somma pari a 1.\n- Dare a quegli n-grammi che non sono mai stati osservati (ma che potrebbero verificarsi) una probabilità non nulla.\n- Affrontare il problema dei dati sparsi rendendo il modello più robusto e in grado di generalizzare a sequenze mai viste nel training.</p>\n<p>Questo approccio è essenziale per garantire che i modelli linguistici possano trattare con successo la varietà e la rarità degli eventi presenti nei dati reali.</p>\n<h2 id=\"tecniche-principali\">Tecniche Principali</h2>\n<h3 id=\"1-laplace-add-one-smoothing\">1. <strong>Laplace (Add-One) Smoothing</strong></h3>\n<p>Il Laplace Smoothing, noto anche come add-one smoothing, è una tecnica usata nei modelli di linguaggio probabilistici per gestire il problema degli zeri nelle stime di probabilità. Nei modelli basati su n-grammi, ad esempio, capita spesso che alcune combinazioni di parole non compaiano mai nel corpus di addestramento. Senza smoothing, queste combinazioni avrebbero probabilità pari a zero, il che può compromettere gravemente la generazione o la valutazione di frasi.</p>\n<p>Il Laplace Smoothing risolve questo problema aggiungendo 1 al conteggio di ogni possibile n-gramma. In pratica, anche gli n-grammi mai visti ottengono un conteggio minimo, evitando probabilità nulle. </p>\n<p>Sebbene semplice ed efficace per corpus piccoli, il Laplace Smoothing tende a sovrastimare la probabilità degli eventi rari, penalizzando quelli frequenti. Per questo motivo, in applicazioni avanzate si preferiscono metodi più sofisticati come Good-Turing o Kneser-Ney smoothing. Tuttavia, il Laplace rimane una base utile per comprendere il concetto di smoothing nei modelli di linguaggio.</p>\n<p><strong>Formula (Unigrammi):</strong><br />\n$$\nP_{\\text{Laplace}}(w_i) = \\frac{c(w_i) + 1}{N + V}\n$$<br />\n- $c(w_i)$: conteggio della parola $w_i$.<br />\n- $N$: numero totale di token nel corpus.<br />\n- $V$: dimensione del vocabolario. Questo semplicemente perché abbiamo aggiunto $+1$ per ogni parola.</p>\n<p><strong>Formula generale per n-grammi</strong>:<br />\nPer un n-gramma $w_1, w_2, \\dots, w_n$:<br />\n$$\nP_{\\text{Laplace}}(w_n | w_1, \\dots, w_{n-1}) = \\frac{c(w_1, \\dots, w_n) + 1}{\\sum_{w}c(w_1, \\dots, w_{n-1} w)+ 1} = \\frac{c(w_1, \\dots, w_n) + 1}{c(w_1, \\dots, w_{n-1}) + V}\n$$<br />\ndove $c(w_1, \\dots, w_{n-1})$ è il conteggio del contesto $(w_1, \\dots, w_{n-1})$ e $V$ la dimensione del vocabolario (sempre perché abbiamo aggiunto $+1$ per ogni n-gramma con prefix $(w_1, \\dots, w_{n-1})$).</p>\n<p><strong>Ridistribuzione dei conteggi</strong>:</p>\n<p>Possiamo ottenere i conteggi risultati dall&rsquo;applicazione dello smoothing con la seguente formula:<br />\n$$\nP_{\\text{Laplace}}(w_n | w_1, \\dots, w_{n-1}) = \\frac{c(w_1, \\dots, w_n) + 1}{c(w_1, \\dots, w_{n-1}) + V} = \\frac{c^*(w_1, \\dots, w_n)}{c(w_i, \\ldots, w_{n-1})} \\Rightarrow c^*(w_1, \\dots, w_n) = \\frac{(c(w_1, \\dots, w_n) + 1) \\cdot c(w_1, \\dots, w_{n-1})}{c(w_1, \\dots, w_{n-1}) + V}.\n$$</p>\n<p>In questo modo possiamo confrontare direttamente i conteggi ridistribuiti con quelli originali (MLE).</p>\n<p><strong>Esempio</strong>:<br />\nSe $N=1000$ e $V=500$, un bigramma &ldquo;gatto felice&rdquo; con $c=3$ (e contesto &ldquo;gatto&rdquo; che appare 10 volte):<br />\n$$\nP_{\\text{Laplace}} = \\frac{3 + 1}{10 + 500} = \\frac{4}{510} \\approx 0.0078\n$$<br />\nConteggio ridistribuito:<br />\n$$\nc^* = \\frac{(3 + 1) \\cdot 10}{10 + 500} = \\frac{40}{510} \\approx 0.078\n$$</p>\n<p><strong>Problema</strong>:<br />\n- Sovrastima degli eventi rari per $V$ grandi (es. $V=10^5$). Per un bigramma mai visto &ldquo;gatto volante&rdquo;, con contesto &ldquo;gatto&rdquo; ($c=10$):<br />\n$$\nP_{\\text{Laplace}} = \\frac{0 + 1}{10 + 500} = \\frac{1}{510} \\approx 0.00196.\n$$</p>\n<hr />\n<h3 id=\"2-add-math_inline_94-smoothing\">2. Add-$k$ Smoothing</h3>\n<p>Un&rsquo;alternativa all&rsquo;add-one smoothing è spostare una quantità minore di massa probabilistica dagli eventi osservati a quelli non osservati. Invece di aggiungere 1 a ogni conteggio, aggiungiamo un conteggio frazionario $0 \\leq k \\leq 1$. Questo algoritmo è quindi chiamato add-$k$ smoothing.</p>\n$$\nP_{Add-k}(w_n |w_1, \\ldots, w_{n−1}) = \\frac{c(w_1, \\ldots, w_n) + k}{c(w_1, \\ldots, w_{n-1}) + kV} = \\frac{c^*(w_1, \\dots, w_n)}{c(w_i, \\ldots, w_{n-1})} \\Rightarrow c^*(w_1, \\dots, w_n) = \\frac{(c(w_1, \\dots, w_n) + k) \\cdot c(w_1, \\dots, w_{n-1})}{c(w_1, \\dots, w_{n-1}) + kV}.\n$$\n<p>L&rsquo;add-$k$ smoothing richiede che si abbia un metodo per scegliere $k$; questo può essere fatto, ad esempio, ottimizzando su un devset. Sebbene l&rsquo;add-$k$ sia utile per alcune attività (inclusa la classificazione di testi), risulta comunque non funzionare bene per la modellazione linguistica, generando conteggi con varianze scarse e spesso sconti inappropriati.</p>\n<hr />\n<h3 id=\"3-good-turing-smoothing\">3. <strong>Good-Turing Smoothing</strong></h3>\n<h4 id=\"definizione\"><strong>Definizione</strong></h4>\n<p>Il <strong>Good-Turing smoothing</strong> è una tecnica statistica fondamentale per stimare la probabilità di token rari o non osservati in un dataset. È particolarmente utile nei modelli linguistici (ad esempio, per $n$-gram) perché permette di ridistribuire la massa probabilistica dagli token frequenti a quelli che non sono stati mai osservati, migliorando così la robustezza del modello anche in presenza di dati scarsi.</p>\n<h4 id=\"formula-principale\"><strong>Formula Principale</strong></h4>\n<p>Per un token osservato $k$ volte, la probabilità scontata è:<br />\n$$\nP_{\\text{GT}}(w) = \\frac{k^*}{N}, \\quad \\text{dove } k^* = \\frac{(k+1) \\cdot N_{k+1}}{N_k},  \n$$<br />\n- $N_k$ = numero di token osservati <strong>esattamente</strong> $k$ volte nel corpus,<br />\n- $N$ = numero totale di token osservati ($N = \\sum_{k=1}^\\infty k \\cdot N_k$).  </p>\n<p><strong>Probabilità per Token non osservati</strong> ($k=0$):<br />\n$$\nP_{\\text{GT}}(w_{\\text{new}}) = \\frac{N_1}{N}.  \n$$</p>\n<p>Ovviamente i token non osservati sono quelli che non sono stati mai osservati nel corpus (training set), ma che sono presenti nel vocabolario $V$.</p>\n<h4 id=\"intuizione\">Intuizione</h4>\n<p>L&rsquo;idea fondamentale del Good-Turing smoothing è quella di “riutilizzare” il corpus come un set di validazione per stimare la probabilità sia dei token già osservati sia di quelli che non abbiamo mai visto. La chiave del seguente ragionamento non è più la probabilità di un token di apparire in un testo, ma la probabilità che un certo token appaia con una certa frequenza. Quello che ci chiediamo è: quale frequenza mi aspetto per il prossimo token? e non più: quale probabilità mi aspetto per il prossimo token?</p>\n<p>Immagina di avere un cesto di frutta e di voler prevedere quale frutto potresti trovare in più, anche se non lo hai mai visto o l&rsquo;hai visto pochissimo. Il Good-Turing smoothing è una tecnica che ci aiuta proprio a fare questo: usa le informazioni sulle frequenze dei frutti per stimare la loro probabilità.</p>\n<p>Assumiamo quindi di avere il seguente corpus $C$:</p>\n<table>\n<thead>\n<tr>\n<th>Frutto</th>\n<th>Frequenza</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>🍌</td>\n<td>5</td>\n</tr>\n<tr>\n<td>🍎</td>\n<td>3</td>\n</tr>\n<tr>\n<td>🍊</td>\n<td>2</td>\n</tr>\n<tr>\n<td>🍒</td>\n<td>2</td>\n</tr>\n<tr>\n<td>🍉</td>\n<td>1</td>\n</tr>\n<tr>\n<td>🍇</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>e il seguente vocabolario: </p>\n$$\nV = \\{ \\text{🍌}, \\text{🍎}, \\text{🍊}, \\text{🍒}, \\text{🍉}, \\text{🍇} \\}\n$$\n<p>In questo contesto, $N_0$ è il numero di token osservati 0 volte ($N_0 = 1$ in questo caso), $N_1$ il numero di token osservati 1 volta, e cosi via.</p>\n<p>Per stimare la probabilità di trovare un 🍇 nel mondo reale, il Good-Turing smoothing utilizza il seguente ragionamento: se il prossimo token fosse 🍇, avrebbe molteplicità 1 nel corpus (perché avrei visto 🍇 per la prima volta). Quindi, se così fosse, avrei che questa situazione ha probabilità $\\frac{1}{13}$, perché nel corpus per ora ho solo un elemento con molteplicità $1$ (🍉). E quindi un altro elemento di molteplicità $1$ ha probabilità $\\frac{1}{13}$.</p>\n<p>Questo ragionamento può estendersi tranquillamente per i token che già appaiono nel corpus. Considerando ad esempio il token 🍒, e chiediamoci qual è la probabilità che appaia di nuovo. Dato che 🍒 appare già 2 volte ($k=2$), se incontrassimo un altro 🍒, ne avremmo 3. Ora, la probabilità di apparire di nuovo di un token di frequenza 2 è la stessa che ha un token di frequenza 3 di apparire nel corpus, che è:\n$$\n\\frac{(k+1) \\cdot N_{k+1}}{N} = \\frac{3 \\cdot 1}{13} = \\frac{3}{13}.\n$$</p>\n<p>Questo però non basta, perché questa è la probabilità che un <strong>generico</strong> frutto con molteplicità 2 diventi di molteplicità 3, quindi (dato che noi vogliamo la probabilità di un unico token) dobbiamo dividere questa probabilità per il numero di frutti con molteplicità 2 nel corpus ($N_2 = 2$). Quindi, la probabilità per il token 🍒 diventa:</p>\n$$\n\\frac{(k+1) \\cdot N_{k+1}}{N \\cdot N_2} = \\frac{3 \\cdot 1}{13 \\cdot 2} = \\frac{3}{26}.\n$$\n<p>In questo contesto, possiamo definire anche $k^*$ come il conteggio atteso di un token con molteplicità $k$ nel corpus $C$ come segue:</p>\n<p>(Numero di volte che un token con molteplicità $k$ apparirebbe nel corpus se venisse osservato un&rsquo;ulteriore volta) x (Numero di classi con la stessa (nuova) molteplicità nel corpus) / (Numero di classi che potenzialmente possono essere &ldquo;promosse&rdquo; a molteplicità $k+1$ nel corpus).</p>\n<p>In formule, </p>\n$$\nk^* = (k+1) \\cdot \\frac{N_{k+1}}{N_k}.\n$$\n<p>Intuitivamente, se:</p>\n<ul>\n<li>$N_{k+1} > N_k$, allora significa che la porzione delle frequenze che hanno molteplicità $k+1$ nel corpus, sono maggiori di quelle che hanno molteplicità $k$ nel corpus. E quindi un token con molteplicità $k$ più probabilmente deve essere promosso a molteplicità $k+1$.</li>\n<li>$N_{k+1} = N_k$, allora significa che se osserviamo un nuovo token con molteplicità $k$, esso arriverà a molteplicità $k+1$. Quindi è come se il modello dicesse: &ldquo;non ho evidenze per correggere il conteggio che ho ora, quindi mi limito ad aumentarlo di 1 in via cautelativa&rdquo;.</li>\n<li>$N_{k+1} < N_k$, allora significa che la porzione delle frequenze che hanno molteplicità $k$ nel corpus, sono maggiori di quelle che hanno molteplicità $k+1$ nel corpus. E quindi un token con molteplicità $k$ più probabilmente rimarrà con molteplicità $k$ invece di essere promosso a molteplicità $k+1$. </li>\n</ul>\n<p>Questo era un esempio di utilizzo in un unigramma, ma questo discorso vale per $N$-grammi in generale.</p>\n<h4 id=\"limiti-e-considerazioni\">Limiti e Considerazioni</h4>\n<p>Il Good-Turing smoothing, pur essendo estremamente utile, presenta alcune limitazioni e aspetti da considerare:</p>\n<ol>\n<li>\n<p><strong>Instabilità quando $N_{k+1} = 0$</strong>:<br />\n   Se per un determinato $k$ non esistono Token osservati $k+1$ volte, la formula per $k^*$ non può essere calcolata, rendendo il metodo inapplicabile in quei casi. In questo caso, si utilizzano metodi per stimare anche il valore di $N_{k+1}$ (e.g. <a href=\"/theory/supervised-learning/Linear Models/Regressione Lineare\" class=\"text-blue-600 hover:underline\">Regressione Lineare</a>).</p>\n</li>\n<li>\n<p><strong>Ridotta Efficacia per Token ad Alta Frequenza</strong>:<br />\n   Per Token molto frequenti (tipicamente per $k \\geq 5$), il metodo può risultare meno efficace, poiché la stima diventa meno significativa.</p>\n</li>\n<li>\n<p><strong>Complessità Computazionale</strong>:<br />\n   Calcolare $N_k$ per ogni valore di $k$ può essere oneroso, soprattutto in corpus di grandi dimensioni. In tali contesti, possono essere necessarie semplificazioni o tecniche approssimative per rendere il calcolo computazionalmente gestibile.</p>\n</li>\n</ol>\n<hr />\n<h3 id=\"4-absolute-discounting\">4. <strong>Absolute Discounting</strong></h3>\n<p>L&rsquo;<strong>Absolute Discounting</strong> è una tecnica di smoothing che applica uno <strong>sconto fisso</strong> $d$ a tutti gli n-grammi con conteggio positivo. L’idea di base è simile al concetto generale di discounting: si sottrae una quantità fissa dal conteggio di ogni n-gramma osservato e si <strong>ridistribuisce la massa probabilistica risparmiata</strong> agli eventi non osservati.</p>\n<h4 id=\"formula\"><strong>Formula</strong></h4>\n<p>Per un bigramma $w_{n-1}, w_n$ con conteggio $c(w_{n-1}, w_n)$, la probabilità scontata viene calcolata come:</p>\n$$\nP_{\\text{Abs}}(w_n | w_{n-1}) =\n\\frac{\\max(c(w_{n-1}, w_n) - d, 0)}{c(w_{n-1})} + \\lambda(w_{n-1}) \\cdot P_{\\text{backoff}}(w_n)\n$$\n<ul>\n<li>$d$: valore dello sconto (tipicamente tra 0.5 e 1.0, scelto empiricamente o stimato).</li>\n<li>$\\lambda(w_{n-1})$: fattore di normalizzazione per il contesto $w_{n-1}$.</li>\n<li>$P_{\\text{backoff}}(w_n)$: probabilità stimata da un modello di ordine inferiore (es. unigramma).</li>\n</ul>\n<h4 id=\"calcolo-di-math_inline_153\"><strong>Calcolo di $\\lambda(w_{n-1})$</strong></h4>\n<p>Il termine $\\lambda(w_{n-1})$ rappresenta <strong>la massa di probabilità riassegnata</strong> ai bigrammi non osservati. Si calcola come:</p>\n$$\n\\lambda(w_{n-1}) = \\frac{d \\cdot N_{+}(w_{n-1})}{c(w_{n-1})}\n$$\n<p>dove:\n- $N_{+}(w_{n-1})$ è il numero di bigrammi diversi che iniziano con $w_{n-1}$ e hanno conteggio positivo.</p>\n<h4 id=\"esempio-pratico\"><strong>Esempio Pratico</strong></h4>\n<p>Supponiamo di avere il seguente contesto $w_{n-1} = \\text{\"gatto\"}$ con questi bigrammi:</p>\n<table>\n<thead>\n<tr>\n<th>Bigramma</th>\n<th>Conteggio</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>(&ldquo;gatto&rdquo;, &ldquo;mangia&rdquo;)</td>\n<td>5</td>\n</tr>\n<tr>\n<td>(&ldquo;gatto&rdquo;, &ldquo;corre&rdquo;)</td>\n<td>3</td>\n</tr>\n<tr>\n<td>(&ldquo;gatto&rdquo;, &ldquo;salta&rdquo;)</td>\n<td>2</td>\n</tr>\n<tr>\n<td>(&ldquo;gatto&rdquo;, &ldquo;parla&rdquo;)</td>\n<td>0</td>\n</tr>\n</tbody>\n</table>\n<p>Totale conteggi per &ldquo;gatto&rdquo;:<br />\n$$\nc(\\text{\"gatto\"}) = 5 + 3 + 2 = 10\n$$</p>\n<p>Applichiamo uno sconto $d = 0.75$. I conteggi scontati diventano:</p>\n<ul>\n<li>(&ldquo;gatto&rdquo;, &ldquo;mangia&rdquo;): $5 - 0.75 = 4.25$  </li>\n<li>(&ldquo;gatto&rdquo;, &ldquo;corre&rdquo;): $3 - 0.75 = 2.25$  </li>\n<li>(&ldquo;gatto&rdquo;, &ldquo;salta&rdquo;): $2 - 0.75 = 1.25$</li>\n</ul>\n<p>Numero di bigrammi osservati: $N_{+}(\\text{\"gatto\"}) = 3$</p>\n<p>Calcoliamo $\\lambda(\\text{\"gatto\"})$:</p>\n$$\n\\lambda(\\text{\"gatto\"}) = \\frac{0.75 \\cdot 3}{10} = 0.225\n$$\n<p>La probabilità per i bigrammi osservati diventa:</p>\n$$\nP(\\text{\"mangia\"}|\\text{\"gatto\"}) = \\frac{4.25}{10} = 0.425  \n$$\n<p>La probabilità per un bigramma non osservato come (&ldquo;gatto&rdquo;, &ldquo;parla&rdquo;) sarà determinata tramite backoff:</p>\n$$\nP(\\text{\"parla\"}|\\text{\"gatto\"}) = 0.225 \\cdot P_{\\text{unigram}}(\\text{\"parla\"})\n$$\n<h4 id=\"vantaggi\"><strong>Vantaggi</strong></h4>\n<ul>\n<li>Più accurato del Laplace/Add-$k$, in quanto riduce i conteggi solo per n-grammi <strong>osservati</strong>.</li>\n<li>È una base del più sofisticato <strong>Kneser-Ney smoothing</strong>.</li>\n</ul>\n<h4 id=\"limiti\"><strong>Limiti</strong></h4>\n<ul>\n<li>Richiede un buon stimatore per $d$ (può essere stimato da un dev set o con metodi come Good-Turing).</li>\n<li>Può sottostimare gli n-grammi frequenti se $d$ è scelto male.</li>\n<li>Viene utilizzato un modello di ordine inferiore per il backoff, e questo può portare a problemi di generalizzazione.</li>\n</ul>\n<h3 id=\"5-kneser-ney-smoothing-stato-dellarte\">5. <strong>Kneser-Ney Smoothing (Stato dell&rsquo;Arte)</strong></h3>\n<p>Il Kneser-Ney smoothing è considerato il metodo più efficace per la modellazione linguistica con $n$-grammi, combinando <strong>sconti dinamici</strong> e una <strong>probabilità di continuazione</strong> per gestire contesti non osservati e ridurre il bias verso parole frequenti in contesti specifici.</p>\n<h4 id=\"formula-base\"><strong>Formula Base</strong></h4>\n<p>Usando l&rsquo;intuizione che deriva dall&rsquo;Absolute Discounting e sostituendo la probabilità di un modello di ordine inferiore con una <strong>probabilità di continuazione</strong>, otteniamo (nel caso di un bigramma) la seguente formula:</p>\n$$\nP_{\\text{KN}}(w_i | w_{i-1}) = \\underbrace{\\frac{\\max(c(w_{i-1}, w_i) - d, 0)}{c(w_{i-1})}}_{\\text{Probabilità del bigramma scontato}} + \\underbrace{\\lambda(w_{i-1})}_\\text{Fattore di interpolazione} \\cdot \\underbrace{P_{\\text{cont}}(w_i)}_\\text{Probabilità di continuazione}\n$$<br />\n- <strong>$d$</strong>: Fattore di sconto (tipicamente $d = 0.75$).<br />\n- <strong>$P_{\\text{cont}}(w_i)$</strong>: Probabilità di continuazione (quanti bigrammi completa $w_i$), definita come:<br />\n  $$\n  P_{\\text{cont}}(w_i) = \\frac{|\\{w_{i-1} : c(w_{i-1}, w_i) > 0\\}|}{|\\{(w_{j-1}, w_j) : c(w_{j-1}, w_j) > 0\\}|}\n  $$<br />\n  - Numeratore: Numero di contesti <strong>diversi</strong> in cui $w_i$ appare.<br />\n  - Denominatore: Numero totale di bigrammi <strong>diversi</strong> osservati nel corpus.</p>\n<ul>\n<li><strong>$\\lambda(w_{i-1})$</strong>: Fattore di interpolazione per garantire che la somma delle probabilità sia 1:<br />\n  $$\n  \\lambda(w_{i-1}) = \\underbrace{\\frac{d}{c(w_{i-1})}}_{\\text{sconto normalizzato}} \\cdot \\overbrace{\\underbrace{\\underbrace{|\\{w_i : c(w_{i-1}, w_i) > 0\\}|}_{\\text{Numero di bigrammi diversi in cui $w_i$ appare}}}_\\text{Numero di volte che abbiamo applicato lo sconto}}^{\\text{Numero di bigrammi scontati}}\n  $$</li>\n</ul>\n<p>In generale:</p>\n<p>Per un generico n-gramma $w_{i-n+1}, \\dots, w_{i-1}, w_i$:  </p>\n<p>$$\nP_{\\text{KN}}(w_i | w_{i-n+1}^{i-1}) = \\frac{\\max\\left(c(w_{i-n+1}^{i}) - d,\\, 0\\right)}{c(w_{i-n+1}^{i-1})} + \\lambda(w_{i-n+1}^{i-1}) \\cdot P_{\\text{KN}}(w_i | w_{i-n+2}^{i-1})\n$$\n<p>Dove:\n- <strong>Sconto</strong> ($d$):<br />\n  Valore fisso (es. $d = 0.75$).<br />\n- <strong>Fattore di interpolazione</strong> ($\\lambda$):<br />\n  $$\n  \\lambda(w_{i-n+1}^{i-1}) = \\frac{d \\cdot |\\{w_i : c(w_{i-n+1}^{i}) > 0\\}|}{c(w_{i-n+1}^{i-1})}\n  $$<br />\n  dove $|\\{w_i : c(w_{i-n+1}^{i}) > 0\\}|$ è il numero di <strong>parole distinte</strong> che seguono il contesto $w_{i-n+1}^{i-1}$.  </p>\n<ul>\n<li><strong>Probabilità di continuazione</strong> (ricorsiva):  </li>\n<li><strong>Numeratore</strong>: Contesti distinti $w_{i-n+1}$ per $w_{i-n+2}^{i}$.  </li>\n<li><strong>Denominatore</strong>: Totale n-grammi unici nel corpus. \n$$\nP_{\\text{KN}}(w_i | w_{i-n+2}^{i-1}) = \\frac{\\max\\left(c(w_{i-n+2}^{i}) - d,\\, 0\\right)}{c(w_{i-n+2}^{i-1})} + \\lambda(w_{i-n+2}^{i-1}) \\cdot P_{\\text{KN}}(w_i | w_{i-n+3}^{i-1}).\n$$</li>\n</ul>\n<p>Alla fine della ricorsione otteniamo la formula per gli unigrammi:</p>\n$$\nP_{KN}(w) = \\frac{\\max(c(w) - d, 0)}{\\underbrace{\\sum_{w_i} c(w_i)}_\\text{Somma totale dei conteggi di tutte le parole}} + \\lambda(\\epsilon) \\frac{1}{V}\n$$\n<p>Se vogliamo includere una parola sconosciuta <code>&lt;UNK&gt;</code>, la trattiamo semplicemente come una normale voce del vocabolario con conteggio pari a zero.<br />\nDi conseguenza, la sua probabilità sarà una distribuzione uniforme pesata dal fattore $\\lambda$:</p>\n$$\nP(<\\!UNK\\!>) = \\lambda(\\varepsilon) \\cdot \\frac{1}{V}\n$$\n<p>dove:\n- $\\varepsilon$ è la stringa vuota,\n- $V$ è la dimensione del vocabolario.</p>\n<h4 id=\"intuizione-per-sconto-e-probabilita-di-continuazione\">Intuizione per Sconto e Probabilità di Continuazione</h4>\n<ol>\n<li>\n<p><strong>Sconto (Discounting)</strong>:<br />\n   Riduce i conteggi degli $n$-grammi osservati per &ldquo;riservare&rdquo; massa probabilistica agli eventi non osservati.<br />\n   Questo sconto penalizzerà di meno il conteggio di parole molto frequenti (quelle di cui ci fidiamo di più) e di più il conteggio di parole poco frequenti (quelle di cui ci fidiamo di meno). </p>\n</li>\n<li>\n<p><strong>Probabilità di Continuazione</strong>:<br />\n   Misura quanto una parola $w_i$ è <strong>versatile</strong> nell&rsquo;apparire in contesti diversi.  </p>\n</li>\n<li>Penalizza parole come &ldquo;Francisco&rdquo; che appaiono spesso solo in contesti specifici (es. dopo &ldquo;San&rdquo;).  </li>\n<li>Premia parole come &ldquo;the&rdquo; o &ldquo;di&rdquo; che appaiono in molti contesti.  </li>\n</ol>\n<h4 id=\"intuizione-per-math_inline_187\">Intuizione per $\\lambda(w_{i-n+1}^{i-1})$</h4>\n<p>L&rsquo;interpretazione intuitiva di $\\lambda(w_{i-n+1}^{i-1})$ si articola in tre componenti principali:</p>\n<ol>\n<li>\n<p><strong>Sconto Normalizzato $\\frac{d}{c(w_{i-n+1}^{i-1})}$:</strong><br />\n   Questo termine rappresenta la frazione della probabilità totale associata al contesto $w_{i-n+1}^{i-1}$ che viene &ldquo;tolta&rdquo; per ciascun n-gramma osservato in quel contesto. Il parametro $d$ è lo sconto fisso applicato, e dividendolo per $c(w_{i-n+1}^{i-1})$ (ovvero il numero totale di occorrenze del contesto $w_{i-n+1}^{i-1}$) si ottiene il <strong>peso</strong> o <strong>quota</strong> di probabilità ridotta per ogni occorrenza.</p>\n</li>\n<li>\n<p><strong>Numero di n-grammi Scontati $|\\{w_i : c(w_{i-n+1}^{i}) > 0\\}|$:</strong><br />\n   Questo termine conta il numero di n-grammi distinti che completano il contesto $w_{i-n+1}^{i-1}$ e che sono stati osservati almeno una volta. In altre parole, esso indica <strong>quante volte lo sconto $d$ viene applicato</strong> all&rsquo;interno del contesto specificato, ovvero quante volte abbiamo &ldquo;rimosso&rdquo; una parte della probabilità dagli n-grammi osservati.</p>\n</li>\n<li>\n<p><strong>Prodotto delle Due Componenti:</strong><br />\n   Moltiplicando il <strong>sconto normalizzato</strong> per il <strong>numero di n-grammi scontati</strong>, si ottiene la <strong>massa totale di probabilità</strong> che è stata sottratta dagli eventi osservati nel contesto $w_{i-n+1}^{i-1}$. Questa massa di probabilità viene poi utilizzata nel meccanismo di backoff (o interpolazione) per garantire che la somma complessiva delle probabilità, comprese quelle dei n-grammi non osservati, risulti pari a 1.</p>\n</li>\n</ol>\n<p>In sintesi, <strong>$\\lambda(w_{i-n+1}^{i-1})$</strong> raccoglie il &ldquo;peso&rdquo; persa a causa dello sconto applicato a tutti gli n-grammi che seguono il contesto $w_{i-n+1}^{i-1}$, e tale massa viene poi ridistribuita al modello inferiore. Questo meccanismo assicura una distribuzione di probabilità completa e normalizzata anche quando alcuni n-grammi non sono stati osservati durante il training.</p>\n<h4 id=\"dimostrazione-che-math_inline_200\">Dimostrazione che $\\sum P_{\\text{KN}}(w_i | w_{i-n+1}^{i-1}) = 1$</h4>\n<p>Consideriamo la formula per un bigramma:</p>\n$$\nP_{\\text{KN}}(w_i | w_{i-1}) = \\frac{\\max(c(w_{i-1}, w_i) - d, 0)}{c(w_{i-1})} + \\lambda(w_{i-1}) \\cdot P_{\\text{cont}}(w_i)\n$$\n<p>dove il fattore di interpolazione è definito come</p>\n$$\n\\lambda(w_{i-1}) = \\frac{d}{c(w_{i-1})} \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|.\n$$\n<p><strong>Passo 1: Sommiamo $P_{\\text{KN}}(w_i | w_{i-1})$ su tutti i possibili $w_i$:</strong></p>\n$$\n\\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-1}) = \\sum_{w_i} \\frac{\\max(c(w_{i-1}, w_i) - d, 0)}{c(w_{i-1})} + \\lambda(w_{i-1}) \\sum_{w_i} P_{\\text{cont}}(w_i)\n$$\n<p>Sappiamo per certo che $P_{\\text{cont}}(w_i)$ sia una distribuzione di probabilità valida, ovvero</p>\n$$\n\\sum_{w_i} P_{\\text{cont}}(w_i) = 1.\n$$\n<p><strong>Passo 2: Scomponiamo la somma per i bigrammi osservati.</strong></p>\n<p>Per ogni $w_i$ tale che $c(w_{i-1}, w_i) > 0$ abbiamo:</p>\n$$\n\\max(c(w_{i-1}, w_i) - d, 0) = c(w_{i-1}, w_i) - d.\n$$\n<p>Quindi, sommando su tutti i $w_i$ osservati otteniamo:</p>\n$$\n\\sum_{\\{w_i: c(w_{i-1},w_i) > 0\\}} \\bigl[c(w_{i-1}, w_i)-d\\bigr] \n= \\left(\\sum_{\\{w_i: c(w_{i-1},w_i) > 0\\}} c(w_{i-1}, w_i)\\right) - d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|.\n$$\n<p>Notiamo che</p>\n$$\n\\sum_{\\{w_i: c(w_{i-1},w_i) > 0\\}} c(w_{i-1}, w_i) = c(w_{i-1}),\n$$\n<p>pertanto si ha:</p>\n$$\n\\sum_{\\{w_i: c(w_{i-1},w_i) > 0\\}} \\bigl[c(w_{i-1}, w_i)-d\\bigr] = c(w_{i-1}) - d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|.\n$$\n<p><strong>Passo 3: Inseriamo il tutto nella sommatoria totale.</strong></p>\n<p>Dividendo per $c(w_{i-1})$ si ottiene:</p>\n$$\n\\sum_{w_i} \\frac{\\max(c(w_{i-1},w_i)-d,0)}{c(w_{i-1})} \n= \\frac{c(w_{i-1}) - d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|}{c(w_{i-1})}.\n$$\n<p>Per la parte del backoff abbiamo:</p>\n$$\n\\lambda(w_{i-1}) \\cdot \\sum_{w_i} P_{\\text{cont}}(w_i) = \\lambda(w_{i-1}) \\cdot 1 = \\lambda(w_{i-1}).\n$$\n<p>Quindi, la somma totale diventa:</p>\n$$\n\\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-1}) \n= \\frac{c(w_{i-1}) - d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|}{c(w_{i-1})} + \\lambda(w_{i-1}).\n$$\n<p><strong>Passo 4: Verifica del vincolo di normalizzazione.</strong></p>\n<p>Sostituendo la definizione di $\\lambda(w_{i-1})$:</p>\n$$\n\\lambda(w_{i-1}) = \\frac{d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|}{c(w_{i-1})},\n$$\n<p>si ottiene:</p>\n$$\n\\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-1}) = \\frac{c(w_{i-1}) - d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|}{c(w_{i-1})} + \\frac{d \\cdot |\\{w_i : c(w_{i-1}, w_i) > 0\\}|}{c(w_{i-1})} = \\frac{c(w_{i-1})}{c(w_{i-1})} = 1.\n$$\n<p>$\\square$</p>\n<p><strong>Conclusione per il Caso Generale (n-grammi):</strong></p>\n<p>La stessa logica si estende al caso degli n-grammi tramite la formulazione ricorsiva:</p>\n$$\nP_{\\text{KN}}(w_i | w_{i-n+1}^{i-1}) = \\frac{\\max(c(w_{i-n+1}^{i}) - d,\\,0)}{c(w_{i-n+1}^{i-1})} + \\lambda(w_{i-n+1}^{i-1}) \\cdot P_{\\text{KN}}(w_i | w_{i-n+2}^{i-1}),\n$$\n<p>con</p>\n$$\n\\lambda(w_{i-n+1}^{i-1}) = \\frac{d \\cdot |\\{w_i : c(w_{i-n+1}^{i}) > 0\\}|}{c(w_{i-n+1}^{i-1})}.\n$$\n<p><strong>Argomentazione per Induzione:</strong></p>\n<ol>\n<li><strong>Base dell&rsquo;induzione (n = 2 – bigrammi):</strong><br />\n   Abbiamo dimostrato che</li>\n</ol>\n$$\n   \\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-1}) = 1.\n   $$\n<ol>\n<li><strong>Passo induttivo:</strong><br />\n   Supponiamo che per un modello di ordine $n-1$ (cioè con condizione $w_{i-n+2}^{i-1}$) la proprietà di normalizzazione sia soddisfatta:</li>\n</ol>\n$$\n   \\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-n+2}^{i-1}) = 1.\n   $$\n<p>Allora, considerando la formula ricorsiva per il modello di ordine $n$:</p>\n$$\n   \\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-n+1}^{i-1}) = \\sum_{w_i} \\left[ \\frac{\\max(c(w_{i-n+1}^{i}) - d,\\,0)}{c(w_{i-n+1}^{i-1})} \\right] + \\lambda(w_{i-n+1}^{i-1}) \\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-n+2}^{i-1}).\n   $$\n<p>Utilizzando l&rsquo;ipotesi induttiva $\\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-n+2}^{i-1}) = 1$ e seguendo i medesimi passaggi del caso bigramma, si ottiene:</p>\n$$\n   \\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-n+1}^{i-1}) = \\frac{c(w_{i-n+1}^{i-1}) - d \\cdot |\\{w_i : c(w_{i-n+1}^{i}) > 0\\}|}{c(w_{i-n+1}^{i-1})} + \\lambda(w_{i-n+1}^{i-1}) = 1.\n   $$\n<p>Pertanto, per induzione, la proprietà di normalizzazione vale per qualsiasi ordine $n$:</p>\n$$\n\\sum_{w_i} P_{\\text{KN}}(w_i | w_{i-n+1}^{i-1}) = 1.\n$$\n<p>$\\square$</p>\n<h4 id=\"variante-del-kneser-ney\"><strong>Variante del Kneser-Ney</strong></h4>\n<ol>\n<li><strong>Modified Kneser-Ney</strong>:<br />\n   Usa <strong>sconti differenziati</strong> per conteggi $c = 1$, $c = 2$, e $c \\geq 3$:  </li>\n<li>$d_1 = 0.75$ (per $c=1$),  </li>\n<li>$d_2 = 0.5$ (per $c=2$),  </li>\n<li>$d_3 = 0.25$ (per $c \\geq 3$).</li>\n</ol>\n<h4 id=\"vantaggi_1\"><strong>Vantaggi</strong></h4>\n<ol>\n<li><strong>Gestione ottimale delle parole comuni</strong>:  </li>\n<li>&ldquo;Francisco&rdquo; avrà bassa $P_{\\text{cont}}$ perché appare solo dopo &ldquo;San&rdquo;.  </li>\n<li>\n<p>&ldquo;the&rdquo; avrà alta $P_{\\text{cont}}$ perché appare in molti contesti.  </p>\n</li>\n<li>\n<p><strong>Adattabilità a contesti sparsi</strong>:<br />\n   Usa informazioni degli $n$-grammi di ordine inferiore in modo più efficace rispetto a Good-Turing.  </p>\n</li>\n<li>\n<p><strong>Performance superiori</strong>:<br />\n   È lo standard per modelli linguistici in task come traduzione automatica e riconoscimento vocale.  </p>\n</li>\n</ol>\n<h4 id=\"limiti_1\"><strong>Limiti</strong></h4>\n<ol>\n<li>\n<p><strong>Complessità computazionale</strong>:<br />\n   Richiede il calcolo di $P_{\\text{cont}}$ per tutte le parole e contesti, costoso per corpus di grandi dimensioni.  </p>\n</li>\n<li>\n<p><strong>Scelta dei parametri</strong>:<br />\n   Il valore di $d$ e la variante (interpolated vs modified) influenzano significativamente i risultati.    </p>\n</li>\n</ol>\n<h2 id=\"tabella-di-confronto\">Tabella di Confronto</h2>\n<table>\n<thead>\n<tr>\n<th><strong>Metodo</strong></th>\n<th><strong>Idee Chiave</strong></th>\n<th><strong>Vantaggi</strong></th>\n<th><strong>Svantaggi</strong></th>\n<th><strong>Casi d&rsquo;Uso</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Laplace (Add-One)</strong></td>\n<td>Aggiunge 1 al conteggio di ogni n-gramma per evitare probabilità zero.</td>\n<td>Semplice da implementare.</td>\n<td>Sovrastima eventi rari, inefficace per vocabolari grandi ($V$ elevato).</td>\n<td>Corpus piccoli, prototipazione.</td>\n</tr>\n<tr>\n<td><strong>Add-$k$</strong></td>\n<td>Aggiunge un conteggio frazionario $k$ (es. 0.5) invece di 1.</td>\n<td>Più flessibile di Laplace.</td>\n<td>Difficoltà nella scelta di $k$, varianza elevata, sconti inappropriati.</td>\n<td>Classificazione testi, task specifici.</td>\n</tr>\n<tr>\n<td><strong>Good-Turing</strong></td>\n<td>Ridistribuisce massa dagli eventi frequenti a quelli rari usando $N_k$.</td>\n<td>Fondamento teorico solido.</td>\n<td>Instabile per $N_{k+1}=0$, complessità computazionale, inefficace per $k$ alti.</td>\n<td>Corpus medi, modelli con sparsità.</td>\n</tr>\n<tr>\n<td><strong>Kneser-Ney</strong></td>\n<td>Combina sconti e probabilità di continuazione per gestire contesti.</td>\n<td>Gestione avanzata dei contesti, stato dell&rsquo;arte.</td>\n<td>Complessità implementativa, richiede calcolo di $P_{\\text{cont}}$.</td>\n<td>Modelli linguistici avanzati (es. NLP moderno).</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"conclusioni_1\">Conclusioni</h2>\n<p>I metodi di smoothing risolvono il problema degli n-grammi non osservati o rari, ma con compromessi tra semplicità e accuratezza:  </p>\n<ol>\n<li><strong>Laplace e Add-$k$</strong> sono adatti per <strong>scenari semplici</strong> (corpus piccoli o prototipi), ma diventano rapidamente inefficaci con vocabolari ampi.  </li>\n<li><strong>Good-Turing</strong> offre una <strong>base teorica rigorosa</strong> per la ridistribuzione della massa probabilistica, ma la sua complessità e instabilità lo rendono poco pratico per corpus molto grandi.  </li>\n<li><strong>Kneser-Ney</strong> è lo <strong>stato dell&rsquo;arte</strong> per la modellazione linguistica, grazie alla combinazione di sconti dinamici e probabilità di continuazione, che penalizzano parole comuni in contesti specifici (es. &ldquo;Francisco&rdquo; dopo &ldquo;San&rdquo;).  </li>\n</ol>\n<p><strong>Raccomandazioni</strong>:<br />\n- Usare <strong>Kneser-Ney</strong> per task avanzati (es. riconoscimento vocale, traduzione automatica).<br />\n- Optare per <strong>Good-Turing</strong> se è necessaria una ridistribuzione teorica senza troppa complessità.<br />\n- <strong>Laplace/Add-$k$</strong> sono utili solo in fase esplorativa o con dati limitati.  </p>\n<p>In sintesi, la scelta dipende dal trade-off tra risorse computazionali, dimensione del corpus e necessità di precisione. Per applicazioni reali, Kneser-Ney rimane il gold standard nonostante la sua complessità.  </p>"
}