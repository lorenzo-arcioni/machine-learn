<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Spelling Correction & Minimum Edit Distance (MED) | Natural Language Processing | ML Theory</title>
    <meta name="description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta name="keywords" content="NLP, natural language processing, text analysis, language models, model, data, neural">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Spelling Correction & Minimum Edit Distance (MED)">
    <meta property="og:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta property="og:url" content="http://localhost:3000/theory/nlp/Spelling Correction and Minimum Edit Distance">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Machine Learning Theory">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Spelling Correction & Minimum Edit Distance (MED)">
    <meta name="twitter:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:3000/theory/nlp/Spelling Correction and Minimum Edit Distance">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Spelling Correction & Minimum Edit Distance (MED)",
      "description": "pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...",
      "url": "http://localhost:3000/theory/nlp/Spelling Correction and Minimum Edit Distance",
      "datePublished": "2025-08-30T19:21:57.336Z",
      "author": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      },
      "publisher": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      }
    }
    </script>
    
    <!-- Critical CSS -->
    <style>
      body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        line-height: 1.6; 
        margin: 0; 
        padding: 20px;
        background: #fafafa;
      }
      .container { 
        max-width: 800px; 
        margin: 0 auto; 
        background: white;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      h1 { 
        color: #1a1a1a; 
        margin-bottom: 20px; 
        font-size: 2.5rem;
        line-height: 1.2;
      }
      .meta { 
        color: #666; 
        margin-bottom: 30px; 
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .content h2, .content h3 { 
        color: #2c3e50; 
        margin-top: 40px; 
        margin-bottom: 16px;
      }
      .content p { 
        margin-bottom: 16px; 
        color: #333;
      }
      .content code { 
        background: #f8f9fa; 
        padding: 2px 6px; 
        border-radius: 4px; 
        font-size: 0.9em;
        color: #e83e8c;
      }
      .content pre { 
        background: #f8f9fa; 
        padding: 20px; 
        border-radius: 8px; 
        overflow-x: auto;
        border: 1px solid #e9ecef;
      }
      .react-redirect {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #007acc;
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(0,122,204,0.3);
        transition: transform 0.2s;
      }
      .react-redirect:hover {
        transform: translateY(-1px);
      }
      @media (max-width: 768px) { 
        body { padding: 10px; }
        .container { padding: 20px; }
        h1 { font-size: 2rem; }
        .react-redirect { position: static; display: block; text-align: center; margin-bottom: 20px; }
      }
    </style>
</head>
<body>
    <!-- Link per versione interattiva -->
    <a href="http://localhost:3000/theory/nlp/Spelling Correction and Minimum Edit Distance" class="react-redirect">ðŸš€ View Interactive Version</a>
    
    <div class="container">
        <article>
            <header>
                <h1>Spelling Correction & Minimum Edit Distance (MED)</h1>
                <div class="meta">
                    <strong>Topic:</strong> Natural Language Processing | 
                    <strong>Updated:</strong> 30/08/2025
                </div>
            </header>
            
            <div class="content">
                <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

/* Styling per blocchi di codice */
.codehilite {
    background: transparent !important;
    border-radius: 8px;
    overflow: hidden;
}
.codehilite pre {
    background: transparent !important;
    margin: 0 !important;
    padding: 20px !important;
    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;
    font-size: 14px !important;
    line-height: 1.5 !important;
    white-space: pre !important;
    overflow-x: auto !important;
    color: inherit !important;
}
.codehilite code {
    background: transparent !important;
    padding: 0 !important;
    font-family: inherit !important;
}


.code-wrapper { 
    position: relative; 
}
.copy-button {
    position: absolute; 
    top: 12px; 
    right: 12px; 
    padding: 6px 12px; 
    font-size: 12px;
    cursor: pointer; 
    border: none; 
    border-radius: 4px; 
    background: rgba(255,255,255,0.9);
    color: #374151; 
    transition: all 0.2s ease;
    font-weight: 500;
}
.copy-button:hover { 
    background: rgba(255,255,255,1);
    transform: translateY(-1px);
}


details.code-container {
    border: 1px solid #e5e7eb; 
    border-radius: 12px; 
    background: #f9fafb;
    margin: 16px 0;
    transition: all 0.3s ease;
}
details.code-container summary {
    padding: 12px 16px;
    font-size: 14px; 
    color: #6b7280; 
    cursor: pointer; 
    outline: none; 
    user-select: none;
    font-weight: 500;
}
details.code-container[open] summary::after { 
    content: " (Hide Code)"; 
    color: #9ca3af; 
}
details.code-container:not([open]) summary::after { 
    content: " (Show Code)"; 
    color: #d1d5db; 
}
details.code-container .code-wrapper {
    padding: 0;
    margin: 0;
}
/* Blocchi di codice sempre visibili */
.code-visible {
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    margin: 16px 0;
}
.code-visible .code-wrapper {
    padding: 0;
    margin: 0;
}
</style>
<h2 id="rilevazione-e-correzione-di-errori-ortografici">Rilevazione e Correzione di Errori Ortografici</h2>
<p>Un tipico problema di Natural Language Processing (NLP) consiste nel rilevare e correggere errori ortografici in testi in linguaggio naturale.</p>
<h3 id="classificazione-degli-errori-kukich-1992">Classificazione degli Errori ([Kukich, 1992])</h3>
<h4 id="rilevazione-di-non-parole">Rilevazione di non-parole</h4>
<p>Identificare parole che non esistono nel dizionario di riferimento.</p>
<p><strong>Esempio:</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Input: &quot;graxfe&quot; â†’ Non presente nel dizionario italiano/inglese.
Azione: Segnalazione automatica o suggerimento di correzione.
</code></pre></div>
</div>
</details>

<p><strong>Metodi:</strong></p>
<ul>
<li>Lookup in dizionari predefiniti (es. dizionari open-source come Hunspell).</li>
<li>Modelli statistici per identificare sequenze di caratteri anomale.</li>
</ul>
<h4 id="correzione-isolata-di-parole">Correzione isolata di parole</h4>
<p>Correggere errori in parole singole senza considerare il contesto circostante.</p>
<p><strong>Esempio:</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Input: &quot;acomodation&quot; â†’ Correzione: &quot;accommodation&quot;.
</code></pre></div>
</div>
</details>

<p><strong>Algoritmi:</strong></p>
<ul>
<li>Generazione di candidati tramite MED (es. parole con edit distance â‰¤ 2).</li>
<li>Ranking basato sulla frequenza lessicale (es. &ldquo;accommodation&rdquo; Ã¨ piÃ¹ comune di &ldquo;accomodation&rdquo;).</li>
</ul>
<h4 id="correzione-dipendente-dal-contesto">Correzione dipendente dal contesto</h4>
<p>Correggere errori che producono parole valide ma semanticamente errate.</p>
<p><strong>Esempio:</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Frase: &quot;I have there apples.&quot; â†’ Correzione: &quot;three&quot;.
</code></pre></div>
</div>
</details>

<p><strong>Tecniche avanzate:</strong></p>
<ul>
<li>Modelli linguistici n-gram (es. trigrammi per valutare la probabilitÃ  della sequenza &ldquo;have three apples&rdquo;).</li>
<li>Reti neurali (es. Transformer) per catturare dipendenze a lungo raggio.</li>
</ul>
<h2 id="statistiche-sugli-errori-damerau-1964">Statistiche sugli Errori ([Damerau, 1964])</h2>
<p>L&lsquo;80% degli errori deriva da un singolo errore per parola:</p>
<table>
<thead>
<tr>
<th>Tipo</th>
<th>Esempio</th>
<th>Correzione</th>
<th>Operazione Richiesta</th>
</tr>
</thead>
<tbody>
<tr>
<td>Inserimento</td>
<td>&ldquo;the&rdquo;</td>
<td>&ldquo;ther&rdquo;</td>
<td>Inserimento del carattere &ldquo;r&rdquo; extra.</td>
</tr>
<tr>
<td>Cancellazione</td>
<td>&ldquo;the&rdquo;</td>
<td>&ldquo;th&rdquo;</td>
<td>Rimozione del carattere &ldquo;e&rdquo;.</td>
</tr>
<tr>
<td>Sostituzione</td>
<td>&ldquo;thw&rdquo;</td>
<td>&ldquo;the&rdquo;</td>
<td>Sostituzione di &ldquo;w&rdquo; con &ldquo;e&rdquo;.</td>
</tr>
<tr>
<td>Trasposizione</td>
<td>&ldquo;teh&rdquo;</td>
<td>&ldquo;the&rdquo;</td>
<td>Inversione di &ldquo;h&rdquo; e &ldquo;e&rdquo;.</td>
</tr>
</tbody>
</table>
<p><strong>Eccezioni:</strong></p>
<ul>
<li>Errori multipli (es. &ldquo;becuaesh&rdquo; â†’ &ldquo;because&rdquo;) richiedono algoritmi piÃ¹ complessi (es. MED con k &gt; 2).</li>
<li>Errori fonetici (es. &ldquo;fone&rdquo; â†’ &ldquo;phone&rdquo;) non rilevabili tramite MED standard.</li>
</ul>
<h2 id="lintuizione">L&rsquo;Intuizione</h2>
<p>Per molte applicazioni (es. Correzione Ortografica, Traduzione Automatica, Estrazione di Informazioni, Riconoscimento Vocale, Biologia Computazionale) Ã¨ cruciale valutare la similaritÃ  tra due stringhe.</p>
<h3 id="quanto-sono-simili-due-stringhe">Quanto sono simili due stringhe?</h3>
<h3 id="correzione-ortografica">Correzione Ortografica</h3>
<p>L&rsquo;utente ha digitato <strong>&ldquo;graffe&rdquo;</strong>, quale parola Ã¨ la piÃ¹ simile?</p>
<ul>
<li>graf</li>
<li>graft</li>
<li>grail</li>
<li>giraffe</li>
</ul>
<p>Dato un dizionario di parole corrette, le similaritÃ  vengono utilizzate per trovare l&rsquo;ortografia corretta piÃ¹ simile.</p>
<p><strong>Riferimento:</strong> [Kukich, 1992]<br />
<strong>Argomento:</strong> Elaborazione del Linguaggio Naturale - Correzione Ortografica e Distanza di Modifica Minima<br />
<strong>Riferimento:</strong> [Damerau, 1964]</p>
<h3 id="biologia-computazionale">Biologia Computazionale</h3>
<p>Allineamento di due sequenze di nucleotidi:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>AGGCTATCACCTGACCTCCAGGCCGATGCCC
TAGCTATCACGACCGCGGTCGATTTGCCCGAC
</code></pre></div>
</div>
</details>

<p>Allineamento risultante:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>-AGGCTATCACCTGACCTCCAGGCCGA--TGCCC---
TAG-CTATCAC--GACCGC--GGTCGATTTGCCCGAC
</code></pre></div>
</div>
</details>

<p>Date due sequenze di nucleotidi, le similaritÃ  vengono utilizzate per eseguire l&rsquo;allineamento ottimale.</p>
<h2 id="minimum-edit-distance-med">Minimum Edit Distance (MED)</h2>
<p>La <strong>Minimum Edit Distance (MED)</strong> Ã¨ una misura del costo minimo necessario per applicare operazioni di modifica al fine di allineare una stringa sorgente $X$ a una stringa target $Y$.</p>
<p>Le operazioni di modifica sono:</p>
<ul>
<li><strong>Inserimento (i):</strong></li>
<li><strong>Cancellazione (d):</strong></li>
<li><strong>Sostituzione (s):</strong></li>
</ul>
<p>La funzione <strong>costo(z):</strong>, con $z \in \{i, d, s\}$, definisce il costo associato all&rsquo;applicazione di una determinata operazione di modifica.</p>
<p>Per calcolare la MED di due stringhe si potrebbe pensare di tentare tutte le combinazioni di operazioni di modifica, ma questo richiederebbe esponenziali operazioni di calcolo. Per evitare questo, si utilizza un algoritmo di programmazione dinamica.</p>
<h3 id="algoritmo-di-wagner-fischer">Algoritmo di Wagner-Fischer</h3>
<p>L&rsquo;algoritmo di Wagner-Fischer utilizza un&rsquo;approccio matriciale per calcolare la MED tra due stringhe. In particolare, si utilizza una matrice $D$ di dimensioni $(n+1) Ã— (m+1)$, dove $n$ e $m$ sono le lunghezze delle due stringhe.</p>
<p>Quindi dato:</p>
<ul>
<li>Una stringa $X$ di lunghezza $n$</li>
<li>Una stringa $Y$ di lunghezza $m$</li>
</ul>
<p>Definiamo $D_{X,Y}(i,j)$ come:</p>
<ul>
<li>La distanza di modifica tra i primi $i$ caratteri di $X$ e i primi $j$ caratteri di $Y$.</li>
<li>La distanza di modifica tra $X$ e $Y$ Ã¨ quindi $D_{X,Y}(n,m)$.</li>
</ul>
<p>L&rsquo;approccio consiste nel calcolo tabulare di $D_{X,Y}(n,m)$.</p>
<p>Si risolve il problema combinando soluzioni di sottoproblemi piÃ¹ piccoli.</p>
<h3 id="strategia-bottom-up">Strategia &ldquo;Bottom-up&rdquo;</h3>
<ul>
<li>Si calcola $D_{X,Y}(i,j)$ per valori piccoli di $i$ e $j$.</li>
<li>Si utilizzano i valori precedentemente calcolati per ottenere $D_{X,Y}(i,j)$ per valori piÃ¹ grandi.</li>
<li>Si computa $D_{X,Y}(i,j)$ per tutti $i$ con $0 < i < n$ e $j$ con $0 < j < m$.</li>
</ul>
<h3 id="formalmente">Formalmente</h3>
$$
\begin{aligned}
& \textbf{Algoritmo: Calcolo della Distanza di Modifica Minima} \\
& \textbf{Input:} \\
& \quad - \text{Stringa sorgente } X \text{, di lunghezza } n \\
& \quad - \text{Stringa target } Y \text{, di lunghezza } m \\
& \textbf{Output:} \\
& \quad - \text{Distanza di modifica minima } D_{X,Y}(n,m) \\
& \quad - \text{Allineamento ottimale tramite puntatori di backtracking} \\
& \\
& \text{1: Inizializza la matrice } D_{X,Y} \text{ di dimensioni } (n+1) \times (m+1) \text{ con:} \\
& \quad \text{per } i = 0 \text{ to } n: \quad D_{X,Y}(i,0) \gets i \\
& \quad \text{per } j = 0 \text{ to } m: \quad D_{X,Y}(0,j) \gets j \\
& \quad \text{(Salva i puntatori di backtracking per ciascuna cella)} \\
& \\
& \text{2: Per } i = 1 \text{ a } n \text{ do:} \\
& \quad \quad \text{Per } j = 1 \text{ a } m \text{ do:} \\
& \quad \quad \quad D_{X,Y}(i,j) \gets \min \Big\{ \\
& \quad \quad \quad \quad D_{X,Y}(i-1,j) + \text{costo(d)} \quad \text{(cancellazione)}, \\
& \quad \quad \quad \quad D_{X,Y}(i,j-1) + \text{costo(i)} \quad \text{(inserimento)}, \\
& \quad \quad \quad \quad D_{X,Y}(i-1,j-1) + 
    \begin{cases}
      \text{costo(s)} & \text{se } X[i] \neq Y[j], \\
      0 & \text{se } X[i] = Y[j]
    \end{cases} \quad \text{(sostituzione)} \\
& \quad \quad \quad \Big\} \\
& \quad \quad \quad \text{(Aggiorna i puntatori di backtracking in base alla scelta minima)} \\
& \\
& \text{3: La distanza di modifica minima Ã¨ } D_{X,Y}(n,m). \\
& \\
& \text{4: Per ottenere l'allineamento ottimale, inizia da } D_{X,Y}(n,m) \text{ e segui i puntatori di backtracking.}
\end{aligned}
$$
<h3 id="esecuzione-completa-dellalgoritmo-per-hello-e-hey">Esecuzione Completa dell&rsquo;Algoritmo per &ldquo;hello&rdquo; e &ldquo;hey&rdquo;</h3>
<p>Consideriamo:</p>
<ul>
<li>$X = "hello"$ (lunghezza $n = 5$)</li>
<li>$Y = "hey"$ (lunghezza $m = 3$)</li>
</ul>
<p>Utilizziamo i seguenti costi:</p>
<ul>
<li>Inserimento: 1</li>
<li>Cancellazione: 1</li>
<li>Sostituzione: 1 (0 se i caratteri sono uguali)</li>
</ul>
<h4 id="1-inizializzazione">1. Inizializzazione</h4>
<p>Si crea una matrice $D$ di dimensioni $(n+1) \times (m+1) = 6 \times 4$.</p>
<p>Per ogni $i = 0, \dots, 5$:
$$
D(i,0) = i
$$
Per ogni $j = 0, \dots, 3$:
$$
D(0,j) = j
$$</p>
<p>La matrice iniziale Ã¨:</p>
$$
\begin{array}{c|cccc}
      & j=0 & j=1 & j=2 & j=3 \\ \hline
i=0   & 0   & 1   & 2   & 3   \\
i=1   & 1   &     &     &     \\
i=2   & 2   &     &     &     \\
i=3   & 3   &     &     &     \\
i=4   & 4   &     &     &     \\
i=5   & 5   &     &     &     \\
\end{array}
$$
<h4 id="2-riempimento-della-matrice">2. Riempimento della Matrice</h4>
<p>Si calcola $D(i,j)$ per $i = 1,\dots,5$ e $j = 1,\dots,3$ utilizzando:</p>
$$
D(i,j)= \min \left\{
\begin{array}{l}
D(i-1,j) + \text{costo(d)} \quad \text{(cancellazione)} \\
D(i,j-1) + \text{costo(i)} \quad \text{(inserimento)} \\
D(i-1,j-1) + 
  \begin{cases}
    0 & \text{se } X[i]=Y[j] \\
    1 & \text{se } X[i]\neq Y[j]
  \end{cases}
  \quad \text{(sostituzione)}
\end{array}
\right\}.
$$
<h4 id="dettaglio-dei-calcoli">Dettaglio dei Calcoli</h4>
<p><strong>Riga $i=1$ ($X[1] = "h"$):</strong></p>
<ul>
<li><strong>$j=1$ ($Y[1] = "h"$):</strong><br />
  $X[1] = h, \; Y[1] = h$ â†’ match (costo 0)
  $$
  D(1,1) = \min \{ D(0,1)+1, \; D(1,0)+1, \; D(0,0)+0 \} = \min \{ 2,\, 2,\, 0 \} = 0.
  $$</li>
<li><strong>$j=2$ ($Y[2] = "e"$):</strong><br />
  $h$ vs $e$ â†’ sostituzione (costo 1)
  $$
  D(1,2) = \min \{ D(0,2)+1, \; D(1,1)+1, \; D(0,1)+1 \} = \min \{ 3,\, 1,\, 2 \} = 1.
  $$</li>
<li><strong>$j=3$ ($Y[3] = "y"$):</strong><br />
  $h$ vs $y$ â†’ sostituzione (costo 1)
  $$
  D(1,3) = \min \{ D(0,3)+1, \; D(1,2)+1, \; D(0,2)+1 \} = \min \{ 4,\, 2,\, 3 \} = 2.
  $$</li>
</ul>
<p>La matrice diventa:</p>
$$
\begin{array}{c|cccc}
      & 0 & 1 & 2 & 3 \\ \hline
0     & 0 & 1 & 2 & 3 \\
1     & 1 & 0 & 1 & 2 \\
2     & 2 &   &   &   \\
3     & 3 &   &   &   \\
4     & 4 &   &   &   \\
5     & 5 &   &   &   \\
\end{array}
$$
<h4 id="riga-math_inline_79-math_inline_80"><strong>Riga $i=2$ ($X[2] = "e"$):</strong></h4>
<ul>
<li><strong>$j=1$ ($Y[1] = "h"$):</strong><br />
  $e$ vs $h$ â†’ sostituzione (costo 1)
  $$
  D(2,1) = \min \{ D(1,1)+1, \; D(2,0)+1, \; D(1,0)+1 \} = \min \{ 1,\, 3,\, 2 \} = 1.
  $$</li>
<li><strong>$j=2$ ($Y[2] = "e"$):</strong><br />
  $e$ vs $e$ â†’ match (costo 0)
  $$
  D(2,2) = \min \{ D(1,2)+1, \; D(2,1)+1, \; D(1,1)+0 \} = \min \{ 2,\, 2,\, 0 \} = 0.
  $$</li>
<li><strong>$j=3$ ($Y[3] = "y"$):</strong><br />
  $e$ vs $y$ â†’ sostituzione (costo 1)
  $$
  D(2,3) = \min \{ D(1,3)+1, \; D(2,2)+1, \; D(1,2)+1 \} = \min \{ 3,\, 1,\, 2 \} = 1.
  $$</li>
</ul>
<p>La matrice aggiornata:</p>
$$
\begin{array}{c|cccc}
      & 0 & 1 & 2 & 3 \\ \hline
0     & 0 & 1 & 2 & 3 \\
1     & 1 & 0 & 1 & 2 \\
2     & 2 & 1 & 0 & 1 \\
3     & 3 &   &   &   \\
4     & 4 &   &   &   \\
5     & 5 &   &   &   \\
\end{array}
$$
<h4 id="riga-math_inline_93-math_inline_94"><strong>Riga $i=3$ ($X[3] = "l"$):</strong></h4>
<ul>
<li><strong>$j=1$ ($Y[1] = "h"$):</strong><br />
  $l$ vs $h$ â†’ sostituzione (costo 1)
  $$
  D(3,1) = \min \{ D(2,1)+1, \; D(3,0)+1, \; D(2,0)+1 \} = \min \{ 2,\, 4,\, 3 \} = 2.
  $$</li>
<li><strong>$j=2$ ($Y[2] = "e"$):</strong><br />
  $l$ vs $e$ â†’ sostituzione (costo 1)
  $$
  D(3,2) = \min \{ D(2,2)+1, \; D(3,1)+1, \; D(2,1)+1 \} = \min \{ 1,\, 3,\, 2 \} = 1.
  $$</li>
<li><strong>$j=3$ ($Y[3] = "y"$):</strong><br />
  $l$ vs $y$ â†’ sostituzione (costo 1)
  $$
  D(3,3) = \min \{ D(2,3)+1, \; D(3,2)+1, \; D(2,2)+1 \} = \min \{ 2,\, 2,\, 1 \} = 1.
  $$</li>
</ul>
<p>La matrice diventa:</p>
$$
\begin{array}{c|cccc}
      & 0 & 1 & 2 & 3 \\ \hline
0     & 0 & 1 & 2 & 3 \\
1     & 1 & 0 & 1 & 2 \\
2     & 2 & 1 & 0 & 1 \\
3     & 3 & 2 & 1 & 1 \\
4     & 4 &   &   &   \\
5     & 5 &   &   &   \\
\end{array}
$$
<h4 id="riga-math_inline_107-math_inline_108"><strong>Riga $i=4$ ($X[4] = "l"$):</strong></h4>
<ul>
<li><strong>$j=1$ ($Y[1] = "h"$):</strong><br />
  $l$ vs $h$ â†’ sostituzione (costo 1)
  $$
  D(4,1) = \min \{ D(3,1)+1, \; D(4,0)+1, \; D(3,0)+1 \} = \min \{ 3,\, 5,\, 4 \} = 3.
  $$</li>
<li><strong>$j=2$ ($Y[2] = "e"$):</strong><br />
  $l$ vs $e$ â†’ sostituzione (costo 1)
  $$
  D(4,2) = \min \{ D(3,2)+1, \; D(4,1)+1, \; D(3,1)+1 \} = \min \{ 2,\, 4,\, 3 \} = 2.
  $$</li>
<li><strong>$j=3$ ($Y[3] = "y"$):</strong><br />
  $l$ vs $y$ â†’ sostituzione (costo 1)
  $$
  D(4,3) = \min \{ D(3,3)+1, \; D(4,2)+1, \; D(3,2)+1 \} = \min \{ 2,\, 3,\, 2 \} = 2.
  $$</li>
</ul>
<p>La matrice diventa:</p>
$$
\begin{array}{c|cccc}
      & 0 & 1 & 2 & 3 \\ \hline
0     & 0 & 1 & 2 & 3 \\
1     & 1 & 0 & 1 & 2 \\
2     & 2 & 1 & 0 & 1 \\
3     & 3 & 2 & 1 & 1 \\
4     & 4 & 3 & 2 & 2 \\
5     & 5 &   &   &   \\
\end{array}
$$
<h4 id="riga-math_inline_121-math_inline_122"><strong>Riga $i=5$ ($X[5] = "o"$):</strong></h4>
<ul>
<li><strong>$j=1$ ($Y[1] = "h"$):</strong><br />
  $o$ vs $h$ â†’ sostituzione (costo 1)
  $$
  D(5,1) = \min \{ D(4,1)+1, \; D(5,0)+1, \; D(4,0)+1 \} = \min \{ 4,\, 6,\, 5 \} = 4.
  $$</li>
<li><strong>$j=2$ ($Y[2] = "e"$):</strong><br />
  $o$ vs $e$ â†’ sostituzione (costo 1)
  $$
  D(5,2) = \min \{ D(4,2)+1, \; D(5,1)+1, \; D(4,1)+1 \} = \min \{ 3,\, 5,\, 4 \} = 3.
  $$</li>
<li><strong>$j=3$ ($Y[3] = "y"$):</strong><br />
  $o$ vs $y$ â†’ sostituzione (costo 1)
  $$
  D(5,3) = \min \{ D(4,3)+1, \; D(5,2)+1, \; D(4,2)+1 \} = \min \{ 3,\, 4,\, 3 \} = 3.
  $$</li>
</ul>
<p>La matrice finale Ã¨:</p>
$$
\begin{array}{c|cccc}
      & 0 & 1 & 2 & 3 \\ \hline
0     & 0 & 1 & 2 & 3 \\
1     & 1 & 0 & 1 & 2 \\
2     & 2 & 1 & 0 & 1 \\
3     & 3 & 2 & 1 & 1 \\
4     & 4 & 3 & 2 & 2 \\
5     & 5 & 4 & 3 & 3 \\
\end{array}
$$
<p>La <strong>distanza di modifica minima</strong> tra &ldquo;hello&rdquo; e &ldquo;hey&rdquo; Ã¨ dunque $D(5,3) = 3$.</p>
<h4 id="3-backtracking-per-lallineamento-ottimale">3. Backtracking per l&rsquo;Allineamento Ottimale</h4>
<p>Si parte da $D(5,3)$ e si risale seguendo i puntatori (cioÃ¨, scegliendo la mossa che ha prodotto il valore corrente):</p>
<ol>
<li>
<p><strong>Da $D(5,3) = 3$:</strong><br />
   Possibili mosse:</p>
</li>
<li>
<p>Da $D(4,3)$: $2 + 1 = 3$</p>
</li>
<li>Da $D(5,2)$: $3 + 1 = 4$</li>
<li>
<p>Da $D(4,2)$: $2 + 1 = 3$<br />
<em>Scelta:</em> Movimento diagonale da $D(4,2)$ (operazione di <strong>sostituzione</strong>: $X[5] = \text{"o"}$ sostituito con $Y[3] = \text{"y"}$).</p>
</li>
<li>
<p><strong>Da $D(4,2) = 2$:</strong><br />
   Possibili mosse:</p>
</li>
<li>
<p>Da $D(3,2)$: $1 + 1 = 2$</p>
</li>
<li>Da $D(4,1)$: $3 + 1 = 4$</li>
<li>
<p>Da $D(3,1)$: $2 + 1 = 3$<br />
<em>Scelta:</em> Movimento dall&rsquo;alto da $D(3,2)$ (operazione di <strong>cancellazione</strong>: eliminazione di $X[4] = \text{"l"}$).</p>
</li>
<li>
<p><strong>Da $D(3,2) = 1$:</strong><br />
   Possibili mosse:</p>
</li>
<li>
<p>Da $D(2,2)$: $0 + 1 = 1$</p>
</li>
<li>Da $D(3,1)$: $2 + 1 = 3$</li>
<li>
<p>Da $D(2,1)$: $1 + 1 = 2$<br />
<em>Scelta:</em> Movimento dall&rsquo;alto da $D(2,2)$ (operazione di <strong>cancellazione</strong>: eliminazione di $X[3] = \text{"l"}$).</p>
</li>
<li>
<p><strong>Da $D(2,2) = 0$:</strong><br />
   $X[2] = \text{"e"}$ e $Y[2] = \text{"e"}$ corrispondono â†’ <strong>match</strong>.<br />
<em>Movimento:</em> Diagonale a $D(1,1)$.</p>
</li>
<li>
<p><strong>Da $D(1,1) = 0$:</strong><br />
   $X[1] = \text{"h"}$ e $Y[1] = \text{"h"}$ corrispondono â†’ <strong>match</strong>.<br />
<em>Movimento:</em> Diagonale a $D(0,0)$.</p>
</li>
</ol>
<p><strong>Sintesi delle operazioni (dal fondo verso l&rsquo;inizio):</strong></p>
<ul>
<li>$D(1,1)$: <strong>Match</strong>: &ldquo;h&rdquo; con &ldquo;h&rdquo;.</li>
<li>$D(2,2)$: <strong>Match</strong>: &ldquo;e&rdquo; con &ldquo;e&rdquo;.</li>
<li>$D(3,2)$: <strong>Cancellazione</strong>: eliminazione di $X[3] = \text{"l"}$.</li>
<li>$D(4,2)$: <strong>Cancellazione</strong>: eliminazione di $X[4] = \text{"l"}$.</li>
<li>$D(5,3)$: <strong>Sostituzione</strong>: $X[5] = \text{"o"}$ sostituito da $Y[3] = \text{"y"}$.</li>
</ul>
<h4 id="4-allineamento-finale">4. Allineamento Finale</h4>
<p>Ricostruendo l&rsquo;allineamento in ordine corretto:</p>
$$
\begin{array}{cccccc}
\textbf{X:} & h & e & l & l & o \\
\textbf{Y:} & h & e & - & - & y \\
\end{array}
$$
<p>Dove:</p>
<ul>
<li>Le lettere &ldquo;h&rdquo; ed &ldquo;e&rdquo; corrispondono.</li>
<li>I due &ldquo;l&rdquo; in &ldquo;hello&rdquo; (posizioni 3 e 4) sono state <strong>cancellate</strong> (allineate a gap).</li>
<li>La lettera &ldquo;o&rdquo; Ã¨ stata <strong>sostituita</strong> con &ldquo;y&rdquo;.</li>
</ul>
<p>Il <strong>punteggio finale</strong> (distanza di modifica) Ã¨ <strong>3</strong>.</p>
<p>Questo esempio mostra in dettaglio l&rsquo;esecuzione dell&rsquo;algoritmo per il calcolo della distanza di modifica minima e come, tramite backtracking, si ottiene l&rsquo;allineamento ottimale tra &ldquo;hello&rdquo; e &ldquo;hey&rdquo;.</p>
<h2 id="weighted-minimum-edit-distance">Weighted Minimum Edit Distance</h2>
<p>Nel contesto della correzione ortografica, alcune lettere sono piÃ¹ soggette ad errori di battitura rispetto ad altre. Il Weighted Minimum Edit Distance assegna costi variabili alle operazioni di modifica per riflettere queste differenze, migliorando cosÃ¬ l&rsquo;accuratezza della correzione.</p>
<p><strong>Schemi di Costi:</strong></p>
<table>
<thead>
<tr>
<th>Operazione</th>
<th>Costo Standard</th>
<th>Costo Ponderato</th>
<th>Spiegazione</th>
</tr>
</thead>
<tbody>
<tr>
<td>Inserimento</td>
<td>1</td>
<td>1</td>
<td>Costo base per aggiungere un carattere.</td>
</tr>
<tr>
<td>Cancellazione</td>
<td>1</td>
<td>1</td>
<td>Costo base per rimuovere un carattere.</td>
</tr>
<tr>
<td>Sostituzione</td>
<td>1</td>
<td>2</td>
<td>Maggiore costo per lettere meno frequentemente sbagliate, riflettendo la probabilitÃ  di errore.</td>
</tr>
<tr>
<td>Trasposizione</td>
<td>Non supportata</td>
<td>1</td>
<td>Inversione di caratteri adiacenti.</td>
</tr>
</tbody>
</table>
<p><strong>Esempio con Costi Ponderati:</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Parola errata: &quot;acesp&quot;
Correzione candidata: &quot;access&quot;
  - Inserisci &quot;c&quot;  â†’ Costo: 1
  - Sostituisci &quot;p&quot; con &quot;s&quot;  â†’ Costo: 2
Totale: 1 + 2 = 3
</code></pre></div>
</div>
</details>

<h2 id="applicazioni-pratiche">Applicazioni Pratiche</h2>
<h3 id="1-correzione-ortografica-in-motori-di-ricerca">1. Correzione Ortografica in Motori di Ricerca</h3>
<p><strong>Funzionamento:</strong></p>
<ol>
<li>Genera candidati con MED â‰¤ 2 (es. &ldquo;graffe&rdquo; â†’ &ldquo;giraffe&rdquo;, &ldquo;graft&rdquo;).</li>
<li>Classifica utilizzando la frequenza nel corpus (es. &ldquo;giraffe&rdquo; Ã¨ piÃ¹ comune di &ldquo;graft&rdquo;).</li>
<li>Aggiunge correzioni contestuali (es. &ldquo;there&rdquo; â†’ &ldquo;three&rdquo; se seguito da un numero).</li>
</ol>
<h3 id="2-allineamento-di-sequenze-genomiche">2. Allineamento di Sequenze Genomiche</h3>
<p><strong>Esempio:</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Sequenza 1: AGGCTATCACCTGACCTCCAGGCCGATGCCC
Sequenza 2: TAGCTATCACGACCGCGGTCGATTTGCCCGAC
</code></pre></div>
</div>
</details>

<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>-AGGCTATCACCTGACCTCCAGGCCGA--TGCCC---
TAG-CTATCAC--GACCGC--GGTCGATTTGCCCGAC
</code></pre></div>
</div>
</details>

<h2 id="limitazioni-e-migliorie">Limitazioni e Migliorie</h2>
<h3 id="limitazioni-del-med">Limitazioni del MED</h3>
<ul>
<li>Ignora il contesto semantico (es. &ldquo;their&rdquo; vs &ldquo;there&rdquo; hanno MED = 0 ma significati diversi).</li>
<li>Non gestisce errori fonetici (es. &ldquo;phish&rdquo; vs &ldquo;fish&rdquo;).</li>
</ul>
<h3 id="migliorie-proposte">Migliorie Proposte</h3>
<ul>
<li>Costi basati sulla tastiera (es. sostituzioni tra tasti vicini).</li>
<li>Modelli ibridi (es. combinare MED con modelli neurali come BERT).</li>
<li>Algoritmi fonetici avanzati (es. Metaphone per gestire omofoni).</li>
</ul>
<h2 id="riferimenti-e-letture-consigliate">Riferimenti e Letture Consigliate</h2>
<ul>
<li>Kukich, K. (1992)</li>
<li>Damerau, F. J. (1964)</li>
<li>Wagner, R. A. e Fischer, M. J. (1974)</li>
</ul>
            </div>
            
            <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee;">
                <p><strong>Keywords:</strong> NLP, natural language processing, text analysis, language models, model, data, neural</p>
                <p><small>This is the SEO-optimized version. <a href="http://localhost:3000/theory/nlp/Spelling Correction and Minimum Edit Distance">Click here for the interactive experience</a>.</small></p>
            </footer>
        </article>
    </div>
    
    <!-- Vercel Analytics (opzionale) -->
    <script>
      // Track SEO page views
      if (window.gtag) {
        gtag('config', 'GA_TRACKING_ID', {
          page_title: 'Spelling Correction & Minimum Edit Distance (MED)',
          page_location: 'http://localhost:3000/theory/nlp/Spelling Correction and Minimum Edit Distance'
        });
      }
    </script>
</body>
</html>