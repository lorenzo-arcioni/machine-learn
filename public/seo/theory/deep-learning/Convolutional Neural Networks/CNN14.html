<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CNN14 (PANN): Architettura per Audio Classification | Deep Learning | ML Theory</title>
    <meta name="description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta name="keywords" content="deep learning, neural networks, CNN, RNN, transformers, data, neural, network">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph -->
    <meta property="og:title" content="CNN14 (PANN): Architettura per Audio Classification">
    <meta property="og:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta property="og:url" content="http://localhost:3000/theory/deep-learning/Convolutional Neural Networks/CNN14">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Machine Learning Theory">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="CNN14 (PANN): Architettura per Audio Classification">
    <meta name="twitter:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:3000/theory/deep-learning/Convolutional Neural Networks/CNN14">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "CNN14 (PANN): Architettura per Audio Classification",
      "description": "pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...",
      "url": "http://localhost:3000/theory/deep-learning/Convolutional Neural Networks/CNN14",
      "datePublished": "2026-01-16T01:12:55.263Z",
      "author": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      },
      "publisher": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      }
    }
    </script>
    
    <!-- Critical CSS -->
    <style>
      body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        line-height: 1.6; 
        margin: 0; 
        padding: 20px;
        background: #fafafa;
      }
      .container { 
        max-width: 800px; 
        margin: 0 auto; 
        background: white;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      h1 { 
        color: #1a1a1a; 
        margin-bottom: 20px; 
        font-size: 2.5rem;
        line-height: 1.2;
      }
      .meta { 
        color: #666; 
        margin-bottom: 30px; 
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .content h2, .content h3 { 
        color: #2c3e50; 
        margin-top: 40px; 
        margin-bottom: 16px;
      }
      .content p { 
        margin-bottom: 16px; 
        color: #333;
      }
      .content code { 
        background: #f8f9fa; 
        padding: 2px 6px; 
        border-radius: 4px; 
        font-size: 0.9em;
        color: #e83e8c;
      }
      .content pre { 
        background: #f8f9fa; 
        padding: 20px; 
        border-radius: 8px; 
        overflow-x: auto;
        border: 1px solid #e9ecef;
      }
      .react-redirect {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #007acc;
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(0,122,204,0.3);
        transition: transform 0.2s;
      }
      .react-redirect:hover {
        transform: translateY(-1px);
      }
      @media (max-width: 768px) { 
        body { padding: 10px; }
        .container { padding: 20px; }
        h1 { font-size: 2rem; }
        .react-redirect { position: static; display: block; text-align: center; margin-bottom: 20px; }
      }
    </style>
</head>
<body>
    <!-- Link per versione interattiva -->
    <a href="http://localhost:3000/theory/deep-learning/Convolutional Neural Networks/CNN14" class="react-redirect">üöÄ View Interactive Version</a>
    
    <div class="container">
        <article>
            <header>
                <h1>CNN14 (PANN): Architettura per Audio Classification</h1>
                <div class="meta">
                    <strong>Topic:</strong> Deep Learning | 
                    <strong>Updated:</strong> 16/01/2026
                </div>
            </header>
            
            <div class="content">
                <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

/* Styling per blocchi di codice */
.codehilite {
    background: transparent !important;
    border-radius: 8px;
    overflow: hidden;
}
.codehilite pre {
    background: transparent !important;
    margin: 0 !important;
    padding: 20px !important;
    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;
    font-size: 14px !important;
    line-height: 1.5 !important;
    white-space: pre !important;
    overflow-x: auto !important;
    color: inherit !important;
}
.codehilite code {
    background: transparent !important;
    padding: 0 !important;
    font-family: inherit !important;
}


.code-wrapper { 
    position: relative; 
}
.copy-button {
    position: absolute; 
    top: 12px; 
    right: 12px; 
    padding: 6px 12px; 
    font-size: 12px;
    cursor: pointer; 
    border: none; 
    border-radius: 4px; 
    background: rgba(255,255,255,0.9);
    color: #374151; 
    transition: all 0.2s ease;
    font-weight: 500;
}
.copy-button:hover { 
    background: rgba(255,255,255,1);
    transform: translateY(-1px);
}


details.code-container {
    border: 1px solid #e5e7eb; 
    border-radius: 12px; 
    background: #f9fafb;
    margin: 16px 0;
    transition: all 0.3s ease;
}
details.code-container summary {
    padding: 12px 16px;
    font-size: 14px; 
    color: #6b7280; 
    cursor: pointer; 
    outline: none; 
    user-select: none;
    font-weight: 500;
}
details.code-container[open] summary::after { 
    content: " (Hide Code)"; 
    color: #9ca3af; 
}
details.code-container:not([open]) summary::after { 
    content: " (Show Code)"; 
    color: #d1d5db; 
}
details.code-container .code-wrapper {
    padding: 0;
    margin: 0;
}
/* Blocchi di codice sempre visibili */
.code-visible {
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    margin: 16px 0;
}
.code-visible .code-wrapper {
    padding: 0;
    margin: 0;
}
</style>
<h2 id="introduzione">Introduzione</h2>
<p>La CNN14 √® un&rsquo;architettura di rete neurale convoluzionale facente parte della famiglia PANN (Pretrained Audio Neural Networks), progettata specificamente per l&rsquo;analisi e la classificazione di segnali audio. Il nome &ldquo;CNN14&rdquo; deriva dal fatto che contiene 14 layer pesati (6 ConvBlock √ó 2 conv ciascuno + 2 layer fully connected).</p>
<p>L&rsquo;architettura trasforma un segnale audio grezzo in un embedding denso ad alta dimensionalit√†, catturando caratteristiche acustiche complesse attraverso una gerarchia di rappresentazioni sempre pi√π astratte.</p>
<h2 id="panoramica-del-pipeline">Panoramica del Pipeline</h2>
<p>Il processo di elaborazione si articola in diverse fasi:</p>
<ol>
<li><strong>Estrazione dello Spettrogramma</strong> - conversione da dominio temporale a tempo-frequenza</li>
<li><strong>Estrazione Log-Mel</strong> - rappresentazione percettivamente motivata</li>
<li><strong>Normalizzazione Batch</strong> - standardizzazione delle feature</li>
<li><strong>Data Augmentation</strong> (solo training) - SpecAugmentation e Mixup</li>
<li><strong>Elaborazione Convoluzionale</strong> - 6 blocchi convoluzionali gerarchici</li>
<li><strong>Pooling Globale</strong> - aggregazione temporale</li>
<li><strong>Classificazione</strong> - layer fully connected</li>
</ol>
<h2 id="1-input-forma-donda-audio">1. Input: Forma d&rsquo;Onda Audio</h2>
<p>L&rsquo;input alla rete √® un segnale audio campionato digitalmente:</p>
$$
\mathbf{s} \in \mathbb{R}^{B \times N_{samples}}
$$
<p>dove:
- $B$ = dimensione del batch
- $N_{samples}$ = numero di campioni audio (tipicamente $480000$ per 10 secondi a 48 kHz)</p>
<p><strong>Intuizione</strong>: Il segnale audio √® una sequenza di valori che rappresentano l&rsquo;ampiezza della pressione sonora nel tempo. √à la rappresentazione pi√π grezza del suono.</p>
<h2 id="2-estrazione-dello-spettrogramma">2. Estrazione dello Spettrogramma</h2>
<h3 id="21-short-time-fourier-transform-stft">2.1 Short-Time Fourier Transform (STFT)</h3>
<p>La STFT applica la trasformata di Fourier a finestre temporali sovrapposte del segnale:</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">spectrogram_extractor</span> <span class="o">=</span> <span class="n">Spectrogram</span><span class="p">(</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>      <span class="c1"># dimensione della FFT (es. 2048)</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="n">hop_size</span><span class="p">,</span>    <span class="c1"># spostamento tra finestre (es. 320)</span>
    <span class="n">win_length</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span> <span class="c1"># lunghezza della finestra</span>
    <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>          <span class="c1"># finestra di Hann</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>            <span class="c1"># padding centrato</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>     <span class="c1"># riflessione ai bordi</span>
    <span class="n">freeze_parameters</span><span class="o">=</span><span class="kc">True</span>  <span class="c1"># parametri non addestrabili</span>
<span class="p">)</span>
</code></pre></div>
</div>
</div>

<p><strong>Matematicamente</strong>:</p>
$$
X[k, n] = \sum_{m=0}^{N-1} x[m + nH] \cdot w[m] \cdot e^{-j2\pi km/N}
$$
<p>dove:
- $k$ = bin di frequenza ($0 \leq k < N/2 + 1$)
- $n$ = frame temporale
- $H$ = hop size
- $w[m]$ = finestra di Hann
- $N$ = dimensione della FFT</p>
<p><strong>Output dello spettrogramma di potenza</strong>:</p>
$$
\mathbf{S} = |X|^2 \in \mathbb{R}^{B \times 1 \times T_{frames} \times F_{bins}}
$$
<p>Con $N_{fft} = 2048$ e hop size $= 320$:
- $T_{frames} = \lfloor 480000 / 320 \rfloor + 1 = 1501$
- $F_{bins} = 2048/2 + 1 = 1025$</p>
<p><strong>Intuizione</strong>: Lo spettrogramma decompone il segnale audio nelle sue componenti di frequenza nel tempo. Ogni colonna verticale rappresenta lo &ldquo;spettro di frequenze&rdquo; presente in una piccola finestra temporale. √à come guardare quali note musicali vengono suonate in ogni istante.</p>
<h3 id="22-finestra-di-hann">2.2 Finestra di Hann</h3>
<p>La finestra di Hann riduce le discontinuit√† ai bordi di ogni frame:</p>
$$
w[m] = 0.5 \left(1 - \cos\left(\frac{2\pi m}{N-1}\right)\right)
$$
<p><strong>Intuizione</strong>: Senza finestra, il taglio brusco del segnale crea &ldquo;artefatti spettrali&rdquo; (frequenze spurie). La finestra di Hann &ldquo;sfuma&rdquo; dolcemente il segnale ai bordi, riducendo questi artefatti.</p>
<h2 id="3-log-mel-spectrogram">3. Log-Mel Spectrogram</h2>
<h3 id="31-mel-filter-bank">3.1 Mel Filter Bank</h3>
<p>Il banco di filtri Mel converte le frequenze lineari in scala Mel, che approssima meglio la percezione umana delle frequenze:</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">logmel_extractor</span> <span class="o">=</span> <span class="n">LogmelFilterBank</span><span class="p">(</span>
    <span class="n">sr</span><span class="o">=</span><span class="n">sample_rate</span><span class="p">,</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="n">window_size</span><span class="p">,</span>
    <span class="n">n_mels</span><span class="o">=</span><span class="n">mel_bins</span><span class="p">,</span>     <span class="c1"># numero di bande Mel (es. 64)</span>
    <span class="n">fmin</span><span class="o">=</span><span class="n">fmin</span><span class="p">,</span>           <span class="c1"># frequenza minima (es. 50 Hz)</span>
    <span class="n">fmax</span><span class="o">=</span><span class="n">fmax</span><span class="p">,</span>           <span class="c1"># frequenza massima (es. 14000 Hz)</span>
    <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
    <span class="n">top_db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freeze_parameters</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
</div>
</div>

<p><strong>Scala Mel</strong>: Conversione da Hz a Mel:</p>
$$
\text{Mel}(f) = 2595 \log_{10}\left(1 + \frac{f}{700}\right)
$$
<p><strong>Applicazione dei filtri triangolari</strong>:</p>
$$
\mathbf{M}_{mel}[b, 1, t, m] = \sum_{k=0}^{F_{bins}-1} \mathbf{S}[b, 1, t, k] \cdot H_m[k]
$$
<p>dove $H_m[k]$ sono i filtri triangolari nella scala Mel.</p>
<p><strong>Conversione in log-scale</strong>:</p>
$$
\mathbf{M}_{log}[b, 1, t, m] = 10 \log_{10}(\max(\mathbf{M}_{mel}[b, 1, t, m], \text{amin}))
$$
<p>con $\text{amin} = 10^{-10}$ per evitare $\log(0)$.</p>
<p><strong>Output</strong>:</p>
$$
\mathbf{M}_{log} \in \mathbb{R}^{B \times 1 \times 1501 \times 64}
$$
<p><strong>Intuizione</strong>: 
- L&rsquo;orecchio umano non percepisce le frequenze linearmente: la differenza tra 100 e 200 Hz √® molto pi√π evidente della differenza tra 10100 e 10200 Hz
- La scala Mel riflette questa non-linearit√† percettiva
- I filtri triangolari aggregano bin di frequenza vicini, riducendo la dimensionalit√† e catturando &ldquo;bande di frequenza&rdquo; percettivamente rilevanti
- La scala logaritmica comprime la gamma dinamica, rendendo sia suoni deboli che forti discriminabili dalla rete</p>
<h2 id="4-normalizzazione-batch-bn0">4. Normalizzazione Batch (bn0)</h2>
<h3 id="41-trasposizione-per-batch-norm">4.1 Trasposizione per Batch Norm</h3>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (B, 1, 1501, 64) ‚Üí (B, 64, 1501, 1)</span>
<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn0</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (B, 64, 1501, 1) ‚Üí (B, 1, 1501, 64)</span>
</code></pre></div>
</div>
</div>

<p><strong>Perch√© questa trasposizione?</strong></p>
<p><code>BatchNorm2d(64)</code> normalizza lungo la dimensione dei canali (dim=1) e si aspetta 
<strong>64 canali in input</strong>. Il log-Mel spectrogram ha forma (B, 1, 1501, 64), con 
1 canale e 64 bande Mel sull&rsquo;ultima dimensione.</p>
<p>La trasposizione <strong>temporanea</strong> sposta le 64 bande Mel nella posizione dei canali, 
permettendo a BatchNorm2d di normalizzare ogni banda Mel indipendentemente. 
Dopo la normalizzazione, si ritrasporta alla forma originale.</p>
<p><strong>Nota tecnica</strong>: <code>bn0</code> √® definito come <code>BatchNorm2d(64)</code>, quindi normalizza 
esattamente 64 &ldquo;canali&rdquo;, che corrispondono alle nostre 64 bande Mel dopo la 
trasposizione.</p>
<h3 id="42-operazione-di-batch-normalization">4.2 Operazione di Batch Normalization</h3>
<p>Per ogni banda Mel $m$ (ora un &ldquo;canale&rdquo;):</p>
$$
\hat{x}[b, m, t, f] = \gamma_m \frac{x[b, m, t, f] - \mu_m}{\sqrt{\sigma_m^2 + \epsilon}} + \beta_m
$$
<p>dove:
- $\mu_m$ = media su tutto il batch e posizioni spazio-temporali per la banda $m$
- $\sigma_m^2$ = varianza corrispondente
- $\gamma_m, \beta_m$ = parametri apprendibili (scaling e shift)
- $\epsilon = 10^{-5}$ = costante per stabilit√† numerica</p>
<p><strong>Calcolo della media</strong>:</p>
$$
\mu_m = \frac{1}{B \cdot T_{frames} \cdot 1} \sum_{b=1}^{B} \sum_{t=1}^{T_{frames}} x[b, m, t, 0]
$$
<p><strong>Intuizione</strong>: 
- Diverse bande di frequenza possono avere energie molto diverse (es. i bassi sono tipicamente pi√π forti degli alti)
- La batch normalization standardizza ogni banda indipendentemente, con media 0 e varianza 1
- Questo aiuta il training permettendo a tutte le bande di contribuire equamente al gradiente
- I parametri $\gamma$ e $\beta$ permettono alla rete di &ldquo;reimparare&rdquo; la scala ottimale per ogni banda</p>
<h2 id="5-data-augmentation-solo-training">5. Data Augmentation (Solo Training)</h2>
<h3 id="51-specaugmentation">5.1 SpecAugmentation</h3>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">spec_augmenter</span> <span class="o">=</span> <span class="n">SpecAugmentation</span><span class="p">(</span>
    <span class="n">time_drop_width</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>    <span class="c1"># larghezza maschere temporali</span>
    <span class="n">time_stripes_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>    <span class="c1"># numero maschere temporali</span>
    <span class="n">freq_drop_width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>     <span class="c1"># larghezza maschere frequenziali</span>
    <span class="n">freq_stripes_num</span><span class="o">=</span><span class="mi">2</span>     <span class="c1"># numero maschere frequenziali</span>
<span class="p">)</span>
</code></pre></div>
</div>
</div>

<p><strong>Time masking</strong>: Azzera 2 strisce verticali casuali di larghezza massima 64 frame</p>
$$
\mathbf{M}[b, 1, t, m] = 0 \quad \text{per } t \in [t_0, t_0 + w_t]
$$
<p>dove $t_0$ √® casuale e $w_t \leq 64$.</p>
<p><strong>Frequency masking</strong>: Azzera 2 strisce orizzontali casuali di larghezza massima 8 bande</p>
$$
\mathbf{M}[b, 1, t, m] = 0 \quad \text{per } m \in [m_0, m_0 + w_m]
$$
<p><strong>Intuizione</strong>: 
- Simula occlusioni e distorsioni reali (es. rumori transienti, perdita di banda)
- Forza la rete a non dipendere da specifiche regioni tempo-frequenza
- Migliora la robustezza e generalizzazione
- √à come &ldquo;nascondere&rdquo; parti dello spettrogramma per insegnare alla rete a riconoscere i suoni anche con informazioni incomplete</p>
<h3 id="52-mixup">5.2 Mixup</h3>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">and</span> <span class="n">mixup_lambda</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">do_mixup</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mixup_lambda</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

<p><strong>Operazione</strong>:</p>
$$
\tilde{x} = \lambda x_i + (1-\lambda) x_j
$$
$$
\tilde{y} = \lambda y_i + (1-\lambda) y_j
$$
<p>dove $\lambda \sim \text{Beta}(\alpha, \alpha)$ (tipicamente $\alpha = 1$, distribuzione uniforme).</p>
<p><strong>Intuizione</strong>:
- Mixa linearmente due esempi e le loro etichette
- Crea esempi &ldquo;ibridi&rdquo; che forzano la rete a imparare interpolazioni smooth tra classi
- Riduce overfitting e migliora calibrazione delle probabilit√†
- √à come sovrapporre due suoni e chiedere alla rete di riconoscere entrambi proporzionalmente</p>
<h2 id="6-blocchi-convoluzionali-gerarchici">6. Blocchi Convoluzionali Gerarchici</h2>
<p>Prima di procedere con i singoli blocchi, √® importante comprendere la struttura del <code>ConvBlock</code>, che √® l&rsquo;unit√† fondamentale ripetuta nell&rsquo;architettura CNN14. Ogni <code>ConvBlock</code> √® composto da:</p>
<ol>
<li><strong>Prima convoluzione 2D</strong> con kernel $3 \times 3$, stride $(1,1)$, padding $(1,1)$</li>
<li><strong>Batch Normalization</strong> sulla prima convoluzione</li>
<li><strong>Attivazione ReLU in-place</strong> ($\text{ReLU}$)</li>
<li><strong>Seconda convoluzione 2D</strong> con kernel $3 \times 3$, stride $(1,1)$, padding $(1,1)$</li>
<li><strong>Batch Normalization</strong> sulla seconda convoluzione</li>
<li><strong>Attivazione ReLU in-place</strong></li>
<li><strong>Pooling operation</strong> (average, max, o avg+max)</li>
</ol>
<h3 id="61-struttura-del-convblock">6.1 Struttura del ConvBlock</h3>
<p>Ogni <code>ConvBlock</code> implementa il pattern:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Input ‚Üí Conv2d ‚Üí BatchNorm ‚Üí ReLU ‚Üí Conv2d ‚Üí BatchNorm ‚Üí ReLU ‚Üí Pooling ‚Üí Output
</code></pre></div>
</div>
</details>

<p><strong>Implementazione matematica</strong>:</p>
<p>Matematicamente, per un <code>ConvBlock</code> che trasforma $C_{in}$ canali in $C_{out}$ canali:</p>
$$
\begin{aligned}
\mathbf{h}_1 &= \text{Conv2d}_{C_{in} \rightarrow C_{out}}(\mathbf{x}, \text{kernel}=3, \text{padding}=1, \text{stride}=1) \\
\mathbf{h}_1 &= \text{ReLU}(\text{BN}(\mathbf{h}_1)) \\
\mathbf{h}_2 &= \text{Conv2d}_{C_{out} \rightarrow C_{out}}(\mathbf{h}_1, \text{kernel}=3, \text{padding}=1, \text{stride}=1) \\
\mathbf{h}_2 &= \text{ReLU}(\text{BN}(\mathbf{h}_2)) \\
\mathbf{x}_{out} &= \text{Pool}(\mathbf{h}_2, \text{pool_size})
\end{aligned}
$$
<p>dove i parametri sono: </p>
<ul>
<li>$\mathbf{x}$: input di dimensione $(C_{in}, H_{in}, W_{in})$</li>
<li>$C_{in}$: numero di canali dell&rsquo;input</li>
<li>$C_{out}$: numero di canali dell&rsquo;output</li>
<li>pool_size: dimensione del pooling</li>
<li>pool_type: tipo di pooling (&lsquo;avg&rsquo;, &lsquo;max&rsquo;, &lsquo;avg+max&rsquo;)</li>
</ul>
<p><strong>Convoluzione 2D con padding=1</strong>:</p>
<p>Per un kernel $3 \times 3$, il padding di 1 pixel preserva le dimensioni spaziali:</p>
$$
H_{out} = H_{in}, \quad W_{out} = W_{in}
$$
<p>La convoluzione calcola:</p>
$$
y[c_{out}, h, w] = \sum_{c_{in}} \sum_{i=-1}^{1} \sum_{j=-1}^{1} x[c_{in}, h+i, w+j] \cdot K[c_{out}, c_{in}, i+1, j+1]
$$
<p><strong>Nota</strong>: il bias $+ b[c_{out}]$ √® omesso nelle convoluzioni perch√© la BatchNorm successiva include gi√† un parametro di shift (Œ≤), rendendo il bias della conv ridondante. Questo √® uno standard nelle architetture moderne.</p>
<p><strong>Batch Normalization dopo Conv</strong>:</p>
$$
\hat{h}[b, c, h, w] = \gamma_c \frac{h[b, c, h, w] - \mu_c}{\sqrt{\sigma_c^2 + \epsilon}} + \beta_c
$$
<p>Normalizza le attivazioni per canale, stabilizzando il training.</p>
<p><strong><span class="text-gray-600">ReLU (Rectified Linear Unit)</span></strong>:</p>
$$
\text{ReLU}(x) = \max(0, x)
$$
<p><strong>Intuizione di ReLU</strong>:
- Introduce non-linearit√†: senza ReLU, stacking di conv sarebbe equivalente a una singola conv
- &ldquo;Accende&rdquo; i neuroni solo per attivazioni positive
- Crea rappresentazioni sparse (molti zeri)
- Permette alla rete di imparare funzioni complesse e gerarchiche</p>
<p><strong>Average Pooling 2D</strong>:</p>
$$
y[c, h', w'] = \frac{1}{k_h \cdot k_w} \sum_{i=0}^{k_h-1} \sum_{j=0}^{k_w-1} x[c, h' \cdot s_h + i, w' \cdot s_w + j]
$$
<p>Con pool_size $(2,2)$ e stride $(2,2)$ (default):</p>
$$
H_{out} = \lfloor H_{in} / 2 \rfloor, \quad W_{out} = \lfloor W_{in} / 2 \rfloor
$$
<p>dove:</p>
<ul>
<li>$k_h$ e $k_w$ sono le dimensioni del kernel</li>
<li>$s_h$ e $s_w$ sono le dimensioni dello stride</li>
<li>$y$ ha dimensioni $(C_{out}, H_{out}, W_{out})$</li>
</ul>
<p><strong>Max Pooling 2D</strong>:</p>
$$
y[c, h', w'] = \max_{i=0}^{k_h-1} \max_{j=0}^{k_w-1} x[c, h' \cdot s_h + i, w' \cdot s_w + j]
$$
<p>Con pool_size $(2,2)$ e stride $(2,2)$ (default):</p>
$$
H_{out} = \lfloor H_{in} / 2 \rfloor, \quad W_{out} = \lfloor W_{in} / 2 \rfloor
$$
<p>dove:</p>
<ul>
<li>$k_h$ e $k_w$ sono le dimensioni del kernel</li>
<li>$s_h$ e $s_w$ sono le dimensioni dello stride</li>
<li>$y$ ha dimensioni $(C_{out}, H_{out}, W_{out})$</li>
</ul>
<p><strong>Avg Pooling 2D + Max Pooling 2D</strong></p>
<p>Combinazione di Average Pooling 2D e Max Pooling 2D. Da notare che entrambi devono avere lo stesso pool_size e stride.</p>
$$
y[c, h', w'] = \text{AvgPooling_2D}(x, pool_size, stride) + \text{MaxPooling_2D}(x, pool_size, stride)
$$
<p><strong>Intuizione del pooling</strong>:
- Riduce le dimensioni spaziali, creando rappresentazioni pi√π compatte
- Introduce invarianza locale: piccoli spostamenti nell&rsquo;input non cambiano drasticamente l&rsquo;output
- Aumenta il &ldquo;campo recettivo&rdquo;: neuroni nei layer successivi &ldquo;vedono&rdquo; porzioni sempre pi√π grandi dell&rsquo;input originale
- Average pooling preserva informazione globale sulla presenza di feature (vs max pooling che preserva solo la pi√π forte)</p>
<p><strong>Riassumendo:</strong>
La convoluzione 2D con padding $(1,1)$ preserva le dimensioni spaziali:</p>
$$
\text{Se } \mathbf{x}_{in} \in \mathbb{R}^{B \times C_{in} \times H \times W} \text{, dopo Conv2D+BatchNorm+ReLU: } \mathbf{h} \in \mathbb{R}^{B \times C_{out} \times H \times W}
$$
<p>Il pooling con pool_size $(2,2)$ dimezza le dimensioni spaziali:</p>
$$
\text{Se } \mathbf{h} \in \mathbb{R}^{B \times C \times H \times W} \text{, dopo pool: } \mathbf{x}_{out} \in \mathbb{R}^{B \times C \times \lfloor H/2 \rfloor \times \lfloor W/2 \rfloor}.
$$
<h3 id="62-progressione-dei-convblock">6.2 Progressione dei ConvBlock</h3>
<p><strong>ConvBlock 1</strong>: $1 \rightarrow 64$ canali</p>
<p>Il primo blocco convoluzionale espande il canale singolo del Mel spectrogram a 64 feature maps:</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_block1</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_1 \in \mathbb{R}^{B \times 1 \times 1501 \times 64} \rightarrow \boxed{\text{ConvBlock1}} \rightarrow \mathbf{x}_2 \in \mathbb{R}^{B \times 64 \times 750 \times 32}
$$
<ul>
<li>Input: log-Mel spectrogram (1 canale)</li>
<li>Output: 64 feature maps</li>
<li>Riduzione: $1501 \rightarrow 750$ frame, $64 \rightarrow 32$ bande Mel</li>
</ul>
<p><strong>Dropout con p=0.2:</strong></p>
$$
\mathbf{x}_2 = \text{Dropout}_{0.2}(\mathbf{x}_2)
$$
<p>Durante il training, ogni elemento ha probabilit√† 0.2 di essere azzerato e i valori rimanenti vengono scalati di $1/0.8 = 1.25$ per mantenere l&rsquo;aspettativa.</p>
<p><strong>Intuizione</strong>: Il primo layer impara feature di basso livello come edge detector, rivelatori di energia locale, pattern di texture semplici.</p>
<p><strong>ConvBlock 2</strong>: $64 \rightarrow 128$ canali</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_block2</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_2 \in \mathbb{R}^{B \times 64 \times 750 \times 32} \rightarrow \boxed{\text{ConvBlock2}} \rightarrow \mathbf{x}_3 \in \mathbb{R}^{B \times 128 \times 375 \times 16}
$$
$$
\mathbf{x}_3 = \text{Dropout}_{0.2}(\mathbf{x}_3)
$$
<p><strong>Intuizione</strong>: Combina feature di basso livello in pattern pi√π complessi (es. sequenze di armoniche, transizioni temporali specifiche).</p>
<p><strong>ConvBlock 3</strong>: $128 \rightarrow 256$ canali</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_block3</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_3 \in \mathbb{R}^{B \times 128 \times 375 \times 16} \rightarrow \boxed{\text{ConvBlock3}} \rightarrow \mathbf{x}_4 \in \mathbb{R}^{B \times 256 \times 187 \times 8}
$$
$$
\mathbf{x}_4 = \text{Dropout}_{0.2}(\mathbf{x}_4)
$$
<p><strong>Intuizione</strong>: Inizia a riconoscere &ldquo;parti di suoni&rdquo; (es. inizio di una nota, parte di una parola, pattern ritmici).</p>
<p><strong>ConvBlock 4</strong>: $256 \rightarrow 512$ canali</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_block4</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_4 \in \mathbb{R}^{B \times 256 \times 187 \times 8} \rightarrow \boxed{\text{ConvBlock4}} \rightarrow \mathbf{x}_5 \in \mathbb{R}^{B \times 512 \times 93 \times 4}
$$
$$
\mathbf{x}_5 = \text{Dropout}_{0.2}(\mathbf{x}_5)
$$
<p><strong>Intuizione</strong>: Riconosce strutture acustiche di medio livello (es. frasi musicali brevi, fonemi, eventi sonori specifici).</p>
<p><strong>ConvBlock 5</strong>: $512 \rightarrow 1024$ canali</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_block5</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">),</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_5 \in \mathbb{R}^{B \times 512 \times 93 \times 4} \rightarrow \boxed{\text{ConvBlock5}} \rightarrow \mathbf{x}_6 \in \mathbb{R}^{B \times 1024 \times 46 \times 2}
$$
$$
\mathbf{x}_6 = \text{Dropout}_{0.2}(\mathbf{x}_6)
$$
<p><strong>Intuizione</strong>: Cattura pattern di alto livello e context (es. stile musicale, tipo di speaker, ambiente acustico).</p>
<p><strong>ConvBlock 6</strong>: $1024 \rightarrow 2048$ canali (pooling 1√ó1)</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">conv_block6</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">pool_size</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">pool_type</span><span class="o">=</span><span class="s1">&#39;avg&#39;</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.2</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_6 \in \mathbb{R}^{B \times 1024 \times 46 \times 2} \rightarrow \boxed{\text{ConvBlock6}} \rightarrow \mathbf{x}_7 \in \mathbb{R}^{B \times 2048 \times 46 \times 2}
$$
$$
\mathbf{x}_7 = \text{Dropout}_{0.2}(\mathbf{x}_7)
$$
<p><strong>Nota cruciale</strong>: Il pooling $(1,1)$ <strong>non riduce</strong> le dimensioni spaziali. Serve solo per:
- Aumentare la capacit√† di rappresentazione (2048 canali)
- Applicare dropout per regolarizzazione
- Mantenere coerenza architetturale</p>
<p><strong>Intuizione</strong>: Questo layer finale di feature extraction crea una rappresentazione molto ricca e astratta, con 2048 dimensioni che codificano caratteristiche semantiche di alto livello del contenuto audio.</p>
<h2 id="7-pooling-temporale-e-globale">7. Pooling Temporale e Globale</h2>
<h3 id="71-frequency-pooling">7.1 Frequency Pooling</h3>
<p>Dopo ConvBlock6, abbiamo $\mathbf{x}_7 \in \mathbb{R}^{B \times 2048 \times 46 \times 2}$.</p>
<p><strong>Operazione</strong>:</p>
$$
\mathbf{x}_{freq}[b, c, t] = \frac{1}{2}\sum_{f=0}^{1} \mathbf{x}_7[b, c, t, f] = \frac{\mathbf{x}_7[b, c, t, 0] + \mathbf{x}_7[b, c, t, 1]}{2}
$$
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

<p><strong>Output</strong>:</p>
$$
\mathbf{x}_{freq} \in \mathbb{R}^{B \times 2048 \times 46}
$$
<p><strong>Intuizione</strong>:
- A questo punto, le 2 &ldquo;bande di frequenza&rdquo; rimaste sono altamente astratte (non pi√π frequenze fisiche)
- Fare la media collassa completamente l&rsquo;informazione frequenziale
- Otteniamo una sequenza temporale pura: 46 frame, ciascuno con 2048 feature
- √à come avere una &ldquo;storia&rdquo; del suono in 46 &ldquo;capitoli&rdquo;, dove ogni capitolo ha 2048 caratteristiche</p>
<h3 id="72-global-temporal-pooling-max-average">7.2 Global Temporal Pooling (Max + Average)</h3>
<p><strong>Max Pooling temporale</strong>:</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="p">(</span><span class="n">x1</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">max</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_{max}[b, c] = \max_{t=1}^{46} \mathbf{x}_{freq}[b, c, t]
$$
<p><strong>Output</strong>: $\mathbf{x}_{max} \in \mathbb{R}^{B \times 2048}$</p>
<p><strong>Intuizione di Max Pooling</strong>:
- Seleziona l&rsquo;attivazione <strong>massima</strong> di ogni feature attraverso tutto il clip audio
- Cattura le caratteristiche <strong>pi√π prominenti</strong> o <strong>eventi pi√π forti</strong>
- √à invariante alla posizione temporale: non importa <em>quando</em> compare un evento, conta solo che ci sia
- Ottimo per rilevare presenza/assenza di pattern specifici (es. &ldquo;c&rsquo;√® un clacson da qualche parte?&rdquo;)</p>
<p><strong>Average Pooling temporale</strong>:</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x2</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_{avg}[b, c] = \frac{1}{46}\sum_{t=1}^{46} \mathbf{x}_{freq}[b, c, t]
$$
<p><strong>Output</strong>: $\mathbf{x}_{avg} \in \mathbb{R}^{B \times 2048}$</p>
<p><strong>Intuizione di Average Pooling</strong>:
- Calcola l&rsquo;attivazione <strong>media</strong> di ogni feature attraverso tutto il clip
- Cattura la <strong>distribuzione globale</strong> e le caratteristiche <strong>persistenti</strong>
- Sensibile alla durata e frequenza di occorrenza di pattern
- Ottimo per texture e caratteristiche diffuse (es. &ldquo;questa musica √® prevalentemente ritmica?&rdquo;)</p>
<p><strong>Combinazione (somma element-wise)</strong>:</p>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span>
</code></pre></div>
</div>
</div>

$$
\mathbf{x}_{global}[b, c] = \mathbf{x}_{max}[b, c] + \mathbf{x}_{avg}[b, c]
$$
<p><strong>Output</strong>: $\mathbf{x}_{global} \in \mathbb{R}^{B \times 2048}$</p>
<p><strong>Intuizione della combinazione</strong>:
- Unisce due &ldquo;punti di vista&rdquo; complementari sullo stesso audio
- Max cattura eventi salienti e picchi
- Average cattura statistiche globali e background
- La somma permette alla rete di pesare entrambi gli aspetti
- √à come avere sia il &ldquo;momento clou&rdquo; che il &ldquo;riassunto generale&rdquo; di ogni caratteristica</p>
<p>Questo √® l&rsquo;<strong>embedding audio finale</strong>: un vettore di 2048 dimensioni che riassume tutto il contenuto acustico del clip.</p>
<h2 id="8-layer-fully-connected-e-classificazione">8. Layer Fully Connected e Classificazione</h2>
<h3 id="81-dropout-pre-fc">8.1 Dropout Pre-FC</h3>
$$
\mathbf{x}_{global} = \text{Dropout}_{0.5}(\mathbf{x}_{global})
$$
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span>
</code></pre></div>
</div>
</div>

<p><strong>Dropout aggressivo al 50%</strong>: spegne casualmente met√† dei neuroni dell&rsquo;embedding.</p>
<p><strong>Intuizione</strong>: 
- Prima dei layer densi, il dropout deve essere pi√π forte (50% vs 20% nei conv)
- I fully connected layer hanno molti pi√π parametri e sono pi√π soggetti a overfitting
- Questo √® il dropout pi√π importante per la regolarizzazione</p>
<h3 id="82-primo-layer-fully-connected-fc1">8.2 Primo Layer Fully Connected (fc1)</h3>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="mi">2048</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">relu_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># (B, 2048)</span>
</code></pre></div>
</div>
</div>

<p><strong>Operazione</strong>:</p>
<p><strong>Operazione</strong>:</p>
$$
\mathbf{h}_{fc1} = \text{ReLU}(\mathbf{x}_{global} \mathbf{W}_1^\top + \mathbf{b}_1)
$$
<p>dove $\mathbf{W}_1 \in \mathbb{R}^{2048 \times 2048}$, $\mathbf{b}_1 \in \mathbb{R}^{2048}$.</p>
<p><strong>Dettaglio del linear layer</strong>:</p>
$$
\mathbf{h}_{fc1}[b, j] = \text{ReLU} \left( \sum_{i=1}^{2048} \mathbf{x}_{global}[b, i] \cdot \mathbf{W}_1[j, i] + \mathbf{b}_1[j] \right), \quad b = 1, \dots, B, \; j = 1, \dots, 2048
$$
<p><strong>Intuizione</strong>:
- Proietta l&rsquo;embedding in un nuovo spazio 2048D
- Permette interazioni non-lineari tra tutte le 2048 feature
- ReLU introduce non-linearit√† critica
- Questo layer &ldquo;ragiona&rdquo; sull&rsquo;embedding: combina e ricombina le feature per creare rappresentazioni ancora pi√π astratte
- √à come un layer di &ldquo;integrazione semantica&rdquo;</p>
<p><strong>Output</strong>: $\mathbf{h}_{fc1} \in \mathbb{R}^{B \times 2048}$</p>
<h3 id="83-secondo-dropout">8.3 Secondo Dropout</h3>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">fc_audioset</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">2048</span><span class="p">,</span> <span class="n">classes_num</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="n">embedding</span> <span class="o">=</span> <span class="n">F</span><span class="o">.</span><span class="n">dropout</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="o">=</span><span class="mf">0.5</span><span class="p">,</span> <span class="n">training</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">)</span> <span class="c1"># (B, 2048)</span>
<span class="n">clipwise_output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_audioset</span><span class="p">(</span><span class="n">x</span><span class="p">))</span> <span class="c1"># (B, classes_num)</span>
</code></pre></div>
</div>
</div>

<p><strong>Dettaglio importante</strong>: Il secondo dropout (50%) viene applicato per creare 
l&rsquo;<code>embedding</code> che viene restituito, ma <strong>NON</strong> viene applicato a $\mathbf{x}_{global}$ prima della 
classificazione. Infatti, <code>fc_audioset</code> opera su $\mathbf{x}_{global}$ (output di fc1+ReLU senza 
il secondo dropout) e non su $embedding$.</p>
<p>Questo significa che:
- <strong>Embedding restituito</strong>: Pi√π regolarizzato (con dropout)
- <strong>Classificazione</strong>: Usa tutte le attivazioni (senza dropout)</p>
<p>Questa scelta permette di avere un embedding pi√π robusto per task downstream 
mantenendo la massima informazione per la classificazione principale.</p>
<h3 id="84-layer-di-classificazione-fc_audioset">8.4 Layer di Classificazione (fc_audioset)</h3>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">clipwise_output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">fc_audioset</span><span class="p">(</span><span class="n">x</span><span class="p">))</span>
</code></pre></div>
</div>
</div>

<p><strong>Operazione</strong>:</p>
$$
\mathbf{z} = \mathbf{h}_{fc1} \mathbf{W}_2^\top + \mathbf{b}_2
$$
<p>dove $\mathbf{W}_2 \in \mathbb{R}^{C \times 2048}$, $\mathbf{b}_2 \in \mathbb{R}^{C}$, $C$ = numero di classi.</p>
<p><strong>Sigmoid activation</strong> (multi-label classification):</p>
$$
\mathbf{p}[b, c] = \sigma(\mathbf{z}[b, c]) = \frac{1}{1 + e^{-\mathbf{z}[b, c]}}
$$
<p><strong>Output</strong>: $\mathbf{p} \in \mathbb{R}^{B \times C}$, con $p[b, c] \in (0, 1)$</p>
<p><strong>Intuizione</strong>:
- Proietta l&rsquo;embedding nelle dimensioni delle classi target
- Sigmoid converte logits in probabilit√† indipendenti per ogni classe
- <strong>Multi-label</strong>: ogni classe pu√≤ essere presente/assente indipendentemente (es. un audio pu√≤ contenere sia &ldquo;musica&rdquo; che &ldquo;parlato&rdquo;)
- Ogni $p[b, c]$ rappresenta la confidenza che la classe $c$ sia presente nel sample $b$
- Training: Binary Cross-Entropy Loss su ogni classe</p>
<h2 id="9-output-della-rete">9. Output della Rete</h2>
<div class="code-visible">
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">output_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;clipwise_output&#39;</span><span class="p">:</span> <span class="n">clipwise_output</span><span class="p">,</span>  <span class="c1"># (B, classes_num)</span>
    <span class="s1">&#39;embedding&#39;</span><span class="p">:</span> <span class="n">embedding</span>                <span class="c1"># (B, 2048)</span>
<span class="p">}</span>
</code></pre></div>
</div>
</div>

<p><strong>clipwise_output</strong>: Probabilit√† per ciascuna classe audio (es. probabilit√† che l&rsquo;audio contenga &ldquo;pianoforte&rdquo;, &ldquo;voce umana&rdquo;, &ldquo;traffico&rdquo;, ecc.)</p>
<p><strong>embedding</strong>: Rappresentazione ad alta dimensionalit√† dell&rsquo;audio, utile per:
- Transfer learning
- Similarity search
- Clustering
- Downstream tasks</p>
<h2 id="10-architettura-complessiva-visualizzazione-del-flusso">10. Architettura Complessiva: Visualizzazione del Flusso</h2>
<p><img src="/images/tikz/cde8894f2cc2931a043bac786c150b9b.svg" style="display: block; width: 100%; height: auto; max-height: 600px;" class="tikz-svg" /></p>
            </div>
            
            <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee;">
                <p><strong>Keywords:</strong> deep learning, neural networks, CNN, RNN, transformers, data, neural, network</p>
                <p><small>This is the SEO-optimized version. <a href="http://localhost:3000/theory/deep-learning/Convolutional Neural Networks/CNN14">Click here for the interactive experience</a>.</small></p>
            </footer>
        </article>
    </div>
    
    <!-- Vercel Analytics (opzionale) -->
    <script>
      // Track SEO page views
      if (window.gtag) {
        gtag('config', 'GA_TRACKING_ID', {
          page_title: 'CNN14 (PANN): Architettura per Audio Classification',
          page_location: 'http://localhost:3000/theory/deep-learning/Convolutional Neural Networks/CNN14'
        });
      }
    </script>
</body>
</html>