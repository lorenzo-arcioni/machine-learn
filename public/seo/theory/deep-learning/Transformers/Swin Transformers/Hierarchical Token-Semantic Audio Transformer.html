<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>HTS-AT: Hierarchical Token-Semantic Audio Transformer | Deep Learning | ML Theory</title>
    <meta name="description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta name="keywords" content="deep learning, neural networks, CNN, RNN, transformers, model, data, neural">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph -->
    <meta property="og:title" content="HTS-AT: Hierarchical Token-Semantic Audio Transformer">
    <meta property="og:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta property="og:url" content="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Hierarchical Token-Semantic Audio Transformer">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Machine Learning Theory">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="HTS-AT: Hierarchical Token-Semantic Audio Transformer">
    <meta name="twitter:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Hierarchical Token-Semantic Audio Transformer">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "HTS-AT: Hierarchical Token-Semantic Audio Transformer",
      "description": "pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...",
      "url": "http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Hierarchical Token-Semantic Audio Transformer",
      "datePublished": "2026-01-15T00:29:00.169Z",
      "author": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      },
      "publisher": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      }
    }
    </script>
    
    <!-- Critical CSS -->
    <style>
      body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        line-height: 1.6; 
        margin: 0; 
        padding: 20px;
        background: #fafafa;
      }
      .container { 
        max-width: 800px; 
        margin: 0 auto; 
        background: white;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      h1 { 
        color: #1a1a1a; 
        margin-bottom: 20px; 
        font-size: 2.5rem;
        line-height: 1.2;
      }
      .meta { 
        color: #666; 
        margin-bottom: 30px; 
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .content h2, .content h3 { 
        color: #2c3e50; 
        margin-top: 40px; 
        margin-bottom: 16px;
      }
      .content p { 
        margin-bottom: 16px; 
        color: #333;
      }
      .content code { 
        background: #f8f9fa; 
        padding: 2px 6px; 
        border-radius: 4px; 
        font-size: 0.9em;
        color: #e83e8c;
      }
      .content pre { 
        background: #f8f9fa; 
        padding: 20px; 
        border-radius: 8px; 
        overflow-x: auto;
        border: 1px solid #e9ecef;
      }
      .react-redirect {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #007acc;
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(0,122,204,0.3);
        transition: transform 0.2s;
      }
      .react-redirect:hover {
        transform: translateY(-1px);
      }
      @media (max-width: 768px) { 
        body { padding: 10px; }
        .container { padding: 20px; }
        h1 { font-size: 2rem; }
        .react-redirect { position: static; display: block; text-align: center; margin-bottom: 20px; }
      }
    </style>
</head>
<body>
    <!-- Link per versione interattiva -->
    <a href="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Hierarchical Token-Semantic Audio Transformer" class="react-redirect">ðŸš€ View Interactive Version</a>
    
    <div class="container">
        <article>
            <header>
                <h1>HTS-AT: Hierarchical Token-Semantic Audio Transformer</h1>
                <div class="meta">
                    <strong>Topic:</strong> Deep Learning | 
                    <strong>Updated:</strong> 15/01/2026
                </div>
            </header>
            
            <div class="content">
                <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

/* Styling per blocchi di codice */
.codehilite {
    background: transparent !important;
    border-radius: 8px;
    overflow: hidden;
}
.codehilite pre {
    background: transparent !important;
    margin: 0 !important;
    padding: 20px !important;
    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;
    font-size: 14px !important;
    line-height: 1.5 !important;
    white-space: pre !important;
    overflow-x: auto !important;
    color: inherit !important;
}
.codehilite code {
    background: transparent !important;
    padding: 0 !important;
    font-family: inherit !important;
}


.code-wrapper { 
    position: relative; 
}
.copy-button {
    position: absolute; 
    top: 12px; 
    right: 12px; 
    padding: 6px 12px; 
    font-size: 12px;
    cursor: pointer; 
    border: none; 
    border-radius: 4px; 
    background: rgba(255,255,255,0.9);
    color: #374151; 
    transition: all 0.2s ease;
    font-weight: 500;
}
.copy-button:hover { 
    background: rgba(255,255,255,1);
    transform: translateY(-1px);
}


details.code-container {
    border: 1px solid #e5e7eb; 
    border-radius: 12px; 
    background: #f9fafb;
    margin: 16px 0;
    transition: all 0.3s ease;
}
details.code-container summary {
    padding: 12px 16px;
    font-size: 14px; 
    color: #6b7280; 
    cursor: pointer; 
    outline: none; 
    user-select: none;
    font-weight: 500;
}
details.code-container[open] summary::after { 
    content: " (Hide Code)"; 
    color: #9ca3af; 
}
details.code-container:not([open]) summary::after { 
    content: " (Show Code)"; 
    color: #d1d5db; 
}
details.code-container .code-wrapper {
    padding: 0;
    margin: 0;
}
/* Blocchi di codice sempre visibili */
.code-visible {
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    margin: 16px 0;
}
.code-visible .code-wrapper {
    padding: 0;
    margin: 0;
}
</style>
<h2 id="introduzione">Introduzione</h2>
<p>HTS-AT (Hierarchical Token-Semantic Audio Transformer) Ã¨ un&rsquo;architettura basata su <strong><a href="/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer" class="text-blue-600 hover:underline">Swin Transformer</a></strong> progettata specificamente per la classificazione e il rilevamento di eventi sonori. A differenza delle architetture CNN tradizionali, HTS-AT utilizza meccanismi di <strong>self-attention</strong> gerarchici per catturare dipendenze a lungo raggio negli spettrogrammi audio.</p>
<p>Il nome deriva da:
- <strong>Hierarchical</strong>: elaborazione multi-scala attraverso layer successivi
- <strong>Token-Semantic</strong>: rappresentazione basata su token (patch) con significato semantico
- <strong>Audio Transformer</strong>: architettura transformer adattata per l&rsquo;audio</p>
<p>L&rsquo;architettura elabora l&rsquo;audio attraverso una pipeline che:
1. Converte il segnale audio in rappresentazione tempo-frequenza (log-mel spectrogram)
2. Divide lo spettrogramma in patch non sovrapposte (tokenizzazione)
3. Elabora le patch attraverso blocchi Swin Transformer gerarchici
4. Produce output di classificazione sia frame-wise che clip-wise</p>
<h2 id="panoramica-del-pipeline">Panoramica del Pipeline</h2>
<ol>
<li><strong>Estrazione dello Spettrogramma</strong> - STFT per conversione tempo-frequenza</li>
<li><strong>Estrazione Log-Mel</strong> - rappresentazione percettiva con mel-scale</li>
<li><strong>Normalizzazione Batch</strong> - standardizzazione delle feature mel</li>
<li><strong>Data Augmentation</strong> (solo training) - SpecAugmentation e Mixup</li>
<li><strong>Reshape a Immagine 2D</strong> - preparazione per patch embedding</li>
<li><strong>Patch Embedding</strong> - tokenizzazione dello spettrogramma</li>
<li><strong>Position Embedding</strong> (opzionale) - encoding posizionale assoluto</li>
<li><strong>Blocchi Swin Transformer</strong> - elaborazione gerarchica con attention</li>
<li><strong>Pooling e Classificazione</strong> - aggregazione e predizione</li>
</ol>
<p><img src="/images/posts/x1.png" alt="Panoramica del Pipeline" style="display: block; margin-left: auto; margin-right: auto;"></p>
<h2 id="1-input-forma-donda-audio">1. Input: Forma d&rsquo;Onda Audio</h2>
<p>L&rsquo;input Ã¨ un segnale audio campionato digitalmente:</p>
$$
\mathbf{s} \in \mathbb{R}^{B \times N_{samples}}
$$
<p>dove:
- $B$ = dimensione del batch
- $N_{samples}$ = numero di campioni audio (tipicamente variabile, es. 10 secondi a 32 kHz = 320000 campioni)</p>
<p>Il segnale $\mathbf{s}$ rappresenta lâ€™<strong>onda sonora campionata nel tempo</strong>, contenente tutte le informazioni acustiche della clip, incluse frequenze, intensitÃ  e dinamiche temporali. A questo livello, il modello non ha ancora estratto caratteristiche significative: ogni campione Ã¨ semplicemente un valore numerico che descrive lâ€™ampiezza del segnale in un dato istante.  </p>
<p>Prima di essere passato al successivo step (feature extraction), $\mathbf{s}$ puÃ² subire alcune operazioni preliminari come:<br />
- <strong>Normalizzazione</strong> per garantire che lâ€™ampiezza rientri in un intervallo standard (ad esempio [-1, 1]),<br />
- <strong>Rimozione del DC offset</strong> per centrare la waveform intorno a zero,<br />
- <strong>Eventuale trimming o padding</strong> per uniformare la durata delle clip allâ€™interno del batch.  </p>
<p>Questo passaggio Ã¨ cruciale perchÃ© definisce la <strong>rappresentazione numerica di base</strong> su cui le successive trasformazioni (come trasformate di Fourier, mel-spectrogrammi o convoluzioni) potranno estrarre caratteristiche semantiche e acustiche rilevanti per lâ€™allenamento contrastivo.</p>
<h2 id="2-estrazione-dello-spettrogramma">2. Estrazione dello Spettrogramma</h2>
<h3 id="21-short-time-fourier-transform-stft">2.1 Short-Time Fourier Transform (STFT)</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">spectrogram_extractor</span> <span class="o">=</span> <span class="n">Spectrogram</span><span class="p">(</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>      <span class="c1"># es. 1024</span>
    <span class="n">hop_length</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">hop_size</span><span class="p">,</span>     <span class="c1"># es. 320</span>
    <span class="n">win_length</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
    <span class="n">window</span><span class="o">=</span><span class="s1">&#39;hann&#39;</span><span class="p">,</span>
    <span class="n">center</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="n">pad_mode</span><span class="o">=</span><span class="s1">&#39;reflect&#39;</span><span class="p">,</span>
    <span class="n">freeze_parameters</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Matematicamente</strong>:</p>
$$
\mathbf{X}_{STFT} = \text{STFT}(\mathbf{s}) \implies \mathbf{X}_{STFT}[b, m, k] = \sum_{n=0}^{N-1} \mathbf{s}[b, n + mH - \underbrace{\frac{N}{2}}_\text{center=True}] \cdot w[n] \cdot e^{-j 2 \pi k n/N_{fft}}
$$
<p>Le dimensioni del tensore risultante sono:</p>
$$
\mathbf{X_{STFT}} \in \mathbb{C}^{B \times C \times T_{frames} \times F_{bins}}
$$
<p>Con:</p>
<ul>
<li>Dimensione della finestra $N=1024$</li>
<li>Numero di punti della FFT $N_{fft} = 1024$</li>
<li>$C$ numero di canali (1 per il segnale audio mono e 2 per il segnale audio stereo)</li>
<li>hop size $= 320$ (configurazione tipica)</li>
<li>$T_{frames} = \lfloor N_{samples} / 320 \rfloor + 1$</li>
<li>$F_{bins} = N_{fft}/2 + 1 = 1024/2 + 1 = 513$</li>
</ul>
<p>Se $N_{samples} < N_{fft}$, si effettua zero-padding della finestra prima della FFT per aumentare la risoluzione in frequenza.</p>
<p><strong>Output dello spettrogramma di potenza</strong>:</p>
<p>PoichÃ© la STFT produce valori complessi, si calcola il <strong>power spectrogram</strong> per ottenere una rappresentazione reale e positiva:</p>
<p>Calcolo del modulo quadrato per ogni elemento complesso:</p>
$$
\mathbf{S} = |\mathbf{X}_{STFT}|^2 = \text{Re}(\mathbf{X}_{STFT})^2 + \text{Im}(\mathbf{X}_{STFT})^2 \in \mathbb{R}^{B \times 1 \times T_{frames} \times F_{bins}}
$$
<p>Dove per ogni elemento:</p>
$$
\mathbf{S}[b, 1, t, f] = (\text{Re}(\mathbf{X}_{STFT}[b, 1, t, f]))^2 + (\text{Im}(\mathbf{X}_{STFT}[b, 1, t, f]))^2
$$
<p>Questa operazione element-wise converte i valori complessi della STFT in valori reali positivi che rappresentano l&rsquo;energia del segnale.</p>
<p>Le dimensioni rimangono le stesse.</p>
<p>Con $N_{fft} = 1024$ e hop size $= 320$ (configurazione tipica):
- $T_{frames} = \lfloor N_{samples} / 320 \rfloor + 1$
- $F_{bins} = 1024/2 + 1 = 513$</p>
<p><strong>Intuizione</strong>: Decompone il segnale nelle sue componenti di frequenza nel tempo, creando una rappresentazione 2D tempo-frequenza.</p>
<h2 id="3-log-mel-spectrogram">3. Log-Mel Spectrogram</h2>
<h3 id="31-mel-filter-bank">3.1 Mel Filter Bank</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">logmel_extractor</span> <span class="o">=</span> <span class="n">LogmelFilterBank</span><span class="p">(</span>
    <span class="n">sr</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">sample_rate</span><span class="p">,</span>          <span class="c1"># es. 32000 Hz</span>
    <span class="n">n_fft</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>       <span class="c1"># es. 1024</span>
    <span class="n">n_mels</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">mel_bins</span><span class="p">,</span>         <span class="c1"># es. 64</span>
    <span class="n">fmin</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">fmin</span><span class="p">,</span>               <span class="c1"># es. 50 Hz</span>
    <span class="n">fmax</span><span class="o">=</span><span class="n">config</span><span class="o">.</span><span class="n">fmax</span><span class="p">,</span>               <span class="c1"># es. 14000 Hz</span>
    <span class="n">ref</span><span class="o">=</span><span class="mf">1.0</span><span class="p">,</span>
    <span class="n">amin</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span>
    <span class="n">top_db</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
    <span class="n">freeze_parameters</span><span class="o">=</span><span class="kc">True</span>
<span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Scala Mel</strong>:
La scala Mel Ã¨ una trasformazione non lineare che approssima la percezione umana delle frequenze:</p>
$$
\text{Mel}(f) = 2595 \log_{10}\left(1 + \frac{f}{700}\right)
$$
<p><strong>Applicazione filtri triangolari</strong>:</p>
<p>A partire dallo spettrogramma $\mathbf{S} \in \mathbb{R}^{B \times 1 \times T_{frames} \times F_{bins}}$, si applica una banca di filtri triangolari $H_m[k]$ dove ogni filtro $m$ aggrega i bin di frequenza lineari $k$ per ottenere bande di frequenza percettivamente significative:</p>
$$
\mathbf{M}_{mel} = \mathbf{S}\mathbf{H}^\top \implies \mathbf{M}_{mel}[b, 1, t, m] = \sum_{k=0}^{F_{bins}-1} \mathbf{S}[b, 1, t, k] \cdot H_m[k]
$$
<ul>
<li>$H_m[k]$ Ã¨ la risposta del filtro triangolare $m$-esimo,</li>
<li>$\mathbf{H} \in \mathbb{R}^{M_{mel} \times F_{bins}}$ Ã¨ la matrice completa dei filtri Mel ($M_{mel}=64$),</li>
<li>La somma avviene lungo la dimensione delle frequenze,</li>
<li>$b = 0, \dots, B-1$, $t = 0, \dots, T_{frames}-1$, $m = 0, \dots, M_{mel}-1$.</li>
</ul>
<p><strong>Conversione in log-scale</strong>:</p>
$$
\mathbf{M}_{log}[b, 1, t, m] = 10 \log_{10}(\max(\mathbf{M}_{mel}[b, 1, t, m], \epsilon))
$$
<p>dove $\epsilon = 10^{-10}$ previene logaritmi di zero.</p>
<p><strong>Output</strong>:</p>
$$
\mathbf{M}_{log} \in \mathbb{R}^{B \times 1 \times T_{frames} \times 64}
$$
<p><strong>Intuizione</strong>: 
- La scala Mel riflette la percezione non-lineare delle frequenze da parte dell&rsquo;orecchio umano
- I filtri triangolari aggregano bin di frequenza adiacenti in bande percettivamente significative
- La scala logaritmica comprime la gamma dinamica</p>
<h2 id="4-normalizzazione-batch-bn0">4. Normalizzazione Batch (bn0)</h2>
<h3 id="41-trasposizione-per-batch-norm">4.1 Trasposizione per Batch Norm</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (B, 1, T, 64) â†’ (B, 64, T, 1)</span>
<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">bn0</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">)</span>  <span class="c1"># (B, 64, T, 1) â†’ (B, 1, T, 64)</span>
</code></pre></div>
</div>
</details>

<p>Dove <code>self.bn0 = nn.BatchNorm2d(config.mel_bins)</code> con <code>config.mel_bins = 64</code>.</p>
<p><strong>PerchÃ© questa trasposizione?</strong></p>
<p><code>BatchNorm2d(64)</code> normalizza lungo la dimensione dei canali (dim=1). Il log-Mel ha forma $(B, 1, T, 64)$ con 1 canale e 64 bande Mel sull&rsquo;ultima dimensione. La trasposizione sposta le 64 bande Mel nella posizione dei canali per permettere la normalizzazione indipendente di ogni banda.</p>
<h3 id="42-operazione-di-batch-normalization">4.2 Operazione di Batch Normalization</h3>
<p>Per ogni banda Mel $m$:</p>
$$
\hat{x}[b, m, t, f] = \gamma_m \frac{x[b, m, t, f] - \mu_m}{\sqrt{\sigma_m^2 + \epsilon}} + \beta_m
$$
<p>dove:
- $\mu_m$ = media su batch e posizioni spazio-temporali per la banda $m$
- $\sigma_m^2$ = varianza corrispondente
- $\gamma_m, \beta_m$ = parametri apprendibili
- $\epsilon = 10^{-5}$ = costante per stabilitÃ  numerica</p>
<p><strong>Intuizione</strong>: Standardizza ogni banda di frequenza indipendentemente, permettendo a tutte le bande di contribuire equamente al training.</p>
<h2 id="5-data-augmentation-solo-training">5. Data Augmentation (Solo Training)</h2>
<h3 id="51-specaugmentation">5.1 SpecAugmentation</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">spec_augmenter</span> <span class="o">=</span> <span class="n">SpecAugmentation</span><span class="p">(</span>
    <span class="n">time_drop_width</span><span class="o">=</span><span class="mi">64</span><span class="p">,</span>
    <span class="n">time_stripes_num</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span>
    <span class="n">freq_drop_width</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span>
    <span class="n">freq_stripes_num</span><span class="o">=</span><span class="mi">2</span>
<span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Time masking</strong>: Azzera 2 strisce verticali casuali di larghezza massima 64 frame:</p>
$$
\mathbf{M}[b, 1, t, m] = 0 \quad \text{per } t \in [t_0, t_0 + w_t], \quad w_t \leq 64
$$
<p><strong>Frequency masking</strong>: Azzera 2 strisce orizzontali casuali di larghezza massima 8 bande:</p>
$$
\mathbf{M}[b, 1, t, m] = 0 \quad \text{per } m \in [m_0, m_0 + w_m], \quad w_m \leq 8
$$
<p><strong>Intuizione</strong>: Simula occlusioni e distorsioni reali, forzando la rete a non dipendere da specifiche regioni tempo-frequenza.</p>
<h3 id="52-mixup">5.2 Mixup</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span> <span class="ow">and</span> <span class="n">mixup_lambda</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">do_mixup</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">mixup_lambda</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Operazione</strong>:</p>
$$
\tilde{x} = \lambda x_i + (1-\lambda) x_j
$$
$$
\tilde{y} = \lambda y_i + (1-\lambda) y_j
$$
<p>dove $\lambda \sim \text{Beta}(\alpha, \alpha)$.</p>
<p><strong>Intuizione</strong>: Crea esempi ibridi che migliorano la generalizzazione e riducono l&rsquo;overfitting.</p>
<h2 id="6-reshape-a-immagine-2d">6. Reshape a Immagine 2D</h2>
<p>Prima del patch embedding, lo spettrogramma viene trasformato in un formato &ldquo;immagine&rdquo; con dimensioni specifiche.</p>
<h3 id="61-parametri-di-configurazione">6.1 Parametri di Configurazione</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">=</span> <span class="mi">256</span>              <span class="c1"># dimensione target dell&#39;immagine</span>
<span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">//</span> <span class="n">config</span><span class="o">.</span><span class="n">mel_bins</span>  <span class="c1"># es. 256 // 64 = 4</span>
</code></pre></div>
</div>
</details>

<p>Questo significa:
- <strong>Target height</strong>: $256$ pixel
- <strong>Target width</strong>: $256$ pixel<br />
- <strong>Freq ratio</strong>: $4$ (numero di ripetizioni delle bande Mel in verticale)</p>
<h3 id="62-funzione-reshape_wav2img">6.2 Funzione reshape_wav2img</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">reshape_wav2img</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">T</span><span class="p">,</span> <span class="n">F</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># es. (B, 1, T_frames, 64)</span>
    <span class="n">target_T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span><span class="p">)</span>  <span class="c1"># 256 * 4 = 1024</span>
    <span class="n">target_F</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span>      <span class="c1"># 256 // 4 = 64</span>
</code></pre></div>
</div>
</details>

<p><strong>Step 1: Interpolazione temporale</strong> (se necessario)</p>
<p>Se $T < 1024$:</p>
$$
x = \text{interpolate}(x, (1024, F), \text{mode}=\text{bicubic})
$$
<p><strong>Step 2: Interpolazione frequenziale</strong> (se necessario)</p>
<p>Se $F < 64$ (in realtÃ  giÃ  64, quindi salta):</p>
$$
x = \text{interpolate}(x, (T, 64), \text{mode}=\text{bicubic})
$$
<p><strong>Step 3: Reshape con freq_ratio</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>  <span class="c1"># (B, 1, 64, 1024)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span><span class="p">,</span> <span class="n">T</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span><span class="p">)</span>
<span class="c1"># (B, 1, 64, 4, 256)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>  <span class="c1"># (B, 1, 4, 64, 256)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span> <span class="o">*</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span><span class="p">)</span>
<span class="c1"># (B, 1, 256, 256)</span>
</code></pre></div>
</div>
</details>

<p><strong>Risultato finale</strong>:</p>
$$
\mathbf{x}_{img} \in \mathbb{R}^{B \times 1 \times 256 \times 256}
$$
<p><strong>Intuizione</strong>: 
- Lo spettrogramma viene riorganizzato in un&rsquo;immagine quadrata $256 \times 256$
- Le 64 bande Mel vengono &ldquo;espanse&rdquo; verticalmente a 256 pixel (4 ripetizioni)
- La dimensione temporale viene compressa da 1024 a 256 frame
- Questo formato Ã¨ ideale per l&rsquo;elaborazione tramite patch embedding</p>
<h2 id="7-patch-embedding">7. Patch Embedding</h2>
<p>Il patch embedding converte l&rsquo;immagine $256 \times 256$ in una sequenza di token (patch).</p>
<h3 id="71-configurazione">7.1 Configurazione</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">patch_size</span> <span class="o">=</span> <span class="mi">4</span>         <span class="c1"># dimensione della patch</span>
<span class="bp">self</span><span class="o">.</span><span class="n">patch_stride</span> <span class="o">=</span> <span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>  <span class="c1"># stride della patch (non sovrapposto)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">patch_embed</span> <span class="o">=</span> <span class="n">PatchEmbed</span><span class="p">(</span>
    <span class="n">img_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span><span class="p">,</span>      <span class="c1"># 256</span>
    <span class="n">patch_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">patch_size</span><span class="p">,</span>   <span class="c1"># 4</span>
    <span class="n">in_chans</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">in_chans</span><span class="p">,</span>       <span class="c1"># 1</span>
    <span class="n">embed_dim</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">embed_dim</span><span class="p">,</span>     <span class="c1"># es. 96</span>
    <span class="n">norm_layer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_layer</span><span class="p">,</span>
    <span class="n">patch_stride</span><span class="o">=</span><span class="n">patch_stride</span>     <span class="c1"># (4, 4)</span>
<span class="p">)</span>
</code></pre></div>
</div>
</details>

<h3 id="72-struttura-del-patchembed">7.2 Struttura del PatchEmbed</h3>
<p>Il modulo <code>PatchEmbed</code> contiene:</p>
<ol>
<li><strong>Conv2D per proiezione</strong>:</li>
</ol>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">padding</span> <span class="o">=</span> <span class="p">((</span><span class="n">patch_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="n">patch_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span> 
           <span class="p">(</span><span class="n">patch_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="n">patch_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span> <span class="o">//</span> <span class="mi">2</span><span class="p">)</span>
<span class="c1"># Con patch_size=4 e stride=4: padding = (0, 0)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">proj</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span>
    <span class="n">in_chans</span><span class="p">,</span>      <span class="c1"># 1</span>
    <span class="n">embed_dim</span><span class="p">,</span>     <span class="c1"># 96</span>
    <span class="n">kernel_size</span><span class="o">=</span><span class="n">patch_size</span><span class="p">,</span>      <span class="c1"># (4, 4)</span>
    <span class="n">stride</span><span class="o">=</span><span class="n">patch_stride</span><span class="p">,</span>         <span class="c1"># (4, 4)</span>
    <span class="n">padding</span><span class="o">=</span><span class="n">padding</span>              <span class="c1"># (0, 0)</span>
<span class="p">)</span>
</code></pre></div>
</div>
</details>

<ol>
<li><strong>Normalizzazione</strong> (opzionale):</li>
</ol>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm_layer</span><span class="p">(</span><span class="n">embed_dim</span><span class="p">)</span> <span class="k">if</span> <span class="n">norm_layer</span> <span class="k">else</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
</code></pre></div>
</div>
</details>

<h3 id="73-operazione-di-patch-embedding">7.3 Operazione di Patch Embedding</h3>
<p><strong>Input</strong>: $\mathbf{x}_{img} \in \mathbb{R}^{B \times 1 \times 256 \times 256}$</p>
<p><strong>Proiezione Conv2D</strong>:</p>
<p>La convoluzione con kernel $4 \times 4$ e stride $(4, 4)$ divide l&rsquo;immagine in patch non sovrapposte:</p>
$$
\mathbf{x}_{conv} = \text{Conv2d}(\mathbf{x}_{img})
$$
<p><strong>Dimensioni output della convoluzione</strong>:</p>
$$
H_{out} = \frac{256 - 4 + 2 \cdot 0}{4} + 1 = 64
$$
$$
W_{out} = \frac{256 - 4 + 2 \cdot 0}{4} + 1 = 64
$$
<p>Quindi: $\mathbf{x}_{conv} \in \mathbb{R}^{B \times 96 \times 64 \times 64}$</p>
<p><strong>Flatten e Transpose</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (B, 96, 64, 64) â†’ (B, 96, 4096) â†’ (B, 4096, 96)</span>
</code></pre></div>
</div>
</details>

$$
\mathbf{x}_{patches} \in \mathbb{R}^{B \times 4096 \times 96}
$$
<p>dove $4096 = 64 \times 64$ Ã¨ il numero totale di patch.</p>
<p><strong>Normalizzazione</strong> (se presente):</p>
$$
\mathbf{x}_{embed} = \text{LayerNorm}(\mathbf{x}_{patches})
$$
<p><strong>Output finale del patch embedding</strong>:</p>
$$
\mathbf{x}_{embed} \in \mathbb{R}^{B \times 4096 \times 96}
$$
<p><strong>Intuizione</strong>:
- Ogni patch $4 \times 4$ dello spettrogramma originale diventa un token di dimensione 96
- L&rsquo;immagine $256 \times 256$ viene divisa in $64 \times 64 = 4096$ patch
- Ogni token rappresenta una regione locale tempo-frequenza dello spettrogramma
- Questo Ã¨ analogo alla tokenizzazione del testo in NLP, ma applicato a regioni spaziali</p>
<h3 id="74-grid-size-e-patches-resolution">7.4 Grid Size e Patches Resolution</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">img_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="n">patch_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> 
                  <span class="n">img_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="n">patch_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># self.grid_size = (256 // 4, 256 // 4) = (64, 64)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">patches_resolution</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">grid_size</span>  <span class="c1"># (64, 64)</span>
<span class="bp">self</span><span class="o">.</span><span class="n">num_patches</span> <span class="o">=</span> <span class="mi">64</span> <span class="o">*</span> <span class="mi">64</span> <span class="o">=</span> <span class="mi">4096</span>
</code></pre></div>
</div>
</details>

<p>Questi valori saranno usati dai layer successivi per operazioni che richiedono la struttura spaziale 2D.</p>
<h2 id="8-position-embedding-opzionale">8. Position Embedding (Opzionale)</h2>
<h3 id="81-absolute-position-embedding">8.1 Absolute Position Embedding</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">ape</span><span class="p">:</span>  <span class="c1"># Absolute Position Embedding</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">absolute_pos_embed</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
        <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">num_patches</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">embed_dim</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="n">trunc_normal_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">absolute_pos_embed</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">.02</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p>Se abilitato (<code>ape=True</code>):</p>
$$
\mathbf{x}_{pos} = \mathbf{x}_{embed} + \mathbf{P}_{abs}
$$
<p>dove $\mathbf{P}_{abs} \in \mathbb{R}^{1 \times 4096 \times 96}$ Ã¨ un parametro apprendibile.</p>
<p><strong>Intuizione</strong>: 
- I transformer sono permutation-invariant (non hanno nozione di ordine)
- Il position embedding aggiunge informazione sulla posizione spaziale di ogni patch
- Questo aiuta il modello a distinguere patch in diverse posizioni dello spettrogramma
- In HTS-AT, l&rsquo;uso Ã¨ opzionale perchÃ© i Swin Transformer usano <strong>relative position bias</strong> intrinseco</p>
<h3 id="82-position-dropout">8.2 Position Dropout</h3>
<p>Applicato sia durante il training che durante l&rsquo;inferenza.</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">pos_drop</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">p</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_rate</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">pos_drop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p>Applica dropout dopo il position embedding per regolarizzazione.</p>
<h2 id="9-stochastic-depth-drop-path">9. Stochastic Depth (Drop Path)</h2>
<p>Prima di entrare nei layer, viene definito uno schedule di stochastic depth:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">dpr</span> <span class="o">=</span> <span class="p">[</span><span class="n">x</span><span class="o">.</span><span class="n">item</span><span class="p">()</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">torch</span><span class="o">.</span><span class="n">linspace</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_path_rate</span><span class="p">,</span> <span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">))]</span>
</code></pre></div>
</div>
</details>

<p><strong>Esempio con configurazione tipica</strong>:
- <code>depths = [2, 2, 6, 2]</code> â†’ totale blocchi = $2 + 2 + 6 + 2 = 12$
- <code>drop_path_rate = 0.1</code>
- <code>dpr = [0.000, 0.009, 0.018, 0.027, 0.036, 0.045, 0.055, 0.064, 0.073, 0.082, 0.091, 0.100]</code></p>
<p><strong>Intuizione</strong>: La probabilitÃ  di drop aumenta linearmente con la profonditÃ  del layer. Questo migliora la regolarizzazione e facilita il training di reti profonde.</p>
<p>Quindi, durante training: Drop Path attivo con probabilitÃ  crescente nei layer piÃ¹ profondi. Mentre durante inferenza: Drop Path <em>completamente disabilitato</em>.</p>
<h2 id="10-architettura-gerarchica-basiclayer">10. Architettura Gerarchica: BasicLayer</h2>
<p>HTS-AT Ã¨ organizzato in <strong>4 stage gerarchici</strong> (configurazione tipica: <code>depths=[2, 2, 6, 2]</code>):</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">=</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">)</span>  <span class="c1"># 4</span>
<span class="bp">self</span><span class="o">.</span><span class="n">layers</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">()</span>

<span class="k">for</span> <span class="n">i_layer</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span><span class="p">):</span>
    <span class="n">layer</span> <span class="o">=</span> <span class="n">BasicLayer</span><span class="p">(</span>
        <span class="n">dim</span><span class="o">=</span><span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">embed_dim</span> <span class="o">*</span> <span class="mi">2</span> <span class="o">**</span> <span class="n">i_layer</span><span class="p">),</span>
        <span class="n">input_resolution</span><span class="o">=</span><span class="p">(</span><span class="n">patches_resolution</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i_layer</span><span class="p">),</span>
                          <span class="n">patches_resolution</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="n">i_layer</span><span class="p">)),</span>
        <span class="n">depth</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">[</span><span class="n">i_layer</span><span class="p">],</span>
        <span class="n">num_heads</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">[</span><span class="n">i_layer</span><span class="p">],</span>
        <span class="n">window_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span>
        <span class="n">mlp_ratio</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp_ratio</span><span class="p">,</span>
        <span class="n">qkv_bias</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qkv_bias</span><span class="p">,</span>
        <span class="n">qk_scale</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">qk_scale</span><span class="p">,</span>
        <span class="n">drop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">drop_rate</span><span class="p">,</span>
        <span class="n">attn_drop</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attn_drop_rate</span><span class="p">,</span>
        <span class="n">drop_path</span><span class="o">=</span><span class="n">dpr</span><span class="p">[</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">[:</span><span class="n">i_layer</span><span class="p">]):</span><span class="nb">sum</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">[:</span><span class="n">i_layer</span> <span class="o">+</span> <span class="mi">1</span><span class="p">])],</span>
        <span class="n">norm_layer</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_layer</span><span class="p">,</span>
        <span class="n">downsample</span><span class="o">=</span><span class="n">PatchMerging</span> <span class="k">if</span> <span class="p">(</span><span class="n">i_layer</span> <span class="o">&lt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_layers</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="k">else</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">use_checkpoint</span><span class="o">=</span><span class="n">use_checkpoint</span><span class="p">,</span>
        <span class="n">norm_before_mlp</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">norm_before_mlp</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">layers</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">layer</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<h3 id="101-progressione-gerarchica">10.1 Progressione Gerarchica</h3>
<p>Con <code>embed_dim=96</code> e <code>num_heads=[4, 8, 16, 32]</code>:</p>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Input Dim</th>
<th>Num Blocks</th>
<th>Num Heads</th>
<th>Input Resolution</th>
<th>Output Dim</th>
<th>Output Resolution</th>
</tr>
</thead>
<tbody>
<tr>
<td>1</td>
<td>96</td>
<td>2</td>
<td>4</td>
<td>(64, 64)</td>
<td>192</td>
<td>(32, 32)</td>
</tr>
<tr>
<td>2</td>
<td>192</td>
<td>2</td>
<td>8</td>
<td>(32, 32)</td>
<td>384</td>
<td>(16, 16)</td>
</tr>
<tr>
<td>3</td>
<td>384</td>
<td>6</td>
<td>16</td>
<td>(16, 16)</td>
<td>768</td>
<td>(8, 8)</td>
</tr>
<tr>
<td>4</td>
<td>768</td>
<td>2</td>
<td>32</td>
<td>(8, 8)</td>
<td>768</td>
<td>(8, 8)</td>
</tr>
</tbody>
</table>
<p><strong>Note importanti</strong>:
- Ogni stage (tranne l&rsquo;ultimo) <strong>raddoppia</strong> il numero di canali
- Ogni stage (tranne l&rsquo;ultimo) <strong>dimezza</strong> la risoluzione spaziale
- Il numero di attention heads aumenta proporzionalmente ai canali
- L&rsquo;ultimo stage non fa downsampling</p>
<p><strong>Intuizione</strong>:
- <strong>Elaborazione multi-scala</strong>: ogni stage cattura pattern a diversa granularitÃ 
- <strong>Stage 1</strong>: feature di basso livello (texture locali, transizioni frequenziali)
- <strong>Stage 2-3</strong>: feature di medio livello (pattern temporali, strutture armoniche)
- <strong>Stage 4</strong>: feature di alto livello (rappresentazioni semantiche globali)</p>
<h2 id="11-basiclayer-struttura-di-uno-stage">11. BasicLayer: Struttura di uno Stage</h2>
<p>Ogni <code>BasicLayer</code> contiene:
1. Una sequenza di <code>SwinTransformerBlock</code> (es. 2, 2, 6, o 2 blocchi)
2. Un layer di <code>PatchMerging</code> (tranne l&rsquo;ultimo stage)</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">BasicLayer</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">input_resolution</span><span class="p">,</span> <span class="n">depth</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">([</span>
            <span class="n">SwinTransformerBlock</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
            <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
        <span class="p">])</span>

        <span class="k">if</span> <span class="n">downsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="n">downsample</span><span class="p">(</span><span class="n">input_resolution</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="o">=</span> <span class="kc">None</span>
</code></pre></div>
</div>
</details>

<h3 id="111-forward-pass-di-basiclayer">11.1 Forward Pass di BasicLayer</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">attns</span> <span class="o">=</span> <span class="p">[]</span>
    <span class="k">for</span> <span class="n">blk</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">blocks</span><span class="p">:</span>
        <span class="n">x</span><span class="p">,</span> <span class="n">attn</span> <span class="o">=</span> <span class="n">blk</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
            <span class="n">attns</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">attn</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">))</span>

    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">downsample</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">training</span><span class="p">:</span>
        <span class="n">attn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">(</span><span class="n">attns</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">attn</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">mean</span><span class="p">(</span><span class="n">attn</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">attn</span>
</code></pre></div>
</div>
</details>

<p><strong>Flusso</strong>:
1. Passa attraverso tutti i blocchi Swin Transformer
2. (Opzionale) Salva le attention maps per visualizzazione
3. Applica PatchMerging per downsampling
4. Restituisce output e attention maps aggregate</p>
<h2 id="12-swintransformerblock-il-cuore-dellarchitettura">12. SwinTransformerBlock: Il Cuore dell&rsquo;Architettura</h2>
<p><img src="/images/posts/sw-mha.png" alt="Immagine di un SwinTransformerBlock" style="display: block; margin-left: auto; margin-right: auto;"></p>
<p>Il <code>SwinTransformerBlock</code> Ã¨ l&rsquo;unitÃ  fondamentale di elaborazione, che implementa:
1. <strong>Window-based Multi-head Self-Attention (W-MSA)</strong> o <strong>Shifted Window MSA (SW-MSA)</strong>
2. <strong>Multi-Layer Perceptron (MLP)</strong>
3. <strong>Residual connections</strong>
4. <strong>Layer Normalization</strong></p>
<h3 id="121-struttura-del-swintransformerblock">12.1 Struttura del SwinTransformerBlock</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">SwinTransformerBlock</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">input_resolution</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="mi">8</span><span class="p">,</span> 
                 <span class="n">shift_size</span><span class="o">=</span><span class="mi">0</span><span class="p">,</span> <span class="n">mlp_ratio</span><span class="o">=</span><span class="mf">4.</span><span class="p">,</span> <span class="o">...</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_resolution</span> <span class="o">=</span> <span class="n">input_resolution</span>  <span class="c1"># (H, W)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span> <span class="o">=</span> <span class="n">num_heads</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size</span>  <span class="c1"># es. 8</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span> <span class="o">=</span> <span class="n">shift_size</span>    <span class="c1"># 0 per W-MSA, window_size//2 per SW-MSA</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp_ratio</span> <span class="o">=</span> <span class="n">mlp_ratio</span>      <span class="c1"># 4.0</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">norm1</span> <span class="o">=</span> <span class="n">norm_layer</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attn</span> <span class="o">=</span> <span class="n">WindowAttention</span><span class="p">(</span>
            <span class="n">dim</span><span class="p">,</span> <span class="n">window_size</span><span class="o">=</span><span class="n">to_2tuple</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">),</span> 
            <span class="n">num_heads</span><span class="o">=</span><span class="n">num_heads</span><span class="p">,</span> <span class="o">...</span>
        <span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop_path</span> <span class="o">=</span> <span class="n">DropPath</span><span class="p">(</span><span class="n">drop_path</span><span class="p">)</span> <span class="k">if</span> <span class="n">drop_path</span> <span class="o">&gt;</span> <span class="mf">0.</span> <span class="k">else</span> <span class="n">nn</span><span class="o">.</span><span class="n">Identity</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm2</span> <span class="o">=</span> <span class="n">norm_layer</span><span class="p">(</span><span class="n">dim</span><span class="p">)</span>  <span class="c1"># o BatchNorm1d se norm_before_mlp=&#39;bn&#39;</span>

        <span class="n">mlp_hidden_dim</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">dim</span> <span class="o">*</span> <span class="n">mlp_ratio</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">mlp</span> <span class="o">=</span> <span class="n">Mlp</span><span class="p">(</span><span class="n">in_features</span><span class="o">=</span><span class="n">dim</span><span class="p">,</span> <span class="n">hidden_features</span><span class="o">=</span><span class="n">mlp_hidden_dim</span><span class="p">,</span> <span class="o">...</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Parametri chiave</strong>:
- <code>window_size</code>: dimensione della finestra locale (tipicamente 8)
- <code>shift_size</code>: offset per shifted window (0 o <code>window_size//2</code>)
- <code>mlp_ratio</code>: fattore di espansione del MLP (tipicamente 4)</p>
<h3 id="122-alternanza-w-msa-e-sw-msa">12.2 Alternanza W-MSA e SW-MSA</h3>
<p>All&rsquo;interno di ogni <code>BasicLayer</code>, i blocchi alternano tra W-MSA e SW-MSA:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="bp">self</span><span class="o">.</span><span class="n">blocks</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">ModuleList</span><span class="p">([</span>
    <span class="n">SwinTransformerBlock</span><span class="p">(</span>
        <span class="o">...</span><span class="p">,</span>
        <span class="n">shift_size</span><span class="o">=</span><span class="mi">0</span> <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="k">else</span> <span class="n">window_size</span> <span class="o">//</span> <span class="mi">2</span><span class="p">,</span>
        <span class="o">...</span>
    <span class="p">)</span>
    <span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">depth</span><span class="p">)</span>
<span class="p">])</span>
</code></pre></div>
</div>
</details>

<ul>
<li><strong>Blocco pari</strong> (<code>i=0, 2, 4, ...</code>): <code>shift_size=0</code> â†’ <strong>W-MSA</strong> (window attention senza shift)</li>
<li><strong>Blocco dispari</strong> (<code>i=1, 3, 5, ...</code>): <code>shift_size=window_size//2</code> â†’ <strong>SW-MSA</strong> (shifted window attention)</li>
</ul>
<p><strong>Intuizione</strong>: L&rsquo;alternanza permette di catturare sia interazioni locali che cross-window, superando la limitazione delle finestre isolate.</p>
<h3 id="123-forward-pass-del-swintransformerblock">12.3 Forward Pass del SwinTransformerBlock</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_resolution</span>  <span class="c1"># es. (64, 64) nel primo stage</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>             <span class="c1"># es. (B, 4096, 96)</span>
    <span class="c1"># L deve essere = H * W</span>

    <span class="n">shortcut</span> <span class="o">=</span> <span class="n">x</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>  <span class="c1"># reshape a formato spaziale 2D</span>

    <span class="c1"># Cyclic shift (solo per SW-MSA)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">shifted_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">),</span> 
                               <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">shifted_x</span> <span class="o">=</span> <span class="n">x</span>

    <span class="c1"># Partition windows</span>
    <span class="n">x_windows</span> <span class="o">=</span> <span class="n">window_partition</span><span class="p">(</span><span class="n">shifted_x</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
    <span class="c1"># (num_windows*B, window_size, window_size, C)</span>
    <span class="n">x_windows</span> <span class="o">=</span> <span class="n">x_windows</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="c1"># (num_windows*B, window_size*window_size, C)</span>

    <span class="c1"># W-MSA/SW-MSA</span>
    <span class="n">attn_windows</span><span class="p">,</span> <span class="n">attn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attn</span><span class="p">(</span><span class="n">x_windows</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">attn_mask</span><span class="p">)</span>

    <span class="c1"># Merge windows</span>
    <span class="n">attn_windows</span> <span class="o">=</span> <span class="n">attn_windows</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="n">shifted_x</span> <span class="o">=</span> <span class="n">window_reverse</span><span class="p">(</span><span class="n">attn_windows</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">)</span>

    <span class="c1"># Reverse cyclic shift (solo per SW-MSA)</span>
    <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">shifted_x</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">),</span> 
                       <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">shifted_x</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span> <span class="o">*</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

    <span class="c1"># Residual connection + DropPath</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">shortcut</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_path</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="c1"># FFN (MLP)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop_path</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">mlp</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">norm2</span><span class="p">(</span><span class="n">x</span><span class="p">)))</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">attn</span>
</code></pre></div>
</div>
</details>

<p><strong>Flusso dettagliato</strong>:
1. <strong>Layer Norm 1</strong> + reshape a 2D
2. <strong>Cyclic shift</strong> (solo SW-MSA)
3. <strong>Window partition</strong> (divisione in finestre)
4. <strong>Window Attention</strong>
5. <strong>Window merge</strong> (ricostruzione)
6. <strong>Reverse shift</strong> (solo SW-MSA)
7. <strong>Residual connection 1</strong> con DropPath
8. <strong>Layer Norm 2</strong> + <strong>MLP</strong>
9. <strong>Residual connection 2</strong> con DropPath</p>
<h3 id="123-forward-pass-concettuale">12.3 Forward Pass (concettuale)</h3>
<p>Flusso chiave (concettuale, senza codice):
1. LayerNorm su x_in
2. (eventuale) cyclic shift per SW-MSA
3. partition in finestre
4. window-attention su ogni finestra
5. merge delle finestre e reverse shift
6. residual connection + DropPath (output dell&rsquo;attenzione)
7. LayerNorm + MLP
8. residual connection + DropPath (output finale del blocco)</p>
<h3 id="124-formula-semplificata-versione-leggibile">12.4 Formula semplificata (versione leggibile)</h3>
<p>Versione con dettagli di normalizzazione e DropPath:</p>
$$
\boxed{%
x_{\text{out}} = x_{\text{in}} \;+\; \text{DropPath}\big(\text{SW-MSA}(\text{LN}(x_{\text{in}}))\big)
\;+\; \text{DropPath}\big(\text{MLP}(\text{LN}(x_{\text{in}} + \text{SW-MSA}(\text{LN}(x_{\text{in}}))))\big)
}
$$
<p>Versione ancora piÃ¹ sintetica e intuitiva:</p>
$$
\boxed{%
x_{\text{out}} = x_{\text{in}} \;+\; \text{Attn}(x_{\text{in}}) \;+\; \text{MLP}\big(x_{\text{in}} + \text{Attn}(x_{\text{in}})\big)
}
$$
<p><strong>Dove:</strong>
- $\text{LN}$ = Layer Normalization
- $\text{SW-MSA}$ = Shifted Window Multi-Head Self-Attention (o W-MSA quando non c&rsquo;Ã¨ shift)
- $\text{Attn}(x_{\text{in}})$ Ã¨ una abbreviazione per $\text{SW-MSA}(\text{LN}(x_{\text{in}}))$
- $\text{DropPath}(\cdot)$ = stochastic depth (residual dropout)
- $\text{MLP}(\cdot)$ = feed-forward (due linear + attivazione)</p>
<p>Queste formule riassumono il comportamento operativo del blocco: l&rsquo;output Ã¨ la somma residua dell&rsquo;input piÃ¹ l&rsquo;aggiornamento apportato dall&rsquo;attenzione locale e dal successivo MLP di raffinamento.</p>
<h2 id="13-window-partition-e-reverse">13. Window Partition e Reverse</h2>
<h3 id="131-window-partition">13.1 Window Partition</h3>
<p>Divide l&rsquo;input 2D in finestre non sovrapposte:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">window_partition</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">window_size</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        x: (B, H, W, C)</span>
<span class="sd">        window_size: int (es. 8)</span>
<span class="sd">    Returns:</span>
<span class="sd">        windows: (num_windows*B, window_size, window_size, C)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span> <span class="o">//</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> 
               <span class="n">W</span> <span class="o">//</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
    <span class="n">windows</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">windows</span>
</code></pre></div>
</div>
</details>

<p><strong>Esempio con H=64, W=64, window_size=8</strong>:</p>
<p>Input: $(B, 64, 64, C)$</p>
<p>Step 1: Reshape
$$
x \rightarrow (B, 8, 8, 8, 8, C)
$$</p>
<p>Step 2: Permute per raggruppare le finestre
$$
x \rightarrow (B, 8, 8, 8, 8, C) \text{ (posizioni: 0,1,3,2,4,5)}
$$</p>
<p>Step 3: View per collassare le finestre
$
x \rightarrow (B \cdot 64, 8, 8, C)
$</p>
<p>dove $64 = (64/8) \times (64/8) = 8 \times 8$ Ã¨ il numero di finestre.</p>
<p><strong>Output</strong>: $(num_windows \cdot B, window_size, window_size, C)$ con $num_windows = 64$</p>
<p><strong>Intuizione</strong>: L&rsquo;immagine viene divisa in una griglia di finestre $8 \times 8$, ognuna contenente $8 \times 8 = 64$ token. L&rsquo;attention sarÃ  calcolata indipendentemente all&rsquo;interno di ogni finestra.</p>
<h3 id="132-window-reverse">13.2 Window Reverse</h3>
<p>Ricostruisce l&rsquo;immagine 2D dalle finestre:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">window_reverse</span><span class="p">(</span><span class="n">windows</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        windows: (num_windows*B, window_size, window_size, C)</span>
<span class="sd">        window_size: int</span>
<span class="sd">        H, W: altezza e larghezza dell&#39;immagine originale</span>
<span class="sd">    Returns:</span>
<span class="sd">        x: (B, H, W, C)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="n">windows</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">/</span> <span class="p">(</span><span class="n">H</span> <span class="o">*</span> <span class="n">W</span> <span class="o">/</span> <span class="n">window_size</span> <span class="o">/</span> <span class="n">window_size</span><span class="p">))</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">windows</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span> <span class="o">//</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">W</span> <span class="o">//</span> <span class="n">window_size</span><span class="p">,</span> 
                     <span class="n">window_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div>
</div>
</details>

<p>Inverte esattamente le operazioni di <code>window_partition</code>.</p>
<h2 id="14-windowattention-self-attention-locale">14. WindowAttention: Self-Attention Locale</h2>
<p>Il modulo <code>WindowAttention</code> implementa la <strong>multi-head self-attention</strong> all&rsquo;interno di ogni finestra, con l&rsquo;aggiunta cruciale del <strong>relative position bias</strong>.</p>
<h3 id="141-struttura-del-windowattention">14.1 Struttura del WindowAttention</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">WindowAttention</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">window_size</span><span class="p">,</span> <span class="n">num_heads</span><span class="p">,</span> <span class="n">qkv_bias</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span> 
                 <span class="n">qk_scale</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">attn_drop</span><span class="o">=</span><span class="mf">0.</span><span class="p">,</span> <span class="n">proj_drop</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>                      <span class="c1"># es. 96</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">=</span> <span class="n">window_size</span>      <span class="c1"># (8, 8)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span> <span class="o">=</span> <span class="n">num_heads</span>          <span class="c1"># es. 4</span>
        <span class="n">head_dim</span> <span class="o">=</span> <span class="n">dim</span> <span class="o">//</span> <span class="n">num_heads</span>         <span class="c1"># 96 // 4 = 24</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">scale</span> <span class="o">=</span> <span class="n">qk_scale</span> <span class="ow">or</span> <span class="n">head_dim</span> <span class="o">**</span> <span class="o">-</span><span class="mf">0.5</span>  <span class="c1"># 1/sqrt(24) â‰ˆ 0.204</span>

        <span class="c1"># Relative position bias table</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_position_bias_table</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
            <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">2</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="p">(</span><span class="mi">2</span> <span class="o">*</span> <span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">),</span> 
                        <span class="n">num_heads</span><span class="p">)</span>
        <span class="p">)</span>  <span class="c1"># (15*15, num_heads) = (225, 4)</span>

        <span class="c1"># QKV projection</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">qkv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span> <span class="o">*</span> <span class="mi">3</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="n">qkv_bias</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">attn_drop</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">attn_drop</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">dim</span><span class="p">,</span> <span class="n">dim</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">proj_drop</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">proj_drop</span><span class="p">)</span>

        <span class="c1"># Initialize relative position bias</span>
        <span class="n">trunc_normal_</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">relative_position_bias_table</span><span class="p">,</span> <span class="n">std</span><span class="o">=</span><span class="mf">.02</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">softmax</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Softmax</span><span class="p">(</span><span class="n">dim</span><span class="o">=-</span><span class="mi">1</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<h3 id="142-relative-position-bias-calcolo-degli-indici">14.2 Relative Position Bias: Calcolo degli Indici</h3>
<p>Il relative position bias Ã¨ un&rsquo;innovazione chiave di Swin Transformer. Invece di usare position embedding assoluti, usa bias <strong>relativi</strong> che dipendono dalla distanza tra token.</p>
<p><strong>Inizializzazione degli indici</strong> (fatto una volta nel costruttore):</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">coords_h</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span>  <span class="c1"># [0, 1, 2, ..., 7]</span>
<span class="n">coords_w</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">arange</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>  <span class="c1"># [0, 1, 2, ..., 7]</span>
<span class="n">coords</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">stack</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">meshgrid</span><span class="p">([</span><span class="n">coords_h</span><span class="p">,</span> <span class="n">coords_w</span><span class="p">]))</span>  <span class="c1"># (2, 8, 8)</span>
<span class="n">coords_flatten</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">coords</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># (2, 64)</span>

<span class="c1"># Calcola coordinate relative per ogni coppia di posizioni</span>
<span class="n">relative_coords</span> <span class="o">=</span> <span class="n">coords_flatten</span><span class="p">[:,</span> <span class="p">:,</span> <span class="kc">None</span><span class="p">]</span> <span class="o">-</span> <span class="n">coords_flatten</span><span class="p">[:,</span> <span class="kc">None</span><span class="p">,</span> <span class="p">:]</span>
<span class="c1"># (2, 64, 64)</span>

<span class="n">relative_coords</span> <span class="o">=</span> <span class="n">relative_coords</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
<span class="c1"># (64, 64, 2)</span>

<span class="c1"># Shift per rendere le coordinate positive</span>
<span class="n">relative_coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># +7</span>
<span class="n">relative_coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">1</span><span class="p">]</span> <span class="o">+=</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># +7</span>

<span class="c1"># Conversione a indice 1D</span>
<span class="n">relative_coords</span><span class="p">[:,</span> <span class="p">:,</span> <span class="mi">0</span><span class="p">]</span> <span class="o">*=</span> <span class="mi">2</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span>  <span class="c1"># *15</span>
<span class="n">relative_position_index</span> <span class="o">=</span> <span class="n">relative_coords</span><span class="o">.</span><span class="n">sum</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (64, 64)</span>

<span class="bp">self</span><span class="o">.</span><span class="n">register_buffer</span><span class="p">(</span><span class="s2">&quot;relative_position_index&quot;</span><span class="p">,</span> <span class="n">relative_position_index</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione del calcolo</strong>:
- Per ogni coppia di posizioni $(i, j)$ nella finestra $8 \times 8$, calcola la loro posizione relativa
- La posizione relativa varia da $-7$ a $+7$ in entrambe le dimensioni
- Dopo lo shift: varia da $0$ a $14$ (totale 15 valori)
- L&rsquo;indice 1D varia da $0$ a $224$ (totale $15 \times 15 = 225$ possibili offset)
- <code>relative_position_index[i, j]</code> contiene l&rsquo;indice nella tabella dei bias per la coppia $(i,j)$</p>
<h3 id="143-forward-pass-del-windowattention">14.3 Forward Pass del WindowAttention</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">mask</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    Args:</span>
<span class="sd">        x: (num_windows*B, N, C) dove N = window_size * window_size = 64</span>
<span class="sd">        mask: (num_windows, N, N) o None</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">B_</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># es. (64*B, 64, 96)</span>

    <span class="c1"># Step 1: Compute Q, K, V</span>
    <span class="n">qkv</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">qkv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (B_, N, 3*C) = (64*B, 64, 288)</span>
    <span class="n">qkv</span> <span class="o">=</span> <span class="n">qkv</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">,</span> <span class="n">C</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">)</span>
    <span class="c1"># (64*B, 64, 3, 4, 24)</span>
    <span class="n">qkv</span> <span class="o">=</span> <span class="n">qkv</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>
    <span class="c1"># (3, 64*B, 4, 64, 24)</span>

    <span class="n">q</span><span class="p">,</span> <span class="n">k</span><span class="p">,</span> <span class="n">v</span> <span class="o">=</span> <span class="n">qkv</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">qkv</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">qkv</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
    <span class="c1"># Ciascuno: (64*B, 4, 64, 24)</span>

    <span class="c1"># Step 2: Scaled dot-product attention</span>
    <span class="n">q</span> <span class="o">=</span> <span class="n">q</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">scale</span>  <span class="c1"># Scale by 1/sqrt(d_k)</span>
    <span class="n">attn</span> <span class="o">=</span> <span class="p">(</span><span class="n">q</span> <span class="o">@</span> <span class="n">k</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="o">-</span><span class="mi">2</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">))</span>  <span class="c1"># (64*B, 4, 64, 64)</span>
</code></pre></div>
</div>
</details>

<p><strong>Matematica della self-attention</strong>:</p>
<p>Per ogni head $h$:</p>
<p>$
\text{Attention}(Q_h, K_h, V_h) = \text{softmax}\left(\frac{Q_h K_h^T}{\sqrt{d_k}} + B\right) V_h
$</p>
<p>dove:
- $Q_h, K_h, V_h \in \mathbb{R}^{N \times d_k}$ con $N=64$, $d_k=24$
- $B \in \mathbb{R}^{N \times N}$ Ã¨ il relative position bias
- $\sqrt{d_k} = \sqrt{24} \approx 4.899$</p>
<p><strong>Step 3: Aggiungi Relative Position Bias</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>    <span class="c1"># Retrieve relative position bias</span>
    <span class="n">relative_position_bias</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">relative_position_bias_table</span><span class="p">[</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">relative_position_index</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="p">]</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> 
           <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="c1"># (64, 64, num_heads) = (64, 64, 4)</span>

    <span class="n">relative_position_bias</span> <span class="o">=</span> <span class="n">relative_position_bias</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
    <span class="c1"># (4, 64, 64)</span>

    <span class="n">attn</span> <span class="o">=</span> <span class="n">attn</span> <span class="o">+</span> <span class="n">relative_position_bias</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="c1"># (64*B, 4, 64, 64) + (1, 4, 64, 64)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione del relative position bias</strong>:
- Ogni coppia di posizioni $(i,j)$ ha un bias apprendibile diverso per ogni head
- Il bias dipende solo dalla <strong>distanza relativa</strong>, non dalla posizione assoluta
- Questo permette alla rete di apprendere preferenze per interazioni a diverse distanze
- Ad esempio: un head potrebbe imparare a dare piÃ¹ peso a token vicini, un altro a token lontani</p>
<p><strong>Step 4: Maschera per Shifted Window (opzionale)</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>    <span class="k">if</span> <span class="n">mask</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
        <span class="n">nW</span> <span class="o">=</span> <span class="n">mask</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>  <span class="c1"># numero di finestre</span>
        <span class="n">attn</span> <span class="o">=</span> <span class="n">attn</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B_</span> <span class="o">//</span> <span class="n">nW</span><span class="p">,</span> <span class="n">nW</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span> <span class="o">+</span> \
               <span class="n">mask</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
        <span class="n">attn</span> <span class="o">=</span> <span class="n">attn</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_heads</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">N</span><span class="p">)</span>
        <span class="n">attn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">attn</span><span class="p">)</span>
    <span class="k">else</span><span class="p">:</span>
        <span class="n">attn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">softmax</span><span class="p">(</span><span class="n">attn</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p>La maschera Ã¨ usata solo in SW-MSA per impedire l&rsquo;attenzione tra token di finestre originali diverse (dopo lo shift).</p>
<p><strong>Step 5: Applica Attention e Proietta</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>    <span class="n">attn</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">attn_drop</span><span class="p">(</span><span class="n">attn</span><span class="p">)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">attn</span> <span class="o">@</span> <span class="n">v</span><span class="p">)</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B_</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>
    <span class="c1"># (64*B, 4, 64, 24) @ (64*B, 4, 64, 24) â†’ (64*B, 4, 64, 24)</span>
    <span class="c1"># transpose â†’ (64*B, 64, 4, 24)</span>
    <span class="c1"># reshape â†’ (64*B, 64, 96)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>      <span class="c1"># Linear projection</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">proj_drop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>

    <span class="k">return</span> <span class="n">x</span><span class="p">,</span> <span class="n">attn</span>
</code></pre></div>
</div>
</details>

<p><strong>Output</strong>: 
- $x \in \mathbb{R}^{B' \times 64 \times 96}$ dove $B' = num_windows \cdot B$
- $attn \in \mathbb{R}^{B' \times 4 \times 64 \times 64}$ (attention weights)</p>
<p><strong>Intuizione complessiva del WindowAttention</strong>:
- Ogni finestra di $8 \times 8 = 64$ token viene elaborata indipendentemente
- La multi-head attention permette di catturare diversi tipi di relazioni
- Il relative position bias aggiunge informazione spaziale senza position embedding globali
- Questo design Ã¨ molto piÃ¹ efficiente della global attention ($O(N^2)$ vs $O(n \cdot (N/n)^2)$ dove $n$ Ã¨ il numero di finestre)</p>
<h2 id="15-shifted-window-attention-sw-msa">15. Shifted Window Attention (SW-MSA)</h2>
<p>Il problema del W-MSA Ã¨ che le finestre sono isolate: non c&rsquo;Ã¨ comunicazione tra finestre diverse. La <strong>Shifted Window Attention</strong> risolve questo problema.</p>
<h3 id="151-cyclic-shift">15.1 Cyclic Shift</h3>
<p>Per i blocchi con <code>shift_size = window_size // 2 = 4</code>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">shifted_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">),</span> 
                           <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div>
</div>
</details>

<p><strong>Operazione</strong>:</p>
<p>$
\text{shifted_x}[b, h, w, c] = x[b, (h + 4) \mod H, (w + 4) \mod W, c]
$</p>
<p><strong>Visualizzazione dello shift</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Prima dello shift:         Dopo shift di (-4, -4):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”             â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚  A  â”‚  B  â”‚             â”‚  D  â”‚  C  â”‚
â”‚     â”‚     â”‚             â”‚     â”‚     â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤      â†’      â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚  C  â”‚  D  â”‚             â”‚  B  â”‚  A  â”‚
â”‚     â”‚     â”‚             â”‚     â”‚     â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜             â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜
</code></pre></div>
</div>
</details>

<p>Ogni lettera rappresenta una finestra $8 \times 8$.</p>
<p><strong>Intuizione dello shift</strong>:
- Dopo lo shift, le nuove finestre contengono parti di <strong>4 finestre originali diverse</strong>
- Questo permette la comunicazione cross-window
- Il cyclic shift Ã¨ computazionalmente gratuito (solo reindexing)</p>
<h3 id="152-attention-mask-per-sw-msa">15.2 Attention Mask per SW-MSA</h3>
<p>Il problema: dopo lo shift, ogni nuova finestra contiene token da finestre originali diverse. Vogliamo permettere attenzione solo tra token della <strong>stessa finestra originale</strong>.</p>
<p><strong>Creazione della maschera</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_resolution</span>
    <span class="n">img_mask</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">((</span><span class="mi">1</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>  <span class="c1"># (1, 64, 64, 1)</span>

    <span class="n">h_slices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">),</span>
                <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">),</span>
                <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>
    <span class="n">w_slices</span> <span class="o">=</span> <span class="p">(</span><span class="nb">slice</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">),</span>
                <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">,</span> <span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">),</span>
                <span class="nb">slice</span><span class="p">(</span><span class="o">-</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">,</span> <span class="kc">None</span><span class="p">))</span>

    <span class="n">cnt</span> <span class="o">=</span> <span class="mi">0</span>
    <span class="k">for</span> <span class="n">h</span> <span class="ow">in</span> <span class="n">h_slices</span><span class="p">:</span>
        <span class="k">for</span> <span class="n">w</span> <span class="ow">in</span> <span class="n">w_slices</span><span class="p">:</span>
            <span class="n">img_mask</span><span class="p">[:,</span> <span class="n">h</span><span class="p">,</span> <span class="n">w</span><span class="p">,</span> <span class="p">:]</span> <span class="o">=</span> <span class="n">cnt</span>
            <span class="n">cnt</span> <span class="o">+=</span> <span class="mi">1</span>

    <span class="c1"># img_mask ora contiene 9 regioni numerate da 0 a 8</span>
</code></pre></div>
</div>
</details>

<p><strong>Visualizzazione della maschera</strong> (con window_size=8, shift_size=4, per una griglia 64x64):</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”
â”‚   0   â”‚ 1 â”‚   2   â”‚ 3 â”‚
â”‚       â”‚   â”‚       â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   4   â”‚ 5 â”‚   6   â”‚ 7 â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚   8   â”‚ 9 â”‚  10   â”‚11 â”‚
â”‚       â”‚   â”‚       â”‚   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”¤
â”‚  12   â”‚13 â”‚  14   â”‚15 â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”˜
</code></pre></div>
</div>
</details>

<p>Ogni numero identifica una regione della finestra originale.</p>
<p><strong>Conversione a maschera di attenzione</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>    <span class="n">mask_windows</span> <span class="o">=</span> <span class="n">window_partition</span><span class="p">(</span><span class="n">img_mask</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
    <span class="c1"># (num_windows, window_size*window_size, 1)</span>
    <span class="n">mask_windows</span> <span class="o">=</span> <span class="n">mask_windows</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">window_size</span><span class="p">)</span>
    <span class="c1"># (num_windows, 64)</span>

    <span class="n">attn_mask</span> <span class="o">=</span> <span class="n">mask_windows</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="o">-</span> <span class="n">mask_windows</span><span class="o">.</span><span class="n">unsqueeze</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
    <span class="c1"># (num_windows, 64, 64)</span>

    <span class="n">attn_mask</span> <span class="o">=</span> <span class="n">attn_mask</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">(</span><span class="n">attn_mask</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="o">-</span><span class="mf">100.0</span><span class="p">))</span>
    <span class="n">attn_mask</span> <span class="o">=</span> <span class="n">attn_mask</span><span class="o">.</span><span class="n">masked_fill</span><span class="p">(</span><span class="n">attn_mask</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">float</span><span class="p">(</span><span class="mf">0.0</span><span class="p">))</span>
</code></pre></div>
</div>
</details>

<p><strong>Risultato</strong>:
- $\text{attn_mask}[w, i, j] = 0$ se i token $i$ e $j$ provengono dalla stessa regione originale
- $\text{attn_mask}[w, i, j] = -100$ altrimenti</p>
<p>Quando questo viene aggiunto ai logits di attenzione prima del softmax, i valori $-100$ diventano effettivamente $0$ dopo il softmax (mascheratura dell&rsquo;attenzione).</p>
<h3 id="153-reverse-cyclic-shift">15.3 Reverse Cyclic Shift</h3>
<p>Dopo l&rsquo;attenzione, lo shift viene invertito:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">shifted_x</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">shift_size</span><span class="p">),</span> 
                   <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
</code></pre></div>
</div>
</details>

<p>Questo riporta i token alle loro posizioni originali.</p>
<p><strong>Intuizione complessiva di SW-MSA</strong>:
- Lo shift permette la comunicazione tra finestre diverse
- La maschera garantisce che ogni token attenda solo a token della stessa finestra originale
- L&rsquo;alternanza W-MSA/SW-MSA crea connessioni sia locali che cross-window
- Questo design mantiene l&rsquo;efficienza computazionale di W-MSA ma supera la limitazione delle finestre isolate</p>
<h2 id="16-multi-layer-perceptron-mlp">16. Multi-Layer Perceptron (MLP)</h2>
<p>Dopo ogni attention block, c&rsquo;Ã¨ un MLP per elaborazione non-lineare:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">Mlp</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">in_features</span><span class="p">,</span> <span class="n">hidden_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> <span class="n">out_features</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span> 
                 <span class="n">act_layer</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">GELU</span><span class="p">,</span> <span class="n">drop</span><span class="o">=</span><span class="mf">0.</span><span class="p">):</span>
        <span class="n">out_features</span> <span class="o">=</span> <span class="n">out_features</span> <span class="ow">or</span> <span class="n">in_features</span>
        <span class="n">hidden_features</span> <span class="o">=</span> <span class="n">hidden_features</span> <span class="ow">or</span> <span class="n">in_features</span>

        <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">in_features</span><span class="p">,</span> <span class="n">hidden_features</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">act</span> <span class="o">=</span> <span class="n">act_layer</span><span class="p">()</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">hidden_features</span><span class="p">,</span> <span class="n">out_features</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">drop</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Dropout</span><span class="p">(</span><span class="n">drop</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Forward pass</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc1</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># (B, N, C) â†’ (B, N, 4*C)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">act</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># GELU activation</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">fc2</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>       <span class="c1"># (B, N, 4*C) â†’ (B, N, C)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">drop</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">x</span>
</code></pre></div>
</div>
</details>

<p><strong>Con mlp_ratio=4 e dim=96</strong>:</p>
<p>$
\mathbf{x} \in \mathbb{R}^{B \times N \times 96} \xrightarrow{\text{fc1}} \mathbb{R}^{B \times N \times 384} \xrightarrow{\text{GELU}} \mathbb{R}^{B \times N \times 384} \xrightarrow{\text{fc2}} \mathbb{R}^{B \times N \times 96}
$</p>
<p><strong>GELU (Gaussian Error Linear Unit)</strong>:</p>
<p>$
\text{GELU}(x) = x \cdot \Phi(x) = x \cdot \frac{1}{2}\left[1 + \text{erf}\left(\frac{x}{\sqrt{2}}\right)\right]
$</p>
<p>dove $\Phi(x)$ Ã¨ la CDF della distribuzione normale standard.</p>
<p><strong>Intuizione</strong>:
- Il MLP espande le feature a 4x la dimensione originale (bottleneck invertito)
- GELU introduce non-linearitÃ  smooth (simile a ReLU ma piÃ¹ morbido)
- Dropout per regolarizzazione
- Ogni token viene elaborato indipendentemente (elaborazione point-wise)</p>
<h2 id="17-patchmerging-downsampling-gerarchico">17. PatchMerging: Downsampling Gerarchico</h2>
<p>Al termine di ogni stage (tranne l&rsquo;ultimo), <code>PatchMerging</code> riduce la risoluzione spaziale e aumenta i canali.</p>
<h3 id="171-struttura-del-patchmerging">17.1 Struttura del PatchMerging</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">class</span><span class="w"> </span><span class="nc">PatchMerging</span><span class="p">(</span><span class="n">nn</span><span class="o">.</span><span class="n">Module</span><span class="p">):</span>
    <span class="k">def</span><span class="w"> </span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">input_resolution</span><span class="p">,</span> <span class="n">dim</span><span class="p">,</span> <span class="n">norm_layer</span><span class="o">=</span><span class="n">nn</span><span class="o">.</span><span class="n">LayerNorm</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">input_resolution</span> <span class="o">=</span> <span class="n">input_resolution</span>  <span class="c1"># (H, W)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">dim</span> <span class="o">=</span> <span class="n">dim</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">dim</span><span class="p">,</span> <span class="mi">2</span> <span class="o">*</span> <span class="n">dim</span><span class="p">,</span> <span class="n">bias</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">norm</span> <span class="o">=</span> <span class="n">norm_layer</span><span class="p">(</span><span class="mi">4</span> <span class="o">*</span> <span class="n">dim</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<h3 id="172-forward-pass-del-patchmerging">17.2 Forward Pass del PatchMerging</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">def</span><span class="w"> </span><span class="nf">forward</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">x</span><span class="p">):</span>
<span class="w">    </span><span class="sd">&quot;&quot;&quot;</span>
<span class="sd">    x: (B, H*W, C)</span>
<span class="sd">    &quot;&quot;&quot;</span>
    <span class="n">H</span><span class="p">,</span> <span class="n">W</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">input_resolution</span>
    <span class="n">B</span><span class="p">,</span> <span class="n">L</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>
    <span class="k">assert</span> <span class="n">L</span> <span class="o">==</span> <span class="n">H</span> <span class="o">*</span> <span class="n">W</span><span class="p">,</span> <span class="s2">&quot;input feature has wrong size&quot;</span>
    <span class="k">assert</span> <span class="n">H</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span> <span class="ow">and</span> <span class="n">W</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">0</span><span class="p">,</span> <span class="s2">&quot;H and W must be even&quot;</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">)</span>

    <span class="c1"># Estrai 4 sottogriglie con stride 2</span>
    <span class="n">x0</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># top-left: (B, H/2, W/2, C)</span>
    <span class="n">x1</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># bottom-left: (B, H/2, W/2, C)</span>
    <span class="n">x2</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">0</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># top-right: (B, H/2, W/2, C)</span>
    <span class="n">x3</span> <span class="o">=</span> <span class="n">x</span><span class="p">[:,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">::</span><span class="mi">2</span><span class="p">,</span> <span class="p">:]</span>  <span class="c1"># bottom-right: (B, H/2, W/2, C)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">cat</span><span class="p">([</span><span class="n">x0</span><span class="p">,</span> <span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">],</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>  <span class="c1"># (B, H/2, W/2, 4*C)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">view</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">4</span> <span class="o">*</span> <span class="n">C</span><span class="p">)</span>             <span class="c1"># (B, H/2*W/2, 4*C)</span>

    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reduction</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>                <span class="c1"># (B, H/2*W/2, 2*C)</span>

    <span class="k">return</span> <span class="n">x</span>
</code></pre></div>
</div>
</details>

<p><strong>Visualizzazione</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Input (H, W, C):           Output (H/2, W/2, 2*C):
â”Œâ”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”¬â”€â”€â”€â”         â”Œâ”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 0 â”‚ 2 â”‚ 0 â”‚ 2 â”‚         â”‚  0123 â”‚  0123 â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤   â†’     â”‚concat â”‚concat â”‚
â”‚ 1 â”‚ 3 â”‚ 1 â”‚ 3 â”‚         â”œâ”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”¤
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â”‚  0123 â”‚  0123 â”‚
â”‚ 0 â”‚ 2 â”‚ 0 â”‚ 2 â”‚         â”‚concat â”‚concat â”‚
â”œâ”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¼â”€â”€â”€â”¤         â””â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”˜
â”‚ 1 â”‚ 3 â”‚ 1 â”‚ 3 â”‚
â””â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”´â”€â”€â”€â”˜
</code></pre></div>
</div>
</details>

<p>Ogni gruppo di 4 patch (0,1,2,3) viene concatenato e poi proiettato.</p>
<p><strong>Matematica</strong>:</p>
<p>Input: $\mathbf{x} \in \mathbb{R}^{B \times HW \times C}$</p>
<p>Dopo concatenazione: $\mathbf{x}_{cat} \in \mathbb{R}^{B \times \frac{HW}{4} \times 4C}$</p>
<p>Dopo proiezione lineare:</p>
<p>$
\mathbf{x}_{out} = \text{LayerNorm}(\mathbf{x}_{cat}) \cdot \mathbf{W}_{reduction}
$</p>
<p>dove $\mathbf{W}_{reduction} \in \mathbb{R}^{4C \times 2C}$.</p>
<p>Output: $\mathbf{x}_{out} \in \mathbb{R}^{B \times \frac{HW}{4} \times 2C}$</p>
<p><strong>Esempio con Stage 1 â†’ Stage 2</strong>:
- Input: $(B, 4096, 96)$ con risoluzione $(64, 64)$
- Dopo PatchMerging: $(B, 1024, 192)$ con risoluzione $(32, 32)$</p>
<p><strong>Intuizione</strong>:
- Riduce risoluzione di 2x in entrambe le dimensioni (downsampling 4x totale)
- Raddoppia il numero di canali (da $C$ a $2C$)
- Simile al pooling nelle CNN ma apprendibile
- Permette elaborazione gerarchica: feature piÃ¹ astratte a risoluzioni piÃ¹ basse</p>
<h2 id="18-elaborazione-completa-attraverso-i-4-stage">18. Elaborazione Completa attraverso i 4 Stage</h2>
<p><img src="/images/posts/HTS-AT-swin.png" alt="Elaborazione attraverso i 4 Stage" style="display: block; margin-left: auto; margin-right: auto;"></p>
<p>Riassumiamo il flusso attraverso l&rsquo;intera architettura con un esempio concreto.</p>
<p><strong>Configurazione</strong>: <code>embed_dim=96</code>, <code>depths=[2,2,6,2]</code>, <code>num_heads=[4,8,16,32]</code>, <code>window_size=8</code></p>
<h3 id="stage-1-feature-di-basso-livello">Stage 1: Feature di Basso Livello</h3>
<p><strong>Input</strong>: $(B, 4096, 96)$ con risoluzione $(64, 64)$</p>
<p><strong>Blocco 1</strong> (W-MSA):
- Window partition: $64 \times 64 \rightarrow 64$ finestre $8 \times 8$
- WindowAttention con 4 heads
- MLP con espansione 4x
- Output: $(B, 4096, 96)$</p>
<p><strong>Blocco 2</strong> (SW-MSA):
- Cyclic shift di $(-4, -4)$
- Window partition con maschera
- WindowAttention con 4 heads
- Reverse shift
- MLP
- Output: $(B, 4096, 96)$</p>
<p><strong>PatchMerging</strong>:
- Output: $(B, 1024, 192)$ con risoluzione $(32, 32)$</p>
<p><strong>Intuizione Stage 1</strong>: Cattura pattern locali e texture di base dello spettrogramma.</p>
<h3 id="stage-2-feature-di-medio-basso-livello">Stage 2: Feature di Medio-Basso Livello</h3>
<p><strong>Input</strong>: $(B, 1024, 192)$ con risoluzione $(32, 32)$</p>
<p><strong>Blocco 1</strong> (W-MSA):
- $32 \times 32 \rightarrow 16$ finestre $8 \times 8$
- WindowAttention con 8 heads
- Output: $(B, 1024, 192)$</p>
<p><strong>Blocco 2</strong> (SW-MSA):
- Shift + attention + reverse
- WindowAttention con 8 heads
- Output: $(B, 1024, 192)$</p>
<p><strong>PatchMerging</strong>:
- Output: $(B, 256, 384)$ con risoluzione $(16, 16)$</p>
<p><strong>Intuizione Stage 2</strong>: Inizia a catturare relazioni temporali e pattern armonici.</p>
<h3 id="stage-3-feature-di-alto-livello">Stage 3: Feature di Alto Livello</h3>
<p><strong>Input</strong>: $(B, 256, 384)$ con risoluzione $(16, 16)$</p>
<p><strong>6 Blocchi alternati</strong> (W-MSA, SW-MSA, W-MSA, SW-MSA, W-MSA, SW-MSA):
- $16 \times 16 \rightarrow 4$ finestre $8 \times 8$
- WindowAttention con 16 heads
- Output dopo 6 blocchi: $(B, 256, 384)$</p>
<p><strong>PatchMerging</strong>:
- Output: $(B, 64, 768)$ con risoluzione $(8, 8)$</p>
<p><strong>Intuizione Stage 3</strong>: Stage piÃ¹ profondo che cattura dipendenze semantiche complesse e pattern a lungo raggio.</p>
<h3 id="stage-4-feature-semantiche-globali">Stage 4: Feature Semantiche Globali</h3>
<p><strong>Input</strong>: $(B, 64, 768)$ con risoluzione $(8, 8)$</p>
<p><strong>Blocco 1</strong> (W-MSA):
- $8 \times 8 \rightarrow 1$ finestra $8 \times 8$
- WindowAttention con 32 heads (global attention!)
- Output: $(B, 64, 768)$</p>
<p><strong>Blocco 2</strong> (SW-MSA):
- Con risoluzione $8 \times 8$ e window_size $8$, lo shift non ha effetto pratico
- Output: $(B, 64, 768)$</p>
<p><strong>Nessun PatchMerging</strong> (ultimo stage)</p>
<p><strong>Output finale dopo normalization</strong>: $(B, 64, 768)$</p>
<p><strong>Intuizione Stage 4</strong>: Con solo 1 finestra, questo stage fa effettivamente <strong>global attention</strong> su tutta la rappresentazione compressa, catturando il context semantico completo.</p>
<h2 id="19-classificazione-tscam-token-semantic-convolutional-attention-map">19. Classificazione: TSCAM (Token-Semantic Convolutional Attention Map)</h2>
<p>Dopo i 4 stage, HTS-AT usa un approccio innovativo chiamato <strong>TSCAM</strong> per la classificazione.</p>
<h3 id="191-configurazione-tscam">19.1 Configurazione TSCAM</h3>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">config</span><span class="o">.</span><span class="n">enable_tscam</span><span class="p">:</span>
    <span class="n">SF</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span>
    <span class="c1"># SF = 256 // 8 // 4 // 4 = 2</span>

    <span class="bp">self</span><span class="o">.</span><span class="n">tscam_conv</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Conv2d</span><span class="p">(</span>
        <span class="n">in_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_features</span><span class="p">,</span>     <span class="c1"># 768</span>
        <span class="n">out_channels</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span><span class="p">,</span>     <span class="c1"># es. 527</span>
        <span class="n">kernel_size</span><span class="o">=</span><span class="p">(</span><span class="n">SF</span><span class="p">,</span> <span class="mi">3</span><span class="p">),</span>               <span class="c1"># (2, 3)</span>
        <span class="n">padding</span><span class="o">=</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="p">)</span>
    <span class="bp">self</span><span class="o">.</span><span class="n">head</span> <span class="o">=</span> <span class="n">nn</span><span class="o">.</span><span class="n">Linear</span><span class="p">(</span><span class="n">num_classes</span><span class="p">,</span> <span class="n">num_classes</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<h3 id="192-forward-pass-con-tscam">19.2 Forward Pass con TSCAM</h3>
<p><strong>Input</strong>: $\mathbf{x} \in \mathbb{R}^{B \times 64 \times 768}$ dopo l&rsquo;ultimo stage</p>
<p><strong>Step 1: Layer Normalization</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># LayerNorm(768)</span>
<span class="n">B</span><span class="p">,</span> <span class="n">N</span><span class="p">,</span> <span class="n">C</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># (B, 64, 768)</span>
</code></pre></div>
</div>
</details>

<p><strong>Step 2: Reshape a formato spaziale 2D</strong>:</p>
<p>Ricordiamo che <code>frames_num</code> Ã¨ il numero di frame temporali originali dello spettrogramma (prima del reshape_wav2img). Con configurazione tipica:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">SF</span> <span class="o">=</span> <span class="n">frames_num</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch_stride</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="c1"># frames_num / 8 / 4</span>
<span class="n">ST</span> <span class="o">=</span> <span class="n">frames_num</span> <span class="o">//</span> <span class="p">(</span><span class="mi">2</span> <span class="o">**</span> <span class="p">(</span><span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">depths</span><span class="p">)</span> <span class="o">-</span> <span class="mi">1</span><span class="p">))</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span>
<span class="c1"># frames_num / 8 / 4</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">SF</span><span class="p">,</span> <span class="n">ST</span><span class="p">)</span>
<span class="c1"># (B, 768, SF, ST)</span>
</code></pre></div>
</div>
</details>

<p>Con <code>frames_num = 1024</code> (dopo interpolazione):
- $SF = 1024 / 8 / 4 = 32$
- $ST = 1024 / 8 / 4 = 32$</p>
<p>Quindi: $\mathbf{x} \in \mathbb{R}^{B \times 768 \times 32 \times 32}$</p>
<p><strong>Nota</strong>: Questo non corrisponde alla risoluzione $(8, 8)$ dell&rsquo;ultimo stage! Il reshape utilizza <code>frames_num</code> (numero di frame temporali dello spettrogramma originale dopo interpolazione) per ricostruire la struttura spazio-temporale originale, non la risoluzione ridotta dei token dopo i stage.</p>
<p><strong>Step 3: Group 2D CNN (Frequency Grouping)</strong>:</p>
<p>Il codice raggruppa le feature lungo la dimensione di frequenza usando <code>freq_ratio</code>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">F</span><span class="p">,</span> <span class="n">T</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span>  <span class="c1"># (B, 768, 32, 32)</span>
<span class="n">c_freq_bin</span> <span class="o">=</span> <span class="n">F</span> <span class="o">//</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span>  <span class="c1"># 32 // 4 = 8</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">F</span> <span class="o">//</span> <span class="n">c_freq_bin</span><span class="p">,</span> <span class="n">c_freq_bin</span><span class="p">,</span> <span class="n">T</span><span class="p">)</span>
<span class="c1"># (B, 768, 4, 8, 32)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">()</span>
<span class="c1"># (B, 768, 8, 4, 32)</span>

<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">reshape</span><span class="p">(</span><span class="n">B</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">c_freq_bin</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
<span class="c1"># (B, 768, 8, 128)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione del grouping</strong>:
- Raggruppa le 32 bande di frequenza in 8 &ldquo;meta-bande&rdquo; di 4 bande ciascuna
- Riorganizza la dimensione temporale: da $(4, 32)$ a $(128)$
- Risultato: $(B, 768, 8, 128)$ dove 8 Ã¨ il numero di bande frequenziali aggregate e 128 Ã¨ la dimensione temporale estesa</p>
<p><strong>Step 4: Latent Output (Embedding)</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">latent_output</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avgpool</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="c1"># flatten(x, 2): (B, 768, 8, 128) â†’ (B, 768, 1024)</span>
<span class="c1"># avgpool: (B, 768, 1024) â†’ (B, 768, 1)</span>
<span class="n">latent_output</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">latent_output</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="c1"># (B, 768)</span>
</code></pre></div>
</div>
</details>

<p>Questo Ã¨ l&rsquo;<strong>embedding</strong> che verrÃ  restituito come rappresentazione densa dell&rsquo;audio.</p>
<p><strong>Step 5: TSCAM Convolution</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">tscam_conv</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (B, 768, 8, 128) â†’ (B, 527, 6, 128)</span>
</code></pre></div>
</div>
</details>

<p>La convoluzione con kernel $(2, 3)$ e padding $(0, 1)$:</p>
<p>$
F_{out} = \frac{8 - 2 + 2 \cdot 0}{1} + 1 = 7 \quad \text{(ma viene troncato a 6)}
$</p>
<p>$
T_{out} = \frac{128 - 3 + 2 \cdot 1}{1} + 1 = 128
$</p>
<p>Output: $(B, 527, 6, 128)$ dove 527 Ã¨ il numero di classi (AudioSet).</p>
<p><strong>Step 6: Flatten e Interpolazione Temporale</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">2</span><span class="p">)</span>  <span class="c1"># (B, 527, 6, 128) â†’ (B, 527, 768)</span>

<span class="c1"># Interpolazione temporale per frame-wise prediction</span>
<span class="n">fpx</span> <span class="o">=</span> <span class="n">interpolate</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span><span class="o">.</span><span class="n">permute</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span><span class="o">.</span><span class="n">contiguous</span><span class="p">(),</span> 
                  <span class="mi">8</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">patch_stride</span><span class="p">[</span><span class="mi">1</span><span class="p">])</span>
<span class="c1"># Interpola da 768 frame a 8 * 4 = 32 frame (o altro target)</span>
<span class="c1"># Output: (B, target_frames, 527)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione dell&rsquo;interpolazione</strong>:
- L&rsquo;output viene interpolato alla risoluzione temporale desiderata per le predizioni frame-wise
- <code>8 * self.patch_stride[1]</code> calcola il numero di frame target basato sulla configurazione
- Questo permette di avere predizioni temporali dettagliate per il rilevamento di eventi</p>
<p><strong>Step 7: Pooling Temporale per Clip-wise Output</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avgpool</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (B, 527, 768) â†’ (B, 527, 1)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># (B, 527)</span>
</code></pre></div>
</div>
</details>

<p><strong>Step 8: Output Finale</strong>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">output_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;framewise_output&#39;</span><span class="p">:</span> <span class="n">fpx</span><span class="p">,</span>              <span class="c1"># (B, target_frames, 527)</span>
    <span class="s1">&#39;clipwise_output&#39;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">),</span>  <span class="c1"># (B, 527)</span>
    <span class="s1">&#39;latent_output&#39;</span><span class="p">:</span> <span class="n">latent_output</span>        <span class="c1"># (B, 768)</span>
<span class="p">}</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione complessiva del TSCAM</strong>:
- <strong>Token</strong>: rappresentazioni locali tempo-frequenza (dai Swin Transformer blocks)
- <strong>Semantic</strong>: la convoluzione aggrega semanticamente le informazioni
- <strong>Convolutional Attention Map</strong>: crea mappe di attenzione per ogni classe
- Il design permette sia predizioni clip-wise (intero audio) che frame-wise (temporalmente risolte)
- Questo Ã¨ essenziale per task di sound event detection dove serve sapere <em>quando</em> avviene un evento</p>
<h3 id="193-alternative-classificazione-senza-tscam">19.3 Alternative: Classificazione Senza TSCAM</h3>
<p>Se <code>enable_tscam=False</code>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">norm</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (B, 64, 768)</span>
<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">avgpool</span><span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">transpose</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>  <span class="c1"># (B, 768, 1)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">flatten</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>  <span class="c1"># (B, 768)</span>

<span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">num_classes</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">head</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># Linear(768 â†’ 527)</span>

<span class="n">output_dict</span> <span class="o">=</span> <span class="p">{</span>
    <span class="s1">&#39;clipwise_output&#39;</span><span class="p">:</span> <span class="n">torch</span><span class="o">.</span><span class="n">sigmoid</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>  <span class="c1"># (B, 527)</span>
<span class="p">}</span>
</code></pre></div>
</div>
</details>

<p>Questo Ã¨ un approccio piÃ¹ semplice: global average pooling + layer fully connected.</p>
<h2 id="20-gestione-di-audio-di-lunghezza-variabile">20. Gestione di Audio di Lunghezza Variabile</h2>
<p>HTS-AT implementa diverse strategie per gestire audio di lunghezza variabile, specialmente durante l&rsquo;inferenza.</p>
<h3 id="201-modalita-repeat">20.1 ModalitÃ  Repeat</h3>
<p>Con <code>config.enable_repeat_mode=True</code>:</p>
<p><strong>Training</strong>: Selezione casuale di una posizione e ripetizione:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">cur_pos</span> <span class="o">=</span> <span class="n">random</span><span class="o">.</span><span class="n">randint</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_wat2img</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">cur_pos</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Inference</strong>: Elaborazione multipla e media:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">output_dicts</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">cur_pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span><span class="p">):</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">clone</span><span class="p">()</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">repeat_wat2img</span><span class="p">(</span><span class="n">tx</span><span class="p">,</span> <span class="n">cur_pos</span><span class="p">)</span>
    <span class="n">output_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward_features</span><span class="p">(</span><span class="n">tx</span><span class="p">))</span>

<span class="c1"># Media delle predizioni</span>
<span class="n">clipwise_output</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;clipwise_output&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">output_dicts</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_dicts</span><span class="p">)</span>
<span class="n">framewise_output</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="n">d</span><span class="p">[</span><span class="s2">&quot;framewise_output&quot;</span><span class="p">]</span> <span class="k">for</span> <span class="n">d</span> <span class="ow">in</span> <span class="n">output_dicts</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_dicts</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione</strong>: Elabora l&rsquo;audio da diverse &ldquo;prospettive temporali&rdquo; e fa la media per robustezza.</p>
<h3 id="202-modalita-crop-default">20.2 ModalitÃ  Crop (Default)</h3>
<p>Per audio piÃ¹ lunghi del target:</p>
<p><strong>Training</strong>: Crop casuale:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="k">if</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span><span class="p">:</span>
    <span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_wav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">crop_size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Inference</strong>: Crop sovrapposti con media:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">overlap_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">4</span>
<span class="n">crop_size</span> <span class="o">=</span> <span class="p">(</span><span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">//</span> <span class="mi">2</span>

<span class="k">for</span> <span class="n">cur_pos</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">-</span> <span class="n">crop_size</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">overlap_size</span><span class="p">):</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">crop_wav</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">crop_size</span><span class="o">=</span><span class="n">crop_size</span><span class="p">,</span> <span class="n">spe_pos</span><span class="o">=</span><span class="n">cur_pos</span><span class="p">)</span>
    <span class="n">tx</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_wav2img</span><span class="p">(</span><span class="n">tx</span><span class="p">)</span>
    <span class="n">output_dicts</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">forward_features</span><span class="p">(</span><span class="n">tx</span><span class="p">))</span>

<span class="c1"># Media delle predizioni</span>
<span class="n">clipwise_output</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_dicts</span><span class="p">)</span>
<span class="n">framewise_output</span> <span class="o">=</span> <span class="nb">sum</span><span class="p">(</span><span class="o">...</span><span class="p">)</span> <span class="o">/</span> <span class="nb">len</span><span class="p">(</span><span class="n">output_dicts</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione</strong>: Per audio lunghi, elabora segmenti sovrapposti e fa ensemble delle predizioni.</p>
<h3 id="203-modalita-infer">20.3 ModalitÃ  Infer</h3>
<p>Con <code>infer_mode=True</code>:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">frame_num</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">shape</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span>
<span class="n">target_T</span> <span class="o">=</span> <span class="nb">int</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">spec_size</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">freq_ratio</span><span class="p">)</span>
<span class="n">repeat_ratio</span> <span class="o">=</span> <span class="n">math</span><span class="o">.</span><span class="n">floor</span><span class="p">(</span><span class="n">target_T</span> <span class="o">/</span> <span class="n">frame_num</span><span class="p">)</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">x</span><span class="o">.</span><span class="n">repeat</span><span class="p">(</span><span class="n">repeats</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">repeat_ratio</span><span class="p">,</span> <span class="mi">1</span><span class="p">))</span>
<span class="n">x</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">reshape_wav2img</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
<span class="n">output_dict</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">forward_features</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Intuizione</strong>: Per audio corti, ripete i frame per raggiungere la lunghezza target.</p>
<h2 id="21-architettura-completa-visualizzazione-del-flusso">21. Architettura Completa: Visualizzazione del Flusso</h2>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code>Input Audio (B, N_samples)
    â†“
STFT â†’ Power Spectrogram (B, 1, T_frames, 513)
    â†“
Mel Filterbank â†’ Log-Mel (B, 1, T_frames, 64)
    â†“
BatchNorm2d(64) [con transpose]
    â†“
SpecAugmentation + Mixup [training only]
    â†“
Reshape to Image (B, 1, 256, 256)
    â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘             PATCH EMBEDDING                      â•‘
â•‘  Conv2d(1â†’96, kernel=4, stride=4)               â•‘
â•‘  Output: (B, 4096, 96)  [64Ã—64 patches]         â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â†“
Position Embedding [optional] + Dropout
    â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              STAGE 1: (64Ã—64, 96)                â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â•‘
â•‘  â”‚ SwinBlock 1 (W-MSA, 4 heads)           â”‚     â•‘
â•‘  â”‚   â€¢ Window Partition (8Ã—8 windows)     â”‚     â•‘
â•‘  â”‚   â€¢ WindowAttention + Rel. Pos. Bias   â”‚     â•‘
â•‘  â”‚   â€¢ MLP (96 â†’ 384 â†’ 96)                â”‚     â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â•‘
â•‘  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”     â•‘
â•‘  â”‚ SwinBlock 2 (SW-MSA, 4 heads)          â”‚     â•‘
â•‘  â”‚   â€¢ Cyclic Shift (-4, -4)              â”‚     â•‘
â•‘  â”‚   â€¢ Masked WindowAttention             â”‚     â•‘
â•‘  â”‚   â€¢ Reverse Shift                      â”‚     â•‘
â•‘  â”‚   â€¢ MLP (96 â†’ 384 â†’ 96)                â”‚     â•‘
â•‘  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜     â•‘
â•‘  PatchMerging: (B, 4096, 96) â†’ (B, 1024, 192)   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              STAGE 2: (32Ã—32, 192)               â•‘
â•‘  2Ã— SwinBlocks (W-MSA, SW-MSA) 8 heads          â•‘
â•‘  PatchMerging: (B, 1024, 192) â†’ (B, 256, 384)   â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              STAGE 3: (16Ã—16, 384)               â•‘
â•‘  6Ã— SwinBlocks alternati, 16 heads              â•‘
â•‘  PatchMerging: (B, 256, 384) â†’ (B, 64, 768)     â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              STAGE 4: (8Ã—8, 768)                 â•‘
â•‘  2Ã— SwinBlocks (global attention) 32 heads      â•‘
â•‘  No PatchMerging                                 â•‘
â•‘  Output: (B, 64, 768)                            â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â†“
LayerNorm(768)
    â†“
â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
â•‘              TSCAM HEAD                          â•‘
â•‘  Reshape â†’ (B, 768, 8, 128)                     â•‘
â•‘  Conv2d(768â†’527, kernel=(2,3))                  â•‘
â•‘  â”œâ”€â†’ AvgPool â†’ Clipwise (B, 527)                â•‘
â•‘  â””â”€â†’ Interpolate â†’ Framewise (B, T, 527)       â•‘
â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
    â†“
Output: {
  &#39;clipwise_output&#39;: (B, 527),    # predizioni per clip
  &#39;framewise_output&#39;: (B, T, 527), # predizioni temporali
  &#39;latent_output&#39;: (B, 768)        # embedding
}
</code></pre></div>
</div>
</details>

<h2 id="22-differenze-chiave-tra-hts-at-e-cnn14">22. Differenze Chiave tra HTS-AT e CNN14</h2>
<table>
<thead>
<tr>
<th>Aspetto</th>
<th>CNN14</th>
<th>HTS-AT</th>
</tr>
</thead>
<tbody>
<tr>
<td><strong>Architettura base</strong></td>
<td>Convolutional Neural Network</td>
<td>Vision Transformer (Swin)</td>
</tr>
<tr>
<td><strong>Receptive field</strong></td>
<td>Locale, aumenta gradualmente</td>
<td>Global tramite self-attention</td>
</tr>
<tr>
<td><strong>Inductive bias</strong></td>
<td>Forte (localitÃ , traslazione)</td>
<td>Debole (appreso dai dati)</td>
</tr>
<tr>
<td><strong>ComplessitÃ </strong></td>
<td>$O(N)$</td>
<td>$O(N)$ grazie a windowed attention</td>
</tr>
<tr>
<td><strong>Parametri</strong></td>
<td>~80M</td>
<td>Variabile (tipicamente 30-90M)</td>
</tr>
<tr>
<td><strong>Feature extraction</strong></td>
<td>Convoluzione gerarchica</td>
<td>Self-attention gerarchica</td>
</tr>
<tr>
<td><strong>Position encoding</strong></td>
<td>Implicito (convoluzione)</td>
<td>Explicit (relative position bias)</td>
</tr>
<tr>
<td><strong>Long-range dependencies</strong></td>
<td>Limitato</td>
<td>Eccellente</td>
</tr>
<tr>
<td><strong>Output</strong></td>
<td>Solo clip-wise</td>
<td>Clip-wise + frame-wise</td>
</tr>
</tbody>
</table>
<h2 id="23-punti-di-forza-di-hts-at">23. Punti di Forza di HTS-AT</h2>
<h3 id="231-attention-mechanism">23.1 Attention Mechanism</h3>
<p><strong>Vantaggio</strong>: Cattura dipendenze a lungo raggio nello spettrogramma.</p>
<p><strong>Esempio pratico</strong>: In musica, puÃ² collegare note distanti che fanno parte della stessa melodia. Nelle registrazioni ambientali, puÃ² associare eventi sonori correlati ma temporalmente separati.</p>
<h3 id="232-hierarchical-processing">23.2 Hierarchical Processing</h3>
<p><strong>Vantaggio</strong>: Elaborazione multi-scala naturale attraverso i 4 stage.</p>
<ul>
<li>Stage 1-2: Texture e pattern locali</li>
<li>Stage 3: Strutture temporali complesse</li>
<li>Stage 4: Context semantico globale</li>
</ul>
<h3 id="233-tscam-per-frame-wise-prediction">23.3 TSCAM per Frame-wise Prediction</h3>
<p><strong>Vantaggio</strong>: Output temporalmente risolto per sound event detection.</p>
<p><strong>Utilizzo</strong>: Non solo &ldquo;questo audio contiene un cane che abbaia&rdquo;, ma &ldquo;il cane abbaia dal secondo 2.5 al secondo 4.8&rdquo;.</p>
<h3 id="234-relative-position-bias">23.4 Relative Position Bias</h3>
<p><strong>Vantaggio</strong>: Encoding posizionale piÃ¹ flessibile rispetto agli absolute position embedding.</p>
<p><strong>Beneficio</strong>: Il modello impara preferenze per distanze relative (es. &ldquo;guarda i token a distanza 3&rdquo;) piuttosto che posizioni assolute.</p>
<h3 id="235-efficient-windowed-attention">23.5 Efficient Windowed Attention</h3>
<p><strong>Vantaggio</strong>: ComplessitÃ  lineare rispetto alla lunghezza della sequenza.</p>
<ul>
<li>Global self-attention: $O(N^2)$ dove $N$ Ã¨ il numero di token</li>
<li>Windowed attention: $O(N \cdot M)$ dove $M$ Ã¨ la dimensione della finestra (costante)</li>
</ul>
<p>Con $N = 4096$ e $M = 64$, il risparmio computazionale Ã¨ enorme.</p>
<h2 id="24-considerazioni-pratiche">24. Considerazioni Pratiche</h2>
<h3 id="241-requisiti-computazionali">24.1 Requisiti Computazionali</h3>
<ul>
<li><strong>Memoria GPU</strong>: Richiede piÃ¹ memoria di CNN14 per il training (attention matrices)</li>
<li><strong>VelocitÃ  di inferenza</strong>: Comparabile a CNN14 per audio singoli, piÃ¹ lenta per batch grandi</li>
<li><strong>Training time</strong>: Generalmente piÃ¹ lungo per convergenza</li>
</ul>
<h3 id="242-transfer-learning">24.2 Transfer Learning</h3>
<p>HTS-AT puÃ² utilizzare <strong>checkpoint pre-trained</strong> da Swin Transformer per computer vision:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="c1"># I pesi dei Swin Transformer blocks possono essere inizializzati</span>
<span class="c1"># da modelli pre-trained su ImageNet</span>
</code></pre></div>
</div>
</details>

<p>Questo accelera significativamente il training per task audio-specifici.</p>
<h3 id="243-data-augmentation">24.3 Data Augmentation</h3>
<p>La combinazione di SpecAugmentation e Mixup Ã¨ cruciale:</p>
<ul>
<li><strong>SpecAugmentation</strong>: Previene overfitting su specifiche regioni tempo-frequenza</li>
<li><strong>Mixup</strong>: Migliora generalizzazione e calibrazione delle probabilitÃ </li>
</ul>
<h3 id="244-hyperparameter-tuning">24.4 Hyperparameter Tuning</h3>
<p>Parametri critici:
- <code>window_size</code>: Trade-off tra local vs global attention (tipicamente 8)
- <code>depths</code>: ProfonditÃ  di ogni stage (tipicamente [2,2,6,2])
- <code>embed_dim</code>: Dimensione base degli embedding (tipicamente 96)
- <code>num_heads</code>: Numero di attention heads per stage (tipicamente [4,8,16,32])</p>
<h2 id="25-conclusioni">25. Conclusioni</h2>
<p>HTS-AT rappresenta un&rsquo;evoluzione significativa nell&rsquo;elaborazione audio tramite deep learning:</p>
<ol>
<li><strong>Self-attention gerarchica</strong> permette di catturare dipendenze complesse a diverse scale temporali</li>
<li><strong>Windowed attention</strong> mantiene l&rsquo;efficienza computazionale</li>
<li><strong>TSCAM</strong> fornisce output temporalmente risolti essenziali per event detection</li>
<li><strong>Relative position bias</strong> offre encoding posizionale flessibile</li>
<li><strong>Architettura modulare</strong> facilita transfer learning e customizzazione</li>
</ol>
<p>L&rsquo;architettura Ã¨ particolarmente efficace per:
- Sound event detection (localizzazione temporale)
- Audio tagging multi-label
- Music information retrieval
- Environmental sound classification</p>
<p>La complessitÃ  aggiuntiva rispetto a CNN14 Ã¨ giustificata quando il task richiede:
- Comprensione di context a lungo raggio
- Localizzazione temporale precisa degli eventi
- Handling di relazioni complesse nello spettrogramma</p>
<p><strong>Trade-off finale</strong>: HTS-AT offre maggiore espressivitÃ  e flessibilitÃ  a costo di maggiore complessitÃ  computazionale e necessitÃ  di piÃ¹ dati per il training.</p>
            </div>
            
            <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee;">
                <p><strong>Keywords:</strong> deep learning, neural networks, CNN, RNN, transformers, model, data, neural</p>
                <p><small>This is the SEO-optimized version. <a href="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Hierarchical Token-Semantic Audio Transformer">Click here for the interactive experience</a>.</small></p>
            </footer>
        </article>
    </div>
    
    <!-- Vercel Analytics (opzionale) -->
    <script>
      // Track SEO page views
      if (window.gtag) {
        gtag('config', 'GA_TRACKING_ID', {
          page_title: 'HTS-AT: Hierarchical Token-Semantic Audio Transformer',
          page_location: 'http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Hierarchical Token-Semantic Audio Transformer'
        });
      }
    </script>
</body>
</html>