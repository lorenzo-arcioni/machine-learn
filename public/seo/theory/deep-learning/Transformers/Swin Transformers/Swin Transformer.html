<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Swin Transformer: Shifted Window Transformers | Deep Learning | ML Theory</title>
    <meta name="description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta name="keywords" content="deep learning, neural networks, CNN, RNN, transformers, model, data, network">
    <meta name="robots" content="index, follow">
    
    <!-- Open Graph -->
    <meta property="og:title" content="Swin Transformer: Shifted Window Transformers">
    <meta property="og:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    <meta property="og:url" content="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer">
    <meta property="og:type" content="article">
    <meta property="og:site_name" content="Machine Learning Theory">
    
    <!-- Twitter Card -->
    <meta name="twitter:card" content="summary_large_image">
    <meta name="twitter:title" content="Swin Transformer: Shifted Window Transformers">
    <meta name="twitter:description" content="pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...">
    
    <!-- Canonical URL -->
    <link rel="canonical" href="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer">
    
    <!-- Preload critical resources -->
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://cdnjs.cloudflare.com">
    
    <!-- JSON-LD Structured Data -->
    <script type="application/ld+json">
    {
      "@context": "https://schema.org",
      "@type": "Article",
      "headline": "Swin Transformer: Shifted Window Transformers",
      "description": "pre { line-height: 125%; } td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; } span.linenos {...",
      "url": "http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer",
      "datePublished": "2025-11-24T18:40:44.606Z",
      "author": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      },
      "publisher": {
        "@type": "Organization",
        "name": "ML Theory Platform"
      }
    }
    </script>
    
    <!-- Critical CSS -->
    <style>
      body { 
        font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif; 
        line-height: 1.6; 
        margin: 0; 
        padding: 20px;
        background: #fafafa;
      }
      .container { 
        max-width: 800px; 
        margin: 0 auto; 
        background: white;
        padding: 40px;
        border-radius: 8px;
        box-shadow: 0 2px 10px rgba(0,0,0,0.1);
      }
      h1 { 
        color: #1a1a1a; 
        margin-bottom: 20px; 
        font-size: 2.5rem;
        line-height: 1.2;
      }
      .meta { 
        color: #666; 
        margin-bottom: 30px; 
        padding-bottom: 20px;
        border-bottom: 1px solid #eee;
      }
      .content h2, .content h3 { 
        color: #2c3e50; 
        margin-top: 40px; 
        margin-bottom: 16px;
      }
      .content p { 
        margin-bottom: 16px; 
        color: #333;
      }
      .content code { 
        background: #f8f9fa; 
        padding: 2px 6px; 
        border-radius: 4px; 
        font-size: 0.9em;
        color: #e83e8c;
      }
      .content pre { 
        background: #f8f9fa; 
        padding: 20px; 
        border-radius: 8px; 
        overflow-x: auto;
        border: 1px solid #e9ecef;
      }
      .react-redirect {
        position: fixed;
        top: 20px;
        right: 20px;
        background: #007acc;
        color: white;
        padding: 10px 20px;
        border-radius: 6px;
        text-decoration: none;
        font-weight: 500;
        box-shadow: 0 2px 8px rgba(0,122,204,0.3);
        transition: transform 0.2s;
      }
      .react-redirect:hover {
        transform: translateY(-1px);
      }
      @media (max-width: 768px) { 
        body { padding: 10px; }
        .container { padding: 20px; }
        h1 { font-size: 2rem; }
        .react-redirect { position: static; display: block; text-align: center; margin-bottom: 20px; }
      }
    </style>
</head>
<body>
    <!-- Link per versione interattiva -->
    <a href="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer" class="react-redirect">üöÄ View Interactive Version</a>
    
    <div class="container">
        <article>
            <header>
                <h1>Swin Transformer: Shifted Window Transformers</h1>
                <div class="meta">
                    <strong>Topic:</strong> Deep Learning | 
                    <strong>Updated:</strong> 24/11/2025
                </div>
            </header>
            
            <div class="content">
                <style>pre { line-height: 125%; }
td.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
span.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }
td.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
span.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }
.codehilite .hll { background-color: #ffffcc }
.codehilite { background: #f8f8f8; }
.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */
.codehilite .err { border: 1px solid #F00 } /* Error */
.codehilite .k { color: #008000; font-weight: bold } /* Keyword */
.codehilite .o { color: #666 } /* Operator */
.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */
.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */
.codehilite .cp { color: #9C6500 } /* Comment.Preproc */
.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */
.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */
.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */
.codehilite .gd { color: #A00000 } /* Generic.Deleted */
.codehilite .ge { font-style: italic } /* Generic.Emph */
.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */
.codehilite .gr { color: #E40000 } /* Generic.Error */
.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */
.codehilite .gi { color: #008400 } /* Generic.Inserted */
.codehilite .go { color: #717171 } /* Generic.Output */
.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */
.codehilite .gs { font-weight: bold } /* Generic.Strong */
.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */
.codehilite .gt { color: #04D } /* Generic.Traceback */
.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */
.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */
.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */
.codehilite .kp { color: #008000 } /* Keyword.Pseudo */
.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */
.codehilite .kt { color: #B00040 } /* Keyword.Type */
.codehilite .m { color: #666 } /* Literal.Number */
.codehilite .s { color: #BA2121 } /* Literal.String */
.codehilite .na { color: #687822 } /* Name.Attribute */
.codehilite .nb { color: #008000 } /* Name.Builtin */
.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */
.codehilite .no { color: #800 } /* Name.Constant */
.codehilite .nd { color: #A2F } /* Name.Decorator */
.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */
.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */
.codehilite .nf { color: #00F } /* Name.Function */
.codehilite .nl { color: #767600 } /* Name.Label */
.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */
.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */
.codehilite .nv { color: #19177C } /* Name.Variable */
.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */
.codehilite .w { color: #BBB } /* Text.Whitespace */
.codehilite .mb { color: #666 } /* Literal.Number.Bin */
.codehilite .mf { color: #666 } /* Literal.Number.Float */
.codehilite .mh { color: #666 } /* Literal.Number.Hex */
.codehilite .mi { color: #666 } /* Literal.Number.Integer */
.codehilite .mo { color: #666 } /* Literal.Number.Oct */
.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */
.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */
.codehilite .sc { color: #BA2121 } /* Literal.String.Char */
.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */
.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */
.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */
.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */
.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */
.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */
.codehilite .sx { color: #008000 } /* Literal.String.Other */
.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */
.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */
.codehilite .ss { color: #19177C } /* Literal.String.Symbol */
.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */
.codehilite .fm { color: #00F } /* Name.Function.Magic */
.codehilite .vc { color: #19177C } /* Name.Variable.Class */
.codehilite .vg { color: #19177C } /* Name.Variable.Global */
.codehilite .vi { color: #19177C } /* Name.Variable.Instance */
.codehilite .vm { color: #19177C } /* Name.Variable.Magic */
.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */

/* Styling per blocchi di codice */
.codehilite {
    background: transparent !important;
    border-radius: 8px;
    overflow: hidden;
}
.codehilite pre {
    background: transparent !important;
    margin: 0 !important;
    padding: 20px !important;
    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;
    font-size: 14px !important;
    line-height: 1.5 !important;
    white-space: pre !important;
    overflow-x: auto !important;
    color: inherit !important;
}
.codehilite code {
    background: transparent !important;
    padding: 0 !important;
    font-family: inherit !important;
}


.code-wrapper { 
    position: relative; 
}
.copy-button {
    position: absolute; 
    top: 12px; 
    right: 12px; 
    padding: 6px 12px; 
    font-size: 12px;
    cursor: pointer; 
    border: none; 
    border-radius: 4px; 
    background: rgba(255,255,255,0.9);
    color: #374151; 
    transition: all 0.2s ease;
    font-weight: 500;
}
.copy-button:hover { 
    background: rgba(255,255,255,1);
    transform: translateY(-1px);
}


details.code-container {
    border: 1px solid #e5e7eb; 
    border-radius: 12px; 
    background: #f9fafb;
    margin: 16px 0;
    transition: all 0.3s ease;
}
details.code-container summary {
    padding: 12px 16px;
    font-size: 14px; 
    color: #6b7280; 
    cursor: pointer; 
    outline: none; 
    user-select: none;
    font-weight: 500;
}
details.code-container[open] summary::after { 
    content: " (Hide Code)"; 
    color: #9ca3af; 
}
details.code-container:not([open]) summary::after { 
    content: " (Show Code)"; 
    color: #d1d5db; 
}
details.code-container .code-wrapper {
    padding: 0;
    margin: 0;
}
/* Blocchi di codice sempre visibili */
.code-visible {
    border: 1px solid #e5e7eb;
    border-radius: 12px;
    background: #f9fafb;
    margin: 16px 0;
}
.code-visible .code-wrapper {
    padding: 0;
    margin: 0;
}
</style>
<h2 id="introduzione">Introduzione</h2>
<p>Lo <strong>Swin Transformer</strong> (Shifted Window Transformer) √® un&rsquo;architettura di deep learning progettata per elaborare immagini in modo efficiente. A differenza dei Vision Transformer tradizionali che applicano l&rsquo;attenzione su tutti i pixel dell&rsquo;immagine contemporaneamente (operazione molto costosa computazionalmente), Swin Transformer utilizza una strategia intelligente basata su <strong>finestre locali</strong> che vengono spostate tra i layer per catturare sia informazioni locali che globali.</p>
<p>Immaginate di osservare un&rsquo;immagine attraverso piccole finestre: prima guardate regioni locali, poi spostate leggermente le finestre per vedere connessioni tra diverse regioni. Questa √® l&rsquo;essenza di Swin Transformer.</p>
<p>In generale, Swin Transformer trasforma un&rsquo;immagine in una sequenza di token (come in NLP) e le passa attraverso un&rsquo;architettura di deep learning, in modo da ottenere rappresentazioni gerarchiche di immagini in un embedding 1D.</p>
<h2 id="architettura-generale">Architettura Generale</h2>
<p>L&rsquo;architettura di Swin Transformer si compone di quattro fasi principali, ognuna con una risoluzione spaziale progressivamente ridotta (simile alle CNN), creando una <strong>gerarchia di rappresentazioni</strong>.</p>
<p><img src="/images/posts/121768619-038e6d80-cb9a-11eb-8cb7-daa827e7772b.png" alt="Immagine di un Transformer" style="display: block; margin-left: auto; margin-right: auto;"></p>
<h3 id="input-e-parametri">Input e Parametri</h3>
<p>Consideriamo un&rsquo;immagine di input:</p>
$$
\mathbf{X}_{\text{input}} \in \mathbb{R}^{B \times 3 \times H_0 \times W_0}
$$
<p>dove:
- $B$ = dimensione del batch (numero di immagini elaborate insieme)
- $3$ = numero di canali (RGB)
- $H_0 = W_0 = 224$ (tipicamente, dimensione immagine standard)</p>
<h2 id="fase-1-patch-partition-and-embedding">Fase 1: Patch Partition and Embedding</h2>
<h3 id="suddivisione-in-patch">Suddivisione in Patch</h3>
<p>Il primo passo consiste nel suddividere l&rsquo;immagine in patch non sovrapposte. Ogni patch viene trattata come un &ldquo;token&rdquo; (simile alle parole in NLP).</p>
<p><strong>Parametri:</strong>
- Dimensione patch: $P = 4$ (tipicamente)
- Dimensione embedding: $C = 96$ (tipicamente)</p>
<p><strong>Operazione:</strong></p>
<p>L&rsquo;immagine viene suddivisa usando una convoluzione 2D:</p>
$$
\text{Conv2D}: \mathbb{R}^{B \times 3 \times 224 \times 224} \rightarrow \mathbb{R}^{B \times 96 \times 56 \times 56}
$$
<p>Parametri della convoluzione:
- Kernel size: $4 \times 4 \implies K = 4$
- Stride: $S = 4$
- Output channels: $C_{out} = 96$</p>
<p>Questo produce:</p>
$$
H_1 = \frac{H_0}{P} = \frac{224}{4} = 56
$$
$$
W_1 = \frac{W_0}{P} = \frac{224}{4} = 56
$$
<p>La convoluzione 2D che genera gli embedding √® definita come:</p>
$$
Y_{c_{\text{out}}, h, w} =
\sum_{c_{\text{in}}=1}^{C_{\text{in}}}
\sum_{i=0}^{K-1} \sum_{j=0}^{K-1}
W_{c_{\text{out}}, c_{\text{in}}, i, j} \cdot
X_{c_{\text{in}},\, h \cdot S + i,\, w \cdot S + j}
+ b_{c_{\text{out}}} = \sum_{d=1}^{3} \sum_{r=0}^{3} \sum_{s=0}^{3}
W_{c_{out},d,r,s} \cdot X_{d,\, h\cdot4 + r,\, w\cdot4 + s} + b_{c_{out}}
$$
<p>Dove:</p>
<ul>
<li>$c_{out} \in \{1, \ldots, C_{out}\}$, $h \in \{1, \ldots, H_1\}$, $w \in \{1, \ldots, W_1\}$</li>
<li>$W \in \mathbb{R}^{96 \times 3 \times 4 \times 4}$ dove ogni $W_c$ √® un <strong>filtro</strong> che rileva un pattern visivo locale (bordi, texture, colori‚Ä¶)</li>
<li>I valori di $W$ <strong>sono parametri appresi</strong> durante il training mediante backpropagation</li>
</ul>
<p>Il numero totale di patch √®:</p>
$$
N = H_1 \times W_1 = 56 \times 56 = 3136
$$
<p><strong>Reshape per elaborazione:</strong></p>
<p>Il tensore viene riorganizzato da formato spaziale a sequenza:</p>
$$
\mathbf{X}_{\text{embed}} \in \mathbb{R}^{B \times 96 \times 56 \times 56} \rightarrow \mathbb{R}^{B \times 3136 \times 96}
$$
<p>Questo permette di elaborare i patch come sequenze di token. √à quindi pi√π comodo per applicare LayerNorm / dropout / pos embedding.</p>
<p><strong>Normalizzazione (opzionale):</strong></p>
<p>Se <code>patch_norm=True</code>, si applica <a href="/theory/deep-learning/Neural Networks/Layer Normalization" class="text-blue-600 hover:underline">Layer Normalization</a>:</p>
$$
\mathbf{X}_{\text{norm}} = \text{LayerNorm}(\mathbf{X}_{\text{embed}})
$$
<p>con $\mathbf{X}_{\text{norm}} \in \mathbb{R}^{B \times 3136 \times 96}$</p>
<h3 id="absolute-position-embedding-opzionale"><span class="text-gray-600">Absolute Position Embedding</span> (opzionale)</h3>
<p>Se il parametro <code>ape=True</code> √® attivato, viene aggiunto un embedding posizionale assoluto:</p>
$$
\mathbf{X}_{\text{pos}} = \mathbf{X}_{\text{norm}} + \mathbf{E}_{\text{abs}}
$$
<p>dove $\mathbf{E}_{\text{abs}} \in \mathbb{R}^{1 \times 3136 \times 96}$ √® un parametro apprendibile che codifica la posizione di ogni patch nell&rsquo;immagine.</p>
<p>Dimensione finale dopo dropout:</p>
$$
\mathbf{X}_0 = \text{Dropout}(\mathbf{X}_{\text{pos}}) \in \mathbb{R}^{B \times 3136 \times 96}
$$
<p><strong>Remark:</strong> Il Dropout ovviamente viene appplicato solamente durante la fase di training.</p>
<h2 id="stage-1-primo-livello-della-gerarchia">Stage 1: Primo Livello della Gerarchia</h2>
<p>Lo Stage 1 processa le patch con la massima risoluzione spaziale.</p>
<h3 id="parametri-dello-stage-1">Parametri dello Stage 1</h3>
<ul>
<li>Risoluzione input: $H_1 \times W_1 = 56 \times 56 = 3136$</li>
<li>Dimensione canali: $C_1 = 96$</li>
<li>Numero di blocchi: $\text{depth}_1 = 2$</li>
<li>Numero di head di attenzione: $\text{heads}_1 = 3$</li>
<li>Dimensione finestra: $M = 7$</li>
</ul>
<h3 id="swin-transformer-block">Swin Transformer Block</h3>
<p>Ogni stage contiene una sequenza di <strong>Swin Transformer Blocks</strong>. Ogni blocco alterna tra:
1. <strong>W-MSA</strong> (Window-based Multi-head Self Attention)
2. <strong>SW-MSA</strong> (Shifted Window-based Multi-head Self Attention)</p>
<p><img src="/images/posts/Two-consecutive-Swin-transformer-blocks.tif" alt="Swin Transformer Block" style="display: block; margin-left: auto; margin-right: auto; height: 500px;"></p>
<h2 id="w-msa-window-based-multi-head-self-attention">W-MSA: Window-based Multi-head Self Attention</h2>
<h3 id="concetto-base">Concetto Base</h3>
<p>Invece di calcolare l&rsquo;attenzione su tutte le $N = 3136$ patch (operazione $O(N^2)$), W-MSA divide l&rsquo;immagine in <strong>finestre non sovrapposte</strong> di dimensione $M \times M$ e calcola l&rsquo;attenzione <strong>localmente</strong> all&rsquo;interno di ogni finestra.</p>
<h3 id="partizionamento-in-finestre">Partizionamento in Finestre</h3>
<p><strong>Input al blocco:</strong></p>
$$
\mathbf{X} \in \mathbb{R}^{B \times (H \times W) \times C}
$$
<p>Per lo Stage 1: $H = W = 56$, $C = 96$</p>
<p><strong>Reshape spaziale:</strong></p>
<p>Dato che per calcolare l&rsquo;attenzione si lavora su finestre di dimensione $M \times M$, l&rsquo;immagine viene riorganizzata da sequenza di patch a &ldquo;immagine&rdquo; di patch. In questo modo, √® possibile calcolare l&rsquo;attenzione localmente.</p>
$$
\mathbf{X} \rightarrow \mathbb{R}^{B \times H \times W \times C} = \mathbb{R}^{B \times 56 \times 56 \times 96}
$$
<p><strong>Partizionamento:</strong></p>
<p>L&rsquo;immagine viene divisa in finestre di dimensione $M \times M$ (con $M = 7$):</p>
$$
\text{num_windows} = \frac{H}{M} \times \frac{W}{M} = \frac{56}{7} \times \frac{56}{7} = 8 \times 8 = 64
$$
<p>Ogni finestra contiene:</p>
$$
M^2 = 7 \times 7 = 49 \text{ patch}
$$
<p><strong>Reshape per l&rsquo;attenzione:</strong></p>
<p>Dopo aver suddiviso l&rsquo;immagine in finestre per il <strong>Window-based Multi-Head Self Attention (W-MSA)</strong>, otteniamo:</p>
$$
\mathbf{X}_{\text{windows}} \in \mathbb{R}^{(B \times 64) \times 49 \times 96}
$$
<p><strong>Perch√© <code>(B √ó 64)</code>?</strong>  </p>
<ul>
<li>Ogni finestra √® trattata come un piccolo &ldquo;mini-batch&rdquo; indipendente.  </li>
<li>Appiattendo batch e finestre in una singola dimensione <code>(B √ó 64)</code>, possiamo <strong>calcolare l&rsquo;attenzione su tutte le finestre in parallelo</strong> senza fare loop immagine per immagine.  </li>
<li>In pratica: tutti gli esempi del batch e tutte le finestre diventano un unico batch ‚Äúvirtuale‚Äù per l‚Äôattenzione.</li>
</ul>
<h3 id="layer-normalization">Layer Normalization</h3>
<p>Prima dell&rsquo;attenzione, si applica normalizzazione:</p>
$$
\mathbf{X}_{\text{norm}} = \text{LayerNorm}(\mathbf{X}_{\text{windows}})
$$
$$
\mathbf{X}_{\text{norm}} \in \mathbb{R}^{(B \times 64) \times 49 \times 96}
$$
<h3 id="multi-head-self-attention">Multi-Head Self Attention</h3>
<p><strong>Numero di head:</strong> $3$ (per Stage 1)</p>
<p><strong>Dimensione per head:</strong></p>
$$
d_h = \frac{C}{\text{heads}} = \frac{96}{3} = 32
$$
<p><strong>Proiezioni QKV:</strong></p>
<p>Le query, key e value vengono generate con una proiezione lineare:</p>
$$
[\mathbf{Q} \;|\; \mathbf{K} \;|\; \mathbf{V}]
 = \mathbf{X}_{\text{norm}} \mathbf{W}_{qkv}
$$
<p>dove $\mathbf{W}_{qkv} \in \mathbb{R}^{96 \times 288} (288 = 3 \times 96$ per $\mathbf Q, \mathbf K, \mathbf V)$</p>
<p>Risultato:</p>
$$
[\mathbf{Q} \;|\; \mathbf{K} \;|\; \mathbf{V}]
 \in \mathbb{R}^{(B \times 64) \times 49 \times 288}
$$
<p>L&rsquo;ultima dimensione √® una concatenazione di $\mathbf Q, \mathbf K, \mathbf V$:</p>
$$
\mathbf{Q} \in \mathbb{R}^{(B \times 64) \times 49 \times 96} , \mathbf{K} \in \mathbb{R}^{(B \times 64) \times 49 \times 96} , \mathbf{V} \in \mathbb{R}^{(B \times 64) \times 49 \times 96}].
$$
<p><strong>Separazione e Reshape:</strong></p>
$$
\mathbf{Q}, \mathbf{K}, \mathbf{V} \in \mathbb{R}^{(B \times 64) \times 49 \times 96}
$$
<p>Reshape per multi-head ($\text{heads} = 3$):</p>
$$
\mathbf{Q} \rightarrow \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}
$$
$$
\mathbf{K} \rightarrow \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}
$$
$$
\mathbf{V} \rightarrow \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}
$$
<p>In pratica, dividiamo i 96 canali in 32 canali per ogni head.</p>
<h3 id="calcolo-dellattenzione">Calcolo dell&rsquo;Attenzione</h3>
<p><strong>Scaled Dot-Product Attention:</strong>
$$
\mathbf{A} = \frac{\mathbf{Q} \mathbf{K}^T}{\sqrt{d_h}} + \mathbf{B}
$$
dove:
- $\mathbf{Q} \mathbf{K}^T \in \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 49}$ (matrice di attenzione)
- Ci dice, per ogni finestra e per ogni immagine, quanto ogni patch √® legata a tutte le altre.
- $\sqrt{d_h} = \sqrt{32} \approx 5.66$ (fattore di scala)
- $\mathbf{B} \in \mathbb{R}^{3 \times 49 \times 49}$ (relative position bias)</p>
<h3 id="relative-position-bias">Relative Position Bias</h3>
<p>Il tensore $\mathbf{B} \in \mathbb{R}^{3 \times 49 \times 49}$ √® ottenuto a partire dalla <strong>tabella dei bias</strong>.
Swin Transformer usa un <strong>bias posizionale relativo</strong> apprendibile invece di embedding posizionali assoluti per ogni token.</p>
<p><strong>Tabella dei bias:</strong>
Consideriamo la head $q$. Siano $(y_i, x_i)$ e $(y_j, x_j)$ le coordinate del patch $p_i$ (query) e $p_j$ (key) rispettivamente (rispetto alla finestra $w$), dove $y$ indica la riga e $x$ la colonna. Sia $B_{\text{table}} \in \mathbb{R}^{(2M-1) \times (2M-1)}$ la tabella dei bias relativa all&rsquo;head $q$.</p>
<p>La tabella dei bias contiene un valore di bias per ogni coppia di $(\Delta y, \Delta x)$. Quindi, per ogni coppia di patch $(y_i, x_i)$ e $(y_j, x_j)$, il valore di $B_{\text{table}}$ corrispondente all&rsquo;offset $(y_j - y_i, x_j - x_i)$ viene recuperato dalla tabella.</p>
<h4 id="esempio">Esempio</h4>
<p>Assumiamo per semplicit√† $M = 2$.
$$
w = \begin{bmatrix}
p_{0, 0} & p_{0, 1} \\
p_{1, 0} & p_{1, 1}
\end{bmatrix}
$$</p>
<p>La $B_{\text{table}}$ ha dimensione $(2M-1) \times (2M-1)$, quindi $B_{\text{table}} \in \mathbb{R}^{3 \times 3}$.</p>
$$
B_{\text{table}} =
\begin{array}{c|ccc}
\Delta y \backslash \Delta x & -1 & 0 & +1 \\
\hline
-1 & 0.1 & 0.2 & 0.3 \\
0 & 0.4 & 0.5 & 0.6 \\
+1 & 0.7 & 0.8 & 0.9 \\
\end{array}
\quad
\text{con } \Delta y, \Delta x \in \{-1, 0, +1\}
$$
<p>Questa √® la tabella dei bias relativa all&rsquo;head $q$ appresa durante il training. Questa tabella ci sta dicendo che abbiamo un bias per ogni posizione relativa tra due patch. In particolare, abbiamo un bias per tutte le posizioni relative $(\Delta y, \Delta x)$ della key rispetto alla query:
- <strong>Stessa posizione:</strong> $(0, 0)$
- <strong>Key pi√π a destra:</strong>
  - Direttamente a destra: $(0, +1)$
  - In alto a destra: $(-1, +1)$
  - In basso a destra: $(+1, +1)$
- <strong>Key pi√π a sinistra:</strong>
  - Direttamente a sinistra: $(0, -1)$
  - In alto a sinistra: $(-1, -1)$
  - In basso a sinistra: $(+1, -1)$
- <strong>Key sulla stessa colonna:</strong>
  - Sopra: $(-1, 0)$
  - Sotto: $(+1, 0)$</p>
<p>Consideriamo le coordinate di due patch: query $(y_i, x_i) = (0, 0)$ e key $(y_j, x_j) = (1, 1)$:
$$
(y_j - y_i, x_j - x_i) = (1 - 0, 1 - 0) = (+1, +1)
$$</p>
<p>quindi la key $p_{1, 1}$ √® in basso a destra rispetto alla query $p_{0, 0}$. E cos√¨ per tutte le combinazioni di patch $(y_i, x_i)$ e $(y_j, x_j)$.</p>
<p>Quindi, nel calcolo dell&rsquo;attenzione per ogni coppia di patch, in totale avremo $M^2 \times M^2 = 4 \times 4 = 16$ coppie. Ogni coppia avr√† un bias associato in base alla loro posizione relativa.</p>
<p>Assumendo che la patch in prima posizione sia la patch query e che la seconda sia la patch key $(Q, K)$:
- <strong>Stessa posizione:</strong> $(p_{0, 0}, p_{0, 0})$, $(p_{0, 1}, p_{0, 1})$, $(p_{1, 0}, p_{1, 0})$, $(p_{1, 1}, p_{1, 1})$ ‚Üí offset $(0, 0)$
- <strong>Key a destra:</strong> $(p_{0, 0}, p_{0, 1})$, $(p_{1, 0}, p_{1, 1})$ ‚Üí offset $(0, +1)$
- <strong>Key a sinistra:</strong> $(p_{0, 1}, p_{0, 0})$, $(p_{1, 1}, p_{1, 0})$ ‚Üí offset $(0, -1)$
- <strong>Key sotto:</strong> $(p_{0, 0}, p_{1, 0})$, $(p_{0, 1}, p_{1, 1})$ ‚Üí offset $(+1, 0)$
- <strong>Key sopra:</strong> $(p_{1, 0}, p_{0, 0})$, $(p_{1, 1}, p_{0, 1})$ ‚Üí offset $(-1, 0)$
- <strong>Key in basso a destra:</strong> $(p_{0, 0}, p_{1, 1})$ ‚Üí offset $(+1, +1)$
- <strong>Key in alto a sinistra:</strong> $(p_{1, 1}, p_{0, 0})$ ‚Üí offset $(-1, -1)$
- <strong>Key in basso a sinistra:</strong> $(p_{0, 1}, p_{1, 0})$ ‚Üí offset $(+1, -1)$
- <strong>Key in alto a destra:</strong> $(p_{1, 0}, p_{0, 1})$ ‚Üí offset $(-1, +1)$</p>
<p>Nell&rsquo;immagine in basso √® presente uno schema a colori che render√† sicuramente meglio l&rsquo;idea molto semplice alla base di questo approccio.</p>
<p><img src=""></p>
<h4 id="costruzione-della-matrice-di-bias-estesa">Costruzione della matrice di bias estesa</h4>
<p>Per ottenere la matrice dei bias con dimensioni $M^2 \times M^2$ (nel nostro esempio $4 \times 4$), che √® quella che verr√† poi utilizzata nel calcolo dell&rsquo;attenzione, si procede come segue:</p>
<ol>
<li>Per ogni coppia di patch $(p_i, p_j)$ nella finestra, con coordinate $(y_i, x_i)$ e $(y_j, x_j)$</li>
<li>Si calcola l&rsquo;offset relativo: $(\Delta y, \Delta x) = (y_j - y_i, x_j - x_i)$</li>
<li>Si recupera il valore corrispondente dalla tabella $B_{\text{table}}[\Delta y, \Delta x]$</li>
<li>Si inserisce questo valore nella posizione $(i, j)$ della matrice estesa</li>
</ol>
<p>Per il nostro esempio con $M = 2$, la matrice dei bias ${B} \in \mathbb{R}^{4 \times 4}$ sar√†:</p>
$$
{B} = \begin{bmatrix}
0.5 & 0.6 & 0.8 & 0.9 \\
0.4 & 0.5 & 0.7 & 0.8 \\
0.2 & 0.3 & 0.5 & 0.6 \\
0.1 & 0.2 & 0.4 & 0.5
\end{bmatrix}
$$
<p>dove ogni riga corrisponde a una patch query e ogni colonna a una patch key. Ad esempio:
- L&rsquo;elemento $(0, 3)$ corrisponde alla coppia $(p_{0,0}, p_{1,1})$ con offset $(+1, +1)$, quindi ha valore $0.9$
- L&rsquo;elemento $(0, 1)$ corrisponde alla coppia $(p_{0,0}, p_{0,1})$ con offset $(0, +1)$, quindi ha valore $0.6$
- L&rsquo;elemento $(3, 0)$ corrisponde alla coppia $(p_{1,1}, p_{0,0})$ con offset $(-1, -1)$, quindi ha valore $0.1$</p>
<p>Nel caso generale con $M = 7$ (finestre $7 \times 7$ con 49 patch), avremo $B_{\text{table}} \in \mathbb{R}^{13 \times 13}$ e ${B} \in \mathbb{R}^{49 \times 49}$ per ciascuna delle 3 heads.</p>
<p>Questo meccanismo permette al modello di apprendere quanto sia importante la posizione relativa tra patch durante l&rsquo;attenzione, rendendo il bias condiviso per tutte le coppie di patch con la stessa distanza relativa.</p>
<h3 id="applicazione-softmax">Applicazione Softmax</h3>
<p>Dopo aver calcolato i punteggi di attenzione grezzi e aggiunto il relative position bias, otteniamo la matrice $\mathbf{A}$. Ora dobbiamo normalizzare questi punteggi per ottenere delle probabilit√† che indichino quanto ogni patch dovrebbe &ldquo;prestare attenzione&rdquo; alle altre patch nella finestra.</p>
$$
\mathbf{A}_{\text{norm}} = \text{Softmax}(\mathbf{A})
$$
$$
\mathbf{A}_{\text{norm}} \in \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 49}
$$
<p><strong>Cosa fa la Softmax:</strong></p>
<p>La funzione softmax viene applicata <strong>lungo l&rsquo;ultima dimensione</strong> (le 49 colonne, corrispondenti alle patch key). Per ogni patch query (riga), la softmax trasforma i punteggi grezzi in una distribuzione di probabilit√† che somma a 1:</p>
$$
\text{Softmax}(a_i) = \frac{e^{a_i}}{\sum_{j=1}^{49} e^{a_j}}
$$
<p><strong>Significato:</strong>
- Ogni riga di $\mathbf{A}_{\text{norm}}$ ora rappresenta una distribuzione di probabilit√†
- I valori sono compresi tra 0 e 1
- La somma di ogni riga √® esattamente 1
- Valori pi√π alti indicano che la patch query dovrebbe &ldquo;prestare pi√π attenzione&rdquo; a quella specifica patch key</p>
<p><strong>Perch√© √® necessaria:</strong>
La softmax serve a:
1. <strong>Normalizzare</strong> i punteggi in un range interpretabile (0-1)
2. <strong>Amplificare</strong> le differenze tra punteggi alti e bassi (grazie alla funzione esponenziale)
3. <strong>Creare una distribuzione di probabilit√†</strong> che pu√≤ essere usata come sistema di pesi per combinare i values</p>
<h3 id="applicazione-ai-values">Applicazione ai Values</h3>
<p>Ora che abbiamo i pesi di attenzione normalizzati, possiamo usarli per aggregare le informazioni dai values:</p>
$$
\mathbf{O} = \mathbf{A}_{\text{norm}} \mathbf{V}
$$
$$
\mathbf{O} \in \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}
$$
<p><strong>Operazione matriciale:</strong></p>
<p>Stiamo moltiplicando:
- $\mathbf{A}_{\text{norm}} \in \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 49}$ (pesi di attenzione)
- $\mathbf{V} \in \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}$ (values)</p>
<p>Risultato: $\mathbf{O} \in \mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}$</p>
<p><strong>Cosa succede concretamente:</strong></p>
<p>Per ogni head e per ogni patch query (49 patch totali):
1. Prendiamo la riga corrispondente di $\mathbf{A}_{\text{norm}}$ (i suoi pesi di attenzione verso tutte le 49 patch)
2. Usiamo questi pesi per fare una <strong>media ponderata</strong> di tutti i 49 values
3. Il risultato √® un nuovo vettore di dimensione 32 (dimensione per head) che rappresenta l&rsquo;informazione aggregata</p>
<p><strong>Interpretazione:</strong></p>
<p>Ogni patch nel risultato $\mathbf{O}$ √® ora una combinazione pesata di tutte le patch della finestra. I pesi sono determinati dall&rsquo;attenzione:
- Se la patch query $i$ ha alta attenzione verso la patch $j$, il value della patch $j$ contribuir√† maggiormente al risultato finale della patch $i$
- Questo permette a ogni patch di &ldquo;raccogliere&rdquo; informazioni contestuali dalle patch vicine in base alla loro rilevanza.</p>
<h3 id="concatenazione-delle-head">Concatenazione delle Head</h3>
<p>Le 3 head hanno processato l&rsquo;informazione in parallelo, ciascuna con la propria prospettiva (parametri $\mathbf{W}_{qkv}$ diversi). Ora dobbiamo ricombinare i loro output:</p>
$$
\mathbf{O} \rightarrow \mathbb{R}^{(B \times 64) \times 49 \times 96}
$$
<p><strong>Operazione di reshape:</strong></p>
<p>Passiamo da:
- $\mathbb{R}^{(B \times 64) \times 3 \times 49 \times 32}$</p>
<p>A:
- $\mathbb{R}^{(B \times 64) \times 49 \times 96}$</p>
<p><strong>Come funziona:</strong></p>
<p>Per ogni patch (delle 49), concateniamo gli output delle 3 head:
- Head 1: vettore di 32 dimensioni
- Head 2: vettore di 32 dimensioni<br />
- Head 3: vettore di 32 dimensioni
- <strong>Concatenazione:</strong> vettore di $32 + 32 + 32 = 96$ dimensioni</p>
<p><strong>Motivazione del multi-head:</strong></p>
<p>Ogni head ha imparato a catturare aspetti diversi delle relazioni tra patch:
- Una head potrebbe specializzarsi in relazioni spaziali locali
- Un&rsquo;altra potrebbe catturare pattern di texture
- Una terza potrebbe rilevare strutture globali</p>
<p>Concatenando i loro output, otteniamo una rappresentazione ricca che combina tutte queste prospettive.</p>
<h3 id="proiezione-finale">Proiezione Finale</h3>
<p>L&rsquo;output concatenato delle head viene trasformato attraverso un&rsquo;ultima proiezione lineare:</p>
<p>$
\mathbf{O}_{\text{proj}} = \mathbf{O} \mathbf{W}_{\text{proj}}
$</p>
<p>dove $\mathbf{W}_{\text{proj}} \in \mathbb{R}^{96 \times 96}$</p>
<p><strong>Perch√© serve questa proiezione finale?</strong></p>
<p>A questo punto del processo, abbiamo concatenato gli output delle 3 head ottenendo per ogni patch un vettore di 96 dimensioni. Tuttavia, questa concatenazione √® semplicemente un &ldquo;affiancamento&rdquo; dei risultati delle diverse head, senza alcuna interazione tra loro. Ogni blocco di 32 dimensioni proviene da una head specifica e rimane isolato dagli altri.</p>
<p>La proiezione finale √® essenziale per <strong>integrare e miscelare</strong> le informazioni che le diverse head hanno estratto in modo indipendente. Pensiamo a questa operazione come a un &ldquo;strato di fusione&rdquo; che permette al modello di imparare come combinare al meglio le diverse prospettive catturate dalle head.</p>
<p><strong>Il concetto di mixing delle informazioni:</strong></p>
<p>Consideriamo un esempio concreto. Supponiamo che durante il training, il modello abbia scoperto che:
- La <strong>head 1</strong> √® brava a identificare bordi verticali
- La <strong>head 2</strong> √® specializzata nel riconoscere texture
- La <strong>head 3</strong> cattura relazioni spaziali a lungo raggio</p>
<p>Dopo la concatenazione, abbiamo tutte queste informazioni presenti nel vettore da 96 dimensioni, ma sono separate in tre blocchi distinti. La proiezione finale, attraverso la matrice $\mathbf{W}_{\text{proj}}$, permette di creare nuove feature che sono <strong>combinazioni</strong> di queste informazioni. </p>
<p>Per esempio, potrebbe imparare che per riconoscere un particolare oggetto serve combinare informazioni dai bordi verticali (head 1) con informazioni sulla texture (head 2), creando una nuova feature che rappresenta questa combinazione. Questo non sarebbe possibile con la semplice concatenazione.</p>
<p><strong>Apprendimento di rappresentazioni pi√π ricche:</strong></p>
<p>La matrice $\mathbf{W}_{\text{proj}} \in \mathbb{R}^{96 \times 96}$ contiene parametri apprendibili. Durante il training con backpropagation, il modello impara quali combinazioni delle feature estratte dalle head sono pi√π utili per il task finale (classificazione, object detection, etc.). </p>
<p>In pratica, ogni riga di $\mathbf{W}_{\text{proj}}$ definisce come costruire una nuova dimensione dell&rsquo;output combinando linearmente tutte le 96 dimensioni dell&rsquo;input concatenato. Questo significa che ogni dimensione dell&rsquo;output pu√≤ dipendere da qualsiasi dimensione di qualsiasi head, permettendo interazioni complesse.</p>
<p><strong>Preparazione per la residual connection:</strong></p>
<p>Un altro aspetto fondamentale √® che questa proiezione trasforma l&rsquo;output del meccanismo di attenzione in uno spazio di rappresentazione che √® compatibile con l&rsquo;input originale $\mathbf{X}$. Ricordiamo che alla fine di questo blocco dovremo sommare questo output all&rsquo;input originale (residual connection):</p>
$$
\mathbf{X}_{\text{attn}} = \mathbf{X} + \text{DropPath}(\mathbf{O}_{\text{proj}})
$$
<p>Per poter effettuare questa somma in modo significativo, l&rsquo;output deve trovarsi nello stesso spazio di rappresentazione dell&rsquo;input. La proiezione finale garantisce questa compatibilit√†, mappando le feature elaborate dall&rsquo;attenzione in uno spazio dove possono essere integrate con le feature originali.</p>
<p><strong>Controllo della capacit√† del modello:</strong></p>
<p>Inoltre, questa proiezione aggiunge un ulteriore strato di parametri apprendibili al modello. Mentre il numero di parametri nella proiezione QKV √® determinato dalla necessit√† di creare query, key e value, la proiezione finale offre al modello una capacit√† aggiuntiva di apprendere trasformazioni complesse. Questo √® particolarmente importante perch√© il meccanismo di attenzione da solo potrebbe non essere sufficiente a catturare tutte le relazioni necessarie.</p>
<p><strong>Dettagli dimensionali:</strong></p>
<p>Osserviamo pi√π nel dettaglio cosa succede numericamente:</p>
<p>Input: $\mathbf{O} \in \mathbb{R}^{(B \times 64) \times 49 \times 96}$</p>
<p>Moltiplicazione per $\mathbf{W}_{\text{proj}} \in \mathbb{R}^{96 \times 96}$</p>
<p>Output: $\mathbf{O}_{\text{proj}} \in \mathbb{R}^{(B \times 64) \times 49 \times 96}$</p>
<p>Per ogni patch (una delle 49 in ogni finestra), prendiamo il suo vettore di 96 dimensioni e lo moltiplichiamo per la matrice $\mathbf{W}_{\text{proj}}$. Questo produce un nuovo vettore di 96 dimensioni dove ciascuna componente √® una combinazione lineare pesata di tutte le 96 componenti originali.</p>
<p>La dimensionalit√† rimane invariata (96 ‚Üí 96), ma la <strong>qualit√†</strong> e il <strong>contenuto informativo</strong> delle feature sono stati arricchiti attraverso questa trasformazione apprendibile. Non √® un semplice passaggio di dati, ma un vero e proprio step di elaborazione che il modello ottimizza durante il training per massimizzare le performance sul task specifico.</p>
<h3 id="merge-delle-finestre">Merge delle Finestre</h3>
<p>Finora abbiamo lavorato su finestre separate. Ora dobbiamo ricostruire l&rsquo;immagine completa ricomponendo tutte le finestre:</p>
$$
\mathbf{O}_{\text{proj}} \in \mathbb{R}^{(B \times 64) \times 49 \times 96} \rightarrow \mathbb{R}^{B \times 56 \times 56 \times 96} \rightarrow \mathbb{R}^{B \times 3136 \times 96}
$$
<p><strong>Processo di ricostruzione:</strong></p>
<p><strong>Passo 1: Da finestre piatte a finestre spaziali</strong></p>
<p>Da $\mathbb{R}^{(B \times 64) \times 49 \times 96}$ a $\mathbb{R}^{B \times 64 \times 49 \times 96}$</p>
<p>Separiamo la dimensione batch dalle finestre.</p>
<p><strong>Passo 2: Reshape delle patch in ogni finestra</strong></p>
<p>Ogni finestra contiene 49 patch disposte in una griglia $7 \times 7$:</p>
<p>$\mathbb{R}^{B \times 64 \times 49 \times 96} \rightarrow \mathbb{R}^{B \times 64 \times 7 \times 7 \times 96}$</p>
<p>Ora ogni finestra ha una struttura spaziale bidimensionale.</p>
<p><strong>Passo 3: Ricomposizione della griglia di finestre</strong></p>
<p>Le 64 finestre erano disposte in una griglia $8 \times 8$ (ricordiamo che $8 \times 8 = 64$ finestre):</p>
<p>$\mathbb{R}^{B \times 64 \times 7 \times 7 \times 96} \rightarrow \mathbb{R}^{B \times 8 \times 8 \times 7 \times 7 \times 96}$</p>
<p><strong>Passo 4: Riorganizzazione in feature map</strong></p>
<p>Riorganizziamo le dimensioni per ottenere un&rsquo;unica feature map continua:</p>
<p>$\mathbb{R}^{B \times 8 \times 8 \times 7 \times 7 \times 96} \rightarrow \mathbb{R}^{B \times (8 \times 7) \times (8 \times 7) \times 96} = \mathbb{R}^{B \times 56 \times 56 \times 96}$</p>
<p>Ogni finestra $7 \times 7$ viene posizionata nella sua posizione originale nella griglia $8 \times 8$, ricreando la feature map completa $56 \times 56$.</p>
<p><strong>Passo 5: Flatten finale</strong></p>
<p>Per compatibilit√† con le operazioni successive, appiattiamo le dimensioni spaziali:</p>
<p>$\mathbb{R}^{B \times 56 \times 56 \times 96} \rightarrow \mathbb{R}^{B \times 3136 \times 96}$</p>
<p>dove $3136 = 56 \times 56$ √® il numero totale di patch nell&rsquo;immagine.</p>
<p><strong>Significato del merge:</strong></p>
<p>Questo processo √® l&rsquo;operazione inversa del windowing iniziale:
- Abbiamo diviso l&rsquo;immagine in finestre per applicare l&rsquo;attenzione locale in modo efficiente
- Ora ricomponiamo le finestre per recuperare la struttura spaziale completa dell&rsquo;immagine
- Ogni patch mantiene le informazioni aggregate dalla sua finestra locale
- La struttura gerarchica √® preservata per i layer successivi.</p>
<h3 id="residual-connection">Residual Connection</h3>
<p>Infine, abbiamo una connessione residuale:</p>
$$
\mathbf{X}_{\text{attn}} = \mathbf{X} + \text{DropPath}(\mathbf{O}_{\text{proj}})
$$
$$
\mathbf{X}_{\text{attn}} \in \mathbb{R}^{B \times 3136 \times 96}
$$
<p>Da notare che la $\text{DropPath}$ viene applicata solo durante il processo di training del modello. Questo significa che durante l&rsquo;inferenza, avremo semplicemente:</p>
$$
\mathbf{X}_{\text{attn}} = \mathbf{X} + \mathbf{O}_{\text{proj}}.
$$
<h2 id="feed-forward-network-mlp">Feed-Forward Network (MLP)</h2>
<p>Dopo l&rsquo;attenzione, ogni blocco include una rete feed-forward:</p>
<p><strong>Layer Norm:</strong></p>
$$
\mathbf{X}_{\text{norm2}} = \text{LayerNorm}(\mathbf{X}_{\text{attn}})
$$
<p><strong>MLP:</strong></p>
$$
\mathbf{X}_{\text{mlp}} = \text{GELU}(\mathbf{X}_{\text{norm2}} \mathbf{W}_1 + \mathbf{b}_1) \mathbf{W}_2 + \mathbf{b}_2
$$
<p>dove:
- $\mathbf{W}_1 \in \mathbb{R}^{96 \times 384}$ (espansione con ratio 4)
- $\mathbf{b}_1 \in \mathbb{R}^{384}$
- $\mathbf{W}_2 \in \mathbb{R}^{384 \times 96}$ (proiezione al numero di canali originale)</p>
<p><strong>Dimensioni intermediate:</strong></p>
$$
\mathbf{X}_{\text{hidden}} \in \mathbb{R}^{B \times 3136 \times 384}
$$
$$
\mathbf{X}_{\text{mlp}} \in \mathbb{R}^{B \times 3136 \times 96}
$$
<p><strong>Residual Connection:</strong></p>
$$
\mathbf{X}_{\text{out}} = \mathbf{X}_{\text{attn}} + \text{DropPath}(\mathbf{X}_{\text{mlp}})
$$
$$
\mathbf{X}_{\text{out}} \in \mathbb{R}^{B \times 3136 \times 96}
$$
<h2 id="sw-msa-shifted-window-multi-head-self-attention">SW-MSA: Shifted Window Multi-head Self Attention</h2>
<p>Nel Swin Transformer, l‚Äôidea √® di applicare l‚Äôattenzione non su tutta l‚Äôimmagine (troppo costoso), ma su piccole finestre locali ‚Äî ad esempio blocchi di $7√ó7$ pixel.</p>
<p><strong>üëâ Problema:</strong>
Se ogni finestra √® indipendente, i pixel in finestre diverse non comunicano mai.
Quindi, un pixel nell‚Äôangolo di una finestra non ‚Äúvede‚Äù nulla fuori da quella finestra.</p>
<p><strong>üëâ Soluzione:</strong>
Il secondo blocco di ogni stage (swin transformer block) sposta le finestre di met√† finestra ($M/2$) in entrambe le direzioni.
Cos√¨, le nuove finestre contengono parti di quelle vecchie, permettendo scambio di informazioni tra regioni diverse.</p>
<h3 id="input-processing">Input Processing</h3>
<p>Prima di applicare lo shift, l&rsquo;output del primo blocco viene normalizzato:</p>
$$
\mathbf{X}_{\text{norm1}} = \text{LayerNorm}(\mathbf{X}_{\text{out}})
$$
$$
\mathbf{X}_{\text{norm1}} \in \mathbb{R}^{B \times 3136 \times 96}
$$
<p><strong>Reshape spaziale per lo shift:</strong></p>
$$
\mathbf{X}_{\text{norm1}} \rightarrow \mathbb{R}^{B \times 56 \times 56 \times 96}
$$
<h3 id="cyclic-shift">Cyclic Shift</h3>
<p>Prima di tutto calcoliamo il fattore di <strong>shift</strong>. Ricordiamo che $M$ rappresenta la dimensione della finestra e consideriamo la parte intera della divisione per $2$.</p>
<p><strong>Shift Amount:</strong></p>
$$
s = \lfloor \frac{M}{2} \rfloor = \lfloor \frac{7}{2} \rfloor = 3
$$
<p><strong>Operazione di Shift:</strong></p>
<p>L&rsquo;immagine viene shiftata ciclicamente di $s$ pixel sia in altezza che in larghezza:</p>
$$
\mathbf{X}_{\text{shifted}}[i, j] = \mathbf{X}_{\text{norm1}}[(i - s) \mod H, (j - s) \mod W]
$$
<p>In notazione tensoriale usando <code>torch.roll</code>:</p>
$$
\mathbf{X}_{\text{shifted}} = \text{roll}(\mathbf{X}_{\text{norm1}}, \text{shifts}=(-3, -3), \text{dims}=(1, 2))
$$
<p><strong>Dimensioni:</strong></p>
$$
\mathbf{X}_{\text{norm1}} \in \mathbb{R}^{B \times 56 \times 56 \times 96} \rightarrow \mathbf{X}_{\text{shifted}} \in \mathbb{R}^{B \times 56 \times 56 \times 96}
$$
<h3 id="partizionamento-e-mascheramento">Partizionamento e Mascheramento</h3>
<p>Dopo lo shift, l&rsquo;immagine viene partizionata in finestre come in W-MSA. Tuttavia, alcune finestre ora contengono regioni che non erano adiacenti nell&rsquo;immagine originale.</p>
<p><strong>Attention Mask:</strong></p>
<p>Una maschera viene applicata per impedire l&rsquo;attenzione tra regioni non adiacenti:</p>
$$
\mathbf{A}_{\text{masked}} = \mathbf{A} + \mathbf{M}_{\text{mask}}
$$
<p>dove $\mathbf{M}_{\text{mask}}$ contiene $-100$ per coppie di posizioni che non dovrebbero interagire e $0$ altrove.</p>
<p><img src="/images/posts/1*uEzhdlu2GppknurQZ7k82A.png" alt="Immagine di un Transformer" style="display: block; margin-left: auto; margin-right: auto;"></p>
<p><img src="/images/posts/1*ptVDLGO3fLPkjLNCNZHs-Q.png" alt="Immagine di un Transformer" style="display: block; margin-left: auto; margin-right: auto;"></p>
<p><strong>Calcolo dell&rsquo;attenzione con maschera:</strong></p>
$$
\mathbf{A}_{\text{norm}} = \text{Softmax}(\mathbf{A}_{\text{masked}})
$$
<h3 id="reverse-cyclic-shift">Reverse Cyclic Shift</h3>
<p>Dopo l&rsquo;attenzione, lo shift viene invertito:</p>
$$
\mathbf{X}_{\text{unshifted}} = \text{roll}(\mathbf{X}_{\text{out}}, \text{shifts}=(3, 3), \text{dims}=(1, 2))
$$
<p>L&rsquo;output ha la stessa forma dell&rsquo;input:</p>
$$
\mathbf{X}_{\text{unshifted}} \in \mathbb{R}^{B \times 3136 \times 96}
$$
<h2 id="patch-merging">Patch Merging</h2>
<p>Alla fine di ogni stage (eccetto l&rsquo;ultimo), un layer di <strong>Patch Merging</strong> riduce la risoluzione spaziale e aumenta il numero di canali.</p>
<h3 id="downsampling-stage-1-stage-2">Downsampling Stage 1 ‚Üí Stage 2</h3>
<p><strong>Input:</strong></p>
$$
\mathbf{X}_1 \in \mathbb{R}^{B \times 3136 \times 96}
$$
<p><strong>Reshape spaziale:</strong></p>
$$
\mathbf{X}_1 \rightarrow \mathbb{R}^{B \times 56 \times 56 \times 96}
$$
<p><strong>Sampling 2√ó2:</strong></p>
<p>L&rsquo;immagine viene campionata prendendo pixel alternati per creare 4 sottoimmagini:</p>
$$
\mathbf{X}_0 = \mathbf{X}_1[:, 0::2, 0::2, :] \in \mathbb{R}^{B \times 28 \times 28 \times 96}
$$
$$
\mathbf{X}_1 = \mathbf{X}_1[:, 1::2, 0::2, :] \in \mathbb{R}^{B \times 28 \times 28 \times 96}
$$
$$
\mathbf{X}_2 = \mathbf{X}_1[:, 0::2, 1::2, :] \in \mathbb{R}^{B \times 28 \times 28 \times 96}
$$
$$
\mathbf{X}_3 = \mathbf{X}_1[:, 1::2, 1::2, :] \in \mathbb{R}^{B \times 28 \times 28 \times 96}
$$
<p><strong>Concatenazione:</strong></p>
$$
\mathbf{X}_{\text{concat}} = \text{Concat}([\mathbf{X}_0, \mathbf{X}_1, \mathbf{X}_2, \mathbf{X}_3], \text{dim}=-1)
$$
$$
\mathbf{X}_{\text{concat}} \in \mathbb{R}^{B \times 28 \times 28 \times 384}
$$
<p><strong>Flatten:</strong></p>
$$
\mathbf{X}_{\text{concat}} \rightarrow \mathbb{R}^{B \times 784 \times 384}
$$
<p><strong>Layer Norm:</strong></p>
$$
\mathbf{X}_{\text{norm}} = \text{LayerNorm}(\mathbf{X}_{\text{concat}})
$$
<p><strong>Proiezione lineare:</strong></p>
$$
\mathbf{X}_2 = \mathbf{X}_{\text{norm}} \mathbf{W}_{\text{reduction}}
$$
<p>dove $\mathbf{W}_{\text{reduction}} \in \mathbb{R}^{384 \times 192}$</p>
<p><strong>Output:</strong></p>
$$
\mathbf{X}_2 \in \mathbb{R}^{B \times 784 \times 192}
$$
<p>Ora abbiamo:
- Risoluzione: $28 \times 28$ (dimezzata)
- Canali: $192$ (raddoppiati)
- Token: $784 = 28 \times 28$</p>
<h2 id="stage-2-secondo-livello-della-gerarchia">Stage 2: Secondo Livello della Gerarchia</h2>
<h3 id="parametri-stage-2">Parametri Stage 2</h3>
<ul>
<li>Risoluzione: $H_2 \times W_2 = 28 \times 28$</li>
<li>Canali: $C_2 = 192$</li>
<li>Numero di blocchi: $\text{depth}_2 = 2$</li>
<li>Numero di head: $\text{heads}_2 = 6$</li>
<li>Dimensione finestra: $M = 7$</li>
</ul>
<h3 id="calcoli">Calcoli</h3>
<p><strong>Numero di finestre:</strong></p>
$$
\text{num_windows} = \frac{28}{7} \times \frac{28}{7} = 4 \times 4 = 16
$$
<p><strong>Dimensione per head:</strong></p>
$$
d_h = \frac{192}{6} = 32
$$
<p>Il processing √® identico allo Stage 1, ma con dimensioni diverse. Ogni finestra contiene ancora $7 \times 7 = 49$ patch.</p>
<h2 id="stage-3-terzo-livello-della-gerarchia">Stage 3: Terzo Livello della Gerarchia</h2>
<h3 id="patch-merging-stage-2-stage-3">Patch Merging Stage 2 ‚Üí Stage 3</h3>
<p><strong>Input:</strong></p>
$$
\mathbf{X}_2 \in \mathbb{R}^{B \times 784 \times 192}
$$
<p>Dopo patch merging:</p>
$$
\mathbf{X}_3 \in \mathbb{R}^{B \times 196 \times 384}
$$
<p>dove $196 = 14 \times 14$</p>
<h3 id="parametri-stage-3">Parametri Stage 3</h3>
<ul>
<li>Risoluzione: $H_3 \times W_3 = 14 \times 14$</li>
<li>Canali: $C_3 = 384$</li>
<li>Numero di blocchi: $\text{depth}_3 = 6$</li>
<li>Numero di head: $\text{heads}_3 = 12$</li>
<li>Dimensione finestra: $M = 7$</li>
</ul>
<p><strong>Numero di finestre:</strong></p>
$$
\text{num_windows} = \frac{14}{7} \times \frac{14}{7} = 2 \times 2 = 4
$$
<p><strong>Dimensione per head:</strong></p>
$$
d_h = \frac{384}{12} = 32
$$
<h2 id="stage-4-quarto-livello-della-gerarchia">Stage 4: Quarto Livello della Gerarchia</h2>
<h3 id="patch-merging-stage-3-stage-4">Patch Merging Stage 3 ‚Üí Stage 4</h3>
<p><strong>Input:</strong></p>
$$
\mathbf{X}_3 \in \mathbb{R}^{B \times 196 \times 384}
$$
<p>Dopo patch merging:</p>
$$
\mathbf{X}_4 \in \mathbb{R}^{B \times 49 \times 768}
$$
<p>dove $49 = 7 \times 7$</p>
<h3 id="parametri-stage-4">Parametri Stage 4</h3>
<ul>
<li>Risoluzione: $H_4 \times W_4 = 7 \times 7$</li>
<li>Canali: $C_4 = 768$</li>
<li>Numero di blocchi: $\text{depth}_4 = 2$</li>
<li>Numero di head: $\text{heads}_4 = 24$</li>
<li>Dimensione finestra: $M = 7$</li>
</ul>
<p><strong>Numero di finestre:</strong></p>
$$
\text{num_windows} = \frac{7}{7} \times \frac{7}{7} = 1 \times 1 = 1
$$
<p>Con una sola finestra, W-MSA e SW-MSA sono equivalenti (non c&rsquo;√® shifting).</p>
<p><strong>Dimensione per head:</strong></p>
$$
d_h = \frac{768}{24} = 32
$$
<h2 id="classification-head">Classification Head</h2>
<p>Dopo tutti gli stage, l&rsquo;output viene processato per la classificazione.</p>
<h3 id="layer-norm-finale">Layer Norm Finale</h3>
$$
\mathbf{X}_{\text{norm}} = \text{LayerNorm}(\mathbf{X}_4)
$$
$$
\mathbf{X}_{\text{norm}} \in \mathbb{R}^{B \times 49 \times 768}
$$
<h3 id="global-average-pooling">Global Average Pooling</h3>
$$
\mathbf{X}_{\text{pool}} = \text{AvgPool}(\mathbf{X}_{\text{norm}}^T)
$$
<p>Trasponendo: $\mathbf{X}_{\text{norm}}^T \in \mathbb{R}^{B \times 768 \times 49}$</p>
<p>Dopo pooling:</p>
$$
\mathbf{X}_{\text{pool}} \in \mathbb{R}^{B \times 768 \times 1} \rightarrow \mathbb{R}^{B \times 768}
$$
<h3 id="linear-classifier">Linear Classifier</h3>
$$
\mathbf{y} = \mathbf{X}_{\text{pool}} \mathbf{W}_{\text{head}} + \mathbf{b}_{\text{head}}
$$
<p>dove:
- $\mathbf{W}_{\text{head}} \in \mathbb{R}^{768 \times K}$
- $K$ = numero di classi (es. 1000 per ImageNet)</p>
<p><strong>Output finale:</strong></p>
$$
\mathbf{y} \in \mathbb{R}^{B \times K}
$$
<p>Questo vettore contiene i logit per ogni classe.</p>
<h2 id="riepilogo-delle-dimensioni">Riepilogo delle Dimensioni</h2>
<table>
<thead>
<tr>
<th>Stage</th>
<th>Risoluzione</th>
<th>Canali</th>
<th>Token</th>
<th>Blocchi</th>
<th>Head</th>
<th>Head Dim</th>
</tr>
</thead>
<tbody>
<tr>
<td>Input</td>
<td>224√ó224</td>
<td>3</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Embed</td>
<td>56√ó56</td>
<td>96</td>
<td>3136</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>1</td>
<td>56√ó56</td>
<td>96</td>
<td>3136</td>
<td>2</td>
<td>3</td>
<td>32</td>
</tr>
<tr>
<td>2</td>
<td>28√ó28</td>
<td>192</td>
<td>784</td>
<td>2</td>
<td>6</td>
<td>32</td>
</tr>
<tr>
<td>3</td>
<td>14√ó14</td>
<td>384</td>
<td>196</td>
<td>6</td>
<td>12</td>
<td>32</td>
</tr>
<tr>
<td>4</td>
<td>7√ó7</td>
<td>768</td>
<td>49</td>
<td>2</td>
<td>24</td>
<td>32</td>
</tr>
<tr>
<td>Output</td>
<td>-</td>
<td>768</td>
<td>1</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
<tr>
<td>Logits</td>
<td>-</td>
<td>K</td>
<td>-</td>
<td>-</td>
<td>-</td>
<td>-</td>
</tr>
</tbody>
</table>
<h2 id="complessita-computazionale">Complessit√† Computazionale</h2>
<h3 id="self-attention-standard-global">Self-Attention Standard (Global)</h3>
<p>Per $N$ token con dimensione $C$:</p>
$$
\text{Complexity}_{\text{global}} = O(N^2 \cdot C)
$$
<p>Per Stage 1 con $N = 3136$:</p>
$$
\text{Complexity}_{\text{global}} = O(3136^2 \cdot 96) \approx O(9.4 \times 10^8)
$$
<h3 id="window-based-self-attention">Window-based Self-Attention</h3>
<p>Con finestre di dimensione $M \times M$:</p>
$$
\text{Complexity}_{\text{window}} = O\left(\frac{N}{M^2} \cdot (M^2)^2 \cdot C\right) = O(N \cdot M^2 \cdot C)
$$
<p>Per Stage 1 con $M = 7$:</p>
$$
\text{Complexity}_{\text{window}} = O(3136 \cdot 49 \cdot 96) \approx O(1.5 \times 10^7)
$$
<p><strong>Riduzione della complessit√†:</strong></p>
$$
\text{Speedup} = \frac{N^2 \cdot C}{N \cdot M^2 \cdot C} = \frac{N}{M^2} = \frac{3136}{49} = 64\times
$$
<p>La window-based attention √® <strong>64 volte pi√π efficiente</strong> per lo Stage 1!</p>
<h2 id="swin-transformer-v2-miglioramenti-e-differenze">Swin Transformer V2: Miglioramenti e Differenze</h2>
<p>Swin Transformer V2 introduce diverse modifiche per migliorare stabilit√†, scalabilit√† e prestazioni.</p>
<h3 id="1-scaled-cosine-attention">1. Scaled Cosine Attention</h3>
<p><strong>Swin V1</strong> usa dot-product attention standard:</p>
$$
\mathbf{A} = \frac{\mathbf{Q} \mathbf{K}^T}{\sqrt{d_h}}
$$
<p><strong>Swin V2</strong> usa cosine attention con temperatura apprendibile:</p>
$$
\mathbf{A} = \tau \cdot \frac{\mathbf{Q}_{\text{norm}} \mathbf{K}_{\text{norm}}^T}{\|\mathbf{Q}_{\text{norm}}\| \|\mathbf{K}_{\text{norm}}\|}
$$
<p>dove:
- Normalizzazione: $\mathbf{Q}_{\text{norm}} = \frac{\mathbf{Q}}{\|\mathbf{Q}\|_2}$, $\mathbf{K}_{\text{norm}} = \frac{\mathbf{K}}{\|\mathbf{K}\|_2}$
- $\tau = \log(\text{scale})$ √® un parametro apprendibile per head
- $\text{scale}$ √® limitato: $\text{scale} \leq \frac{1}{0.01} = 100$</p>
<p><strong>Vantaggi:</strong>
- Maggiore stabilit√† durante il training
- Gradiente pi√π uniforme
- Migliore convergenza per modelli grandi</p>
<h3 id="2-continuous-relative-position-bias">2. Continuous Relative Position Bias</h3>
<p><strong>Swin V1</strong> usa una tabella discreta:</p>
$$
\mathbf{B} \in \mathbb{R}^{(2M-1) \times (2M-1) \times h}
$$
<p><strong>Swin V2</strong> usa una <strong>MLP continua</strong> per generare i bias:</p>
$$
\mathbf{B} = \text{MLP}(\Delta \mathbf{p})
$$
<p>dove $\Delta \mathbf{p}$ sono le coordinate relative normalizzate.</p>
<p><strong>Architettura MLP:</strong></p>
$$
\mathbf{B} = \mathbf{W}_2 \cdot \text{ReLU}(\mathbf{W}_1 \cdot \Delta \mathbf{p} + \mathbf{b}_1)
$$
<p>con:
- $\mathbf{W}_1 \in \mathbb{R}^{512 \times 2}$ (proietta coordinate 2D a 512 dim)
- $\mathbf{W}_2 \in \mathbb{R}^{h \times 512}$ (proietta a numero di head)</p>
<p><strong>Normalizzazione delle coordinate:</strong></p>
$$
\Delta p_x = \frac{i - j}{M - 1}, \quad \Delta p_y = \frac{k - l}{M - 1}
$$
<p>Trasformazione log:</p>
$$
\Delta \hat{p} = \text{sign}(\Delta p) \cdot \log_2(|\Delta p| + 1) / \log_2(8)
$$
<p>Questa trasformazione mappa le coordinate in $[-1, 1]$ con maggiore risoluzione vicino allo zero.</p>
<p><strong>Post-processing del bias:</strong></p>
<p>$
\mathbf{B}_{\text{final}} = 16 \cdot \sigma(\mathbf{B})
$</p>
<p>dove $\sigma$ √® la funzione sigmoid. Questo scala i bias in un range controllato $[0, 16]$.</p>
<p><strong>Vantaggi:</strong>
- Transferibilit√† tra diverse risoluzioni di finestra
- Interpolazione continua delle posizioni
- Migliore generalizzazione</p>
<h3 id="3-log-spaced-continuous-position-bias">3. Log-spaced Continuous Position Bias</h3>
<p>Le coordinate relative vengono trasformate in scala logaritmica prima di essere processate dalla MLP:</p>
<p>$
\hat{x} = \text{sign}(x) \cdot \log(1 + |x|) / \log(8)
$</p>
<p>Questo permette una rappresentazione pi√π uniforme di distanze diverse.</p>
<h3 id="4-rimozione-della-normalizzazione-pre-attenzione">4. Rimozione della Normalizzazione Pre-Attenzione</h3>
<p><strong>Swin V1:</strong></p>
<p>$
\mathbf{X}_{\text{attn}} = \mathbf{X} + \text{Attn}(\text{LN}(\mathbf{X}))
$</p>
<p>$
\mathbf{X}_{\text{out}} = \mathbf{X}_{\text{attn}} + \text{MLP}(\text{LN}(\mathbf{X}_{\text{attn}}))
$</p>
<p><strong>Swin V2:</strong> usa post-normalization per migliorare la stabilit√†</p>
<p>$
\mathbf{X}_{\text{attn}} = \text{LN}(\mathbf{X} + \text{Attn}(\mathbf{X}))
$</p>
<p>$
\mathbf{X}_{\text{out}} = \text{LN}(\mathbf{X}_{\text{attn}} + \text{MLP}(\mathbf{X}_{\text{attn}}))
$</p>
<p>Tuttavia, guardando il codice fornito, Swin V2 mantiene ancora la pre-normalization ma con alcune modifiche ai parametri di inizializzazione.</p>
<h3 id="5-scaled-cosine-attention-dettagli-implementativi">5. Scaled Cosine Attention - Dettagli Implementativi</h3>
<p><strong>Query e Key Bias:</strong></p>
<p>In Swin V2, il QKV bias viene modificato:</p>
<p>$
\text{qkv_bias} = [\mathbf{q}_{\text{bias}}, \mathbf{0}, \mathbf{v}_{\text{bias}}]
$</p>
<p>Il bias per le key √® zero, mentre query e value hanno bias apprendibili.</p>
<p><strong>Calcolo attention:</strong></p>
<p>$
\mathbf{A} = \text{normalize}(\mathbf{Q}) \cdot \text{normalize}(\mathbf{K})^T
$</p>
<p>dove la normalizzazione √®:</p>
<p>$
\text{normalize}(\mathbf{X}) = \frac{\mathbf{X}}{\|\mathbf{X}\|_2 + \epsilon}
$</p>
<p><strong>Scaling con temperatura:</strong></p>
<p>$
\tau = \exp(\log(\text{scale}))
$</p>
<p>con $\text{scale}$ limitato a $\max = \log(1/0.01) = \log(100) \approx 4.6$</p>
<p>$
\mathbf{A}_{\text{scaled}} = \tau \cdot \mathbf{A}
$</p>
<h3 id="6-modifiche-al-patch-merging">6. Modifiche al Patch Merging</h3>
<p><strong>Swin V1:</strong></p>
<p>$
\text{Norm} \rightarrow \text{Linear}
$</p>
<p><strong>Swin V2:</strong></p>
<p>$
\text{Linear} \rightarrow \text{Norm}
$</p>
<p>L&rsquo;ordine √® invertito:</p>
<p>$
\mathbf{X}_{\text{reduced}} = \mathbf{W}_{\text{reduction}} \cdot \mathbf{X}_{\text{concat}}
$</p>
<p>$
\mathbf{X}_{\text{out}} = \text{LayerNorm}(\mathbf{X}_{\text{reduced}})
$</p>
<h2 id="fused-window-process-ottimizzazione">Fused Window Process: Ottimizzazione</h2>
<p>Il codice fornito mostra una implementazione ottimizzata delle operazioni di window partition e cyclic shift.</p>
<h3 id="standard-implementation">Standard Implementation</h3>
<p><strong>Roll + Window Partition (Python):</strong></p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">shifted_x</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">roll</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">shifts</span><span class="o">=</span><span class="p">(</span><span class="o">-</span><span class="n">shift_size</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_size</span><span class="p">),</span> <span class="n">dims</span><span class="o">=</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">))</span>
<span class="n">x_windows</span> <span class="o">=</span> <span class="n">window_partition</span><span class="p">(</span><span class="n">shifted_x</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p>Questo richiede due operazioni separate:
1. Cyclic shift (roll)
2. Window partition (reshape + permute)</p>
<h3 id="fused-implementation">Fused Implementation</h3>
<p>Il kernel fuso combina entrambe le operazioni in un&rsquo;unica operazione CUDA ottimizzata:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x_windows</span> <span class="o">=</span> <span class="n">WindowProcess</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="o">-</span><span class="n">shift_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p><strong>Forward Pass:</strong></p>
<p>$
\mathbf{X} \in \mathbb{R}^{B \times H \times W \times C} \xrightarrow{\text{fused}} \mathbf{X}_{\text{windows}} \in \mathbb{R}^{(B \cdot n_w) \times M \times M \times C}
$</p>
<p>in un&rsquo;unica operazione kernel.</p>
<p><strong>Vantaggi:</strong>
- Riduzione accessi alla memoria
- Eliminazione di tensori intermedi
- Migliore utilizzo della cache
- Speedup 2-3√ó rispetto all&rsquo;implementazione standard</p>
<h3 id="reverse-process">Reverse Process</h3>
<p>Analogamente per l&rsquo;operazione inversa:</p>
<details class="code-container">
<summary>Code</summary>
<div class="code-wrapper">
<button class="copy-button" onclick="
                const code = this.parentElement.querySelector('pre');
                if (code) {
                    navigator.clipboard.writeText(code.innerText);
                    this.textContent = 'Copied!';
                    setTimeout(() => this.textContent = 'Copy', 2000);
                }
            ">Copy</button>
<div class="codehilite"><pre><span></span><code><span class="n">x</span> <span class="o">=</span> <span class="n">WindowProcessReverse</span><span class="o">.</span><span class="n">apply</span><span class="p">(</span><span class="n">attn_windows</span><span class="p">,</span> <span class="n">B</span><span class="p">,</span> <span class="n">H</span><span class="p">,</span> <span class="n">W</span><span class="p">,</span> <span class="n">C</span><span class="p">,</span> <span class="n">shift_size</span><span class="p">,</span> <span class="n">window_size</span><span class="p">)</span>
</code></pre></div>
</div>
</details>

<p>Combina:
1. Window merge
2. Reverse cyclic shift</p>
<p>$
\mathbf{X}_{\text{windows}} \in \mathbb{R}^{(B \cdot n_w) \times M \times M \times C} \xrightarrow{\text{fused}} \mathbf{X} \in \mathbb{R}^{B \times H \times W \times C}
$</p>
<h2 id="training-details">Training Details</h2>
<h3 id="loss-function">Loss Function</h3>
<p>Per classificazione con $K$ classi:</p>
<p>$
\mathcal{L} = -\frac{1}{B} \sum_{i=1}^{B} \sum_{k=1}^{K} y_{ik} \log(\text{softmax}(\hat{y}_{ik}))
$</p>
<p>Con label smoothing ($\alpha = 0.1$):</p>
<p>$
y'_{ik} = (1 - \alpha) \cdot y_{ik} + \frac{\alpha}{K}
$</p>
<p>$
\mathcal{L}_{\text{smooth}} = -\frac{1}{B} \sum_{i=1}^{B} \sum_{k=1}^{K} y'_{ik} \log(\text{softmax}(\hat{y}_{ik}))
$</p>
<h3 id="data-augmentation">Data Augmentation</h3>
<p><strong>Mixup:</strong> combina due immagini</p>
<p>$
\tilde{\mathbf{x}} = \lambda \mathbf{x}_i + (1 - \lambda) \mathbf{x}_j
$</p>
<p>$
\tilde{\mathbf{y}} = \lambda \mathbf{y}_i + (1 - \lambda) \mathbf{y}_j
$</p>
<p>dove $\lambda \sim \text{Beta}(\alpha_{\text{mixup}}, \alpha_{\text{mixup}})$ con $\alpha_{\text{mixup}} = 0.8$</p>
<p><strong>CutMix:</strong> sostituisce una regione dell&rsquo;immagine</p>
<p>$
\mathbf{M} \in \{0, 1\}^{H \times W}
$</p>
<p>$
\tilde{\mathbf{x}} = \mathbf{M} \odot \mathbf{x}_i + (1 - \mathbf{M}) \odot \mathbf{x}_j
$</p>
<h3 id="optimizer">Optimizer</h3>
<p><strong>AdamW</strong> con:
- Learning rate base: $\eta_{\text{base}} = 5 \times 10^{-4}$
- Weight decay: $\lambda = 0.05$
- $\beta_1 = 0.9$, $\beta_2 = 0.999$
- $\epsilon = 10^{-8}$</p>
<p><strong>Linear scaling rule:</strong></p>
<p>$
\eta = \eta_{\text{base}} \times \frac{B \times N_{\text{gpu}}}{512}
$</p>
<h3 id="learning-rate-schedule">Learning Rate Schedule</h3>
<p><strong>Cosine decay</strong> con warmup:</p>
<p><strong>Warmup phase</strong> (primi 20 epochs):</p>
<p>$
\eta(t) = \eta_{\text{warmup}} + \frac{\eta - \eta_{\text{warmup}}}{T_{\text{warmup}}} \cdot t
$</p>
<p>dove $\eta_{\text{warmup}} = 5 \times 10^{-7}$</p>
<p><strong>Cosine decay phase:</strong></p>
<p>$
\eta(t) = \eta_{\text{min}} + \frac{\eta - \eta_{\text{min}}}{2} \left(1 + \cos\left(\frac{t - T_{\text{warmup}}}{T_{\text{max}} - T_{\text{warmup}}} \pi\right)\right)
$</p>
<p>dove $\eta_{\text{min}} = 5 \times 10^{-6}$, $T_{\text{max}} = 300$ epochs</p>
<h3 id="stochastic-depth">Stochastic Depth</h3>
<p><strong>Drop path</strong> con probabilit√† crescente per layer profondi:</p>
<p>$
p_l = p_{\text{max}} \cdot \frac{l}{L}
$</p>
<p>dove:
- $p_{\text{max}} = 0.1$ (drop path rate massimo)
- $l$ = indice del layer
- $L$ = numero totale di layer</p>
<p><strong>Applicazione:</strong></p>
<p>$
\mathbf{X}_{\text{out}} = \mathbf{X} + \text{Bernoulli}(1 - p_l) \cdot \frac{\text{Layer}(\mathbf{X})}{1 - p_l}
$</p>
<h2 id="varianti-di-swin-transformer">Varianti di Swin Transformer</h2>
<h3 id="swin-t-tiny">Swin-T (Tiny)</h3>
<table>
<thead>
<tr>
<th>Parametro</th>
<th>Valore</th>
</tr>
</thead>
<tbody>
<tr>
<td>Embed dim</td>
<td>96</td>
</tr>
<tr>
<td>Depths</td>
<td>[2, 2, 6, 2]</td>
</tr>
<tr>
<td>Num heads</td>
<td>[3, 6, 12, 24]</td>
</tr>
<tr>
<td>Window size</td>
<td>7</td>
</tr>
<tr>
<td>Parametri</td>
<td>~29M</td>
</tr>
</tbody>
</table>
<h3 id="swin-s-small">Swin-S (Small)</h3>
<table>
<thead>
<tr>
<th>Parametro</th>
<th>Valore</th>
</tr>
</thead>
<tbody>
<tr>
<td>Embed dim</td>
<td>96</td>
</tr>
<tr>
<td>Depths</td>
<td>[2, 2, 18, 2]</td>
</tr>
<tr>
<td>Num heads</td>
<td>[3, 6, 12, 24]</td>
</tr>
<tr>
<td>Window size</td>
<td>7</td>
</tr>
<tr>
<td>Parametri</td>
<td>~50M</td>
</tr>
</tbody>
</table>
<h3 id="swin-b-base">Swin-B (Base)</h3>
<table>
<thead>
<tr>
<th>Parametro</th>
<th>Valore</th>
</tr>
</thead>
<tbody>
<tr>
<td>Embed dim</td>
<td>128</td>
</tr>
<tr>
<td>Depths</td>
<td>[2, 2, 18, 2]</td>
</tr>
<tr>
<td>Num heads</td>
<td>[4, 8, 16, 32]</td>
</tr>
<tr>
<td>Window size</td>
<td>7</td>
</tr>
<tr>
<td>Parametri</td>
<td>~88M</td>
</tr>
</tbody>
</table>
<h3 id="swin-l-large">Swin-L (Large)</h3>
<table>
<thead>
<tr>
<th>Parametro</th>
<th>Valore</th>
</tr>
</thead>
<tbody>
<tr>
<td>Embed dim</td>
<td>192</td>
</tr>
<tr>
<td>Depths</td>
<td>[2, 2, 18, 2]</td>
</tr>
<tr>
<td>Num heads</td>
<td>[6, 12, 24, 48]</td>
</tr>
<tr>
<td>Window size</td>
<td>7</td>
</tr>
<tr>
<td>Parametri</td>
<td>~197M</td>
</tr>
</tbody>
</table>
<h2 id="applicazioni">Applicazioni</h2>
<h3 id="image-classification">Image Classification</h3>
<p>Output diretto dal classification head:</p>
<p>$
\mathbf{y} \in \mathbb{R}^{B \times K}
$</p>
<h3 id="object-detection">Object Detection</h3>
<p>Swin Transformer pu√≤ essere usato come backbone in framework come:
- <strong>Mask R-CNN</strong>
- <strong>Cascade Mask R-CNN</strong>
- <strong>HTC</strong> (Hybrid Task Cascade)</p>
<p>Le feature maps dei diversi stage vengono usate:</p>
<p>$
\{\mathbf{F}_1, \mathbf{F}_2, \mathbf{F}_3, \mathbf{F}_4\}
$</p>
<p>con risoluzioni:</p>
<p>$
\left\{\frac{H}{4} \times \frac{W}{4}, \frac{H}{8} \times \frac{W}{8}, \frac{H}{16} \times \frac{W}{16}, \frac{H}{32} \times \frac{W}{32}\right\}
$</p>
<h3 id="semantic-segmentation">Semantic Segmentation</h3>
<p>Usato in <strong>UperNet</strong> per segmentazione:</p>
<p>Le feature gerarchiche vengono combinate con:
- <strong>FPN</strong> (Feature Pyramid Network)
- <strong>PPM</strong> (Pyramid Pooling Module)</p>
<p>Output finale:</p>
<p>$
\mathbf{S} \in \mathbb{R}^{B \times K_{\text{seg}} \times H \times W}
$</p>
<p>dove $K_{\text{seg}}$ √® il numero di classi di segmentazione.</p>
<h2 id="vantaggi-di-swin-transformer">Vantaggi di Swin Transformer</h2>
<h3 id="1-efficienza-computazionale">1. Efficienza Computazionale</h3>
<p>La window-based attention riduce la complessit√† da quadratica a lineare rispetto alla risoluzione:</p>
<p>$
O(N^2) \rightarrow O(N)
$</p>
<h3 id="2-hierarchical-representation">2. Hierarchical Representation</h3>
<p>Come le CNN, Swin costruisce rappresentazioni gerarchiche che sono utili per task dense come detection e segmentation.</p>
<h3 id="3-flessibilita">3. Flessibilit√†</h3>
<p>Pu√≤ processare immagini di diverse dimensioni (con alcuni aggiustamenti) grazie alla struttura a finestre.</p>
<h3 id="4-state-of-the-art-performance">4. State-of-the-Art Performance</h3>
<p>Su ImageNet-1K:
- Swin-B: 83.5% top-1 accuracy
- Swin-L: 84.5% top-1 accuracy</p>
<p>Su COCO object detection:
- Swin-L: 58.7 box AP (Cascade Mask R-CNN)</p>
<h2 id="limitazioni-e-considerazioni">Limitazioni e Considerazioni</h2>
<h3 id="1-window-size-trade-off">1. Window Size Trade-off</h3>
<ul>
<li>Window piccole: meno recettivit√† globale, pi√π efficienza</li>
<li>Window grandi: maggiore recettivit√†, meno efficienza</li>
</ul>
<p>Il valore $M = 7$ √® un compromesso empirico.</p>
<h3 id="2-shifted-windows-overhead">2. Shifted Windows Overhead</h3>
<p>Lo shift ciclico e il mascheramento aggiungono overhead computazionale, anche se recuperato dall&rsquo;efficienza locale.</p>
<h3 id="3-memory-requirements">3. Memory Requirements</h3>
<p>Nonostante l&rsquo;efficienza, i modelli grandi (Swin-L) richiedono ancora molta memoria:</p>
<p>$
\text{Memory} \propto B \cdot H \cdot W \cdot C \cdot L
$</p>
<h3 id="4-fixed-window-size">4. Fixed Window Size</h3>
<p>Il window size fisso pu√≤ non essere ottimale per tutte le scale di oggetti nell&rsquo;immagine.</p>
<h2 id="conclusioni">Conclusioni</h2>
<p>Swin Transformer rappresenta un breakthrough nell&rsquo;applicazione dei Transformer alla computer vision, combinando:</p>
<ol>
<li><strong>Efficienza</strong> delle window-based attention</li>
<li><strong>Flessibilit√†</strong> delle shifted windows per catturare dipendenze cross-window</li>
<li><strong>Struttura gerarchica</strong> simile alle CNN per task multi-scala</li>
<li><strong>Performance state-of-the-art</strong> su molteplici benchmark</li>
</ol>
<p>Le dimensioni dei tensori attraverso la rete mostrano una progressione logica:</p>
<p>$
\mathbb{R}^{B \times 3 \times 224 \times 224} \rightarrow \mathbb{R}^{B \times 3136 \times 96} \rightarrow \mathbb{R}^{B \times 784 \times 192} \rightarrow \mathbb{R}^{B \times 196 \times 384} \rightarrow \mathbb{R}^{B \times 49 \times 768} \rightarrow \mathbb{R}^{B \times K}
$</p>
<p>Ogni transizione dimezza la risoluzione spaziale e raddoppia i canali, creando rappresentazioni sempre pi√π astratte e semantiche dell&rsquo;input, mentre la window-based attention mantiene la complessit√† computazionale gestibile anche ad alte risoluzioni.</p>
            </div>
            
            <footer style="margin-top: 40px; padding-top: 20px; border-top: 1px solid #eee;">
                <p><strong>Keywords:</strong> deep learning, neural networks, CNN, RNN, transformers, model, data, network</p>
                <p><small>This is the SEO-optimized version. <a href="http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer">Click here for the interactive experience</a>.</small></p>
            </footer>
        </article>
    </div>
    
    <!-- Vercel Analytics (opzionale) -->
    <script>
      // Track SEO page views
      if (window.gtag) {
        gtag('config', 'GA_TRACKING_ID', {
          page_title: 'Swin Transformer: Shifted Window Transformers',
          page_location: 'http://localhost:3000/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer'
        });
      }
    </script>
</body>
</html>