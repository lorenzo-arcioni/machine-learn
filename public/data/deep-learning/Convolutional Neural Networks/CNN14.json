{
  "title": "CNN14 (PANN): Architettura per Audio Classification",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n/* Blocchi di codice sempre visibili */\n.code-visible {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    background: #f9fafb;\n    margin: 16px 0;\n}\n.code-visible .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<h2 id=\"introduzione\">Introduzione</h2>\n<p>La CNN14 è un&rsquo;architettura di rete neurale convoluzionale facente parte della famiglia PANN (Pretrained Audio Neural Networks), progettata specificamente per l&rsquo;analisi e la classificazione di segnali audio. Il nome &ldquo;CNN14&rdquo; deriva dal fatto che contiene 14 layer pesati (6 ConvBlock × 2 conv ciascuno + 2 layer fully connected).</p>\n<p>L&rsquo;architettura trasforma un segnale audio grezzo in un embedding denso ad alta dimensionalità, catturando caratteristiche acustiche complesse attraverso una gerarchia di rappresentazioni sempre più astratte.</p>\n<h2 id=\"panoramica-del-pipeline\">Panoramica del Pipeline</h2>\n<p>Il processo di elaborazione si articola in diverse fasi:</p>\n<ol>\n<li><strong>Estrazione dello Spettrogramma</strong> - conversione da dominio temporale a tempo-frequenza</li>\n<li><strong>Estrazione Log-Mel</strong> - rappresentazione percettivamente motivata</li>\n<li><strong>Normalizzazione Batch</strong> - standardizzazione delle feature</li>\n<li><strong>Data Augmentation</strong> (solo training) - SpecAugmentation e Mixup</li>\n<li><strong>Elaborazione Convoluzionale</strong> - 6 blocchi convoluzionali gerarchici</li>\n<li><strong>Pooling Globale</strong> - aggregazione temporale</li>\n<li><strong>Classificazione</strong> - layer fully connected</li>\n</ol>\n<h2 id=\"1-input-forma-donda-audio\">1. Input: Forma d&rsquo;Onda Audio</h2>\n<p>L&rsquo;input alla rete è un segnale audio campionato digitalmente:</p>\n$$\n\\mathbf{s} \\in \\mathbb{R}^{B \\times N_{samples}}\n$$\n<p>dove:\n- $B$ = dimensione del batch\n- $N_{samples}$ = numero di campioni audio (tipicamente $480000$ per 10 secondi a 48 kHz)</p>\n<p><strong>Intuizione</strong>: Il segnale audio è una sequenza di valori che rappresentano l&rsquo;ampiezza della pressione sonora nel tempo. È la rappresentazione più grezza del suono.</p>\n<h2 id=\"2-estrazione-dello-spettrogramma\">2. Estrazione dello Spettrogramma</h2>\n<h3 id=\"21-short-time-fourier-transform-stft\">2.1 Short-Time Fourier Transform (STFT)</h3>\n<p>La STFT applica la trasformata di Fourier a finestre temporali sovrapposte del segnale:</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spectrogram_extractor</span> <span class=\"o\">=</span> <span class=\"n\">Spectrogram</span><span class=\"p\">(</span>\n    <span class=\"n\">n_fft</span><span class=\"o\">=</span><span class=\"n\">window_size</span><span class=\"p\">,</span>      <span class=\"c1\"># dimensione della FFT (es. 2048)</span>\n    <span class=\"n\">hop_length</span><span class=\"o\">=</span><span class=\"n\">hop_size</span><span class=\"p\">,</span>    <span class=\"c1\"># spostamento tra finestre (es. 320)</span>\n    <span class=\"n\">win_length</span><span class=\"o\">=</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"c1\"># lunghezza della finestra</span>\n    <span class=\"n\">window</span><span class=\"o\">=</span><span class=\"s1\">&#39;hann&#39;</span><span class=\"p\">,</span>          <span class=\"c1\"># finestra di Hann</span>\n    <span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>            <span class=\"c1\"># padding centrato</span>\n    <span class=\"n\">pad_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;reflect&#39;</span><span class=\"p\">,</span>     <span class=\"c1\"># riflessione ai bordi</span>\n    <span class=\"n\">freeze_parameters</span><span class=\"o\">=</span><span class=\"kc\">True</span>  <span class=\"c1\"># parametri non addestrabili</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Matematicamente</strong>:</p>\n$$\nX[k, n] = \\sum_{m=0}^{N-1} x[m + nH] \\cdot w[m] \\cdot e^{-j2\\pi km/N}\n$$\n<p>dove:\n- $k$ = bin di frequenza ($0 \\leq k < N/2 + 1$)\n- $n$ = frame temporale\n- $H$ = hop size\n- $w[m]$ = finestra di Hann\n- $N$ = dimensione della FFT</p>\n<p><strong>Output dello spettrogramma di potenza</strong>:</p>\n$$\n\\mathbf{S} = |X|^2 \\in \\mathbb{R}^{B \\times 1 \\times T_{frames} \\times F_{bins}}\n$$\n<p>Con $N_{fft} = 2048$ e hop size $= 320$:\n- $T_{frames} = \\lfloor 480000 / 320 \\rfloor + 1 = 1501$\n- $F_{bins} = 2048/2 + 1 = 1025$</p>\n<p><strong>Intuizione</strong>: Lo spettrogramma decompone il segnale audio nelle sue componenti di frequenza nel tempo. Ogni colonna verticale rappresenta lo &ldquo;spettro di frequenze&rdquo; presente in una piccola finestra temporale. È come guardare quali note musicali vengono suonate in ogni istante.</p>\n<h3 id=\"22-finestra-di-hann\">2.2 Finestra di Hann</h3>\n<p>La finestra di Hann riduce le discontinuità ai bordi di ogni frame:</p>\n$$\nw[m] = 0.5 \\left(1 - \\cos\\left(\\frac{2\\pi m}{N-1}\\right)\\right)\n$$\n<p><strong>Intuizione</strong>: Senza finestra, il taglio brusco del segnale crea &ldquo;artefatti spettrali&rdquo; (frequenze spurie). La finestra di Hann &ldquo;sfuma&rdquo; dolcemente il segnale ai bordi, riducendo questi artefatti.</p>\n<h2 id=\"3-log-mel-spectrogram\">3. Log-Mel Spectrogram</h2>\n<h3 id=\"31-mel-filter-bank\">3.1 Mel Filter Bank</h3>\n<p>Il banco di filtri Mel converte le frequenze lineari in scala Mel, che approssima meglio la percezione umana delle frequenze:</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">logmel_extractor</span> <span class=\"o\">=</span> <span class=\"n\">LogmelFilterBank</span><span class=\"p\">(</span>\n    <span class=\"n\">sr</span><span class=\"o\">=</span><span class=\"n\">sample_rate</span><span class=\"p\">,</span>\n    <span class=\"n\">n_fft</span><span class=\"o\">=</span><span class=\"n\">window_size</span><span class=\"p\">,</span>\n    <span class=\"n\">n_mels</span><span class=\"o\">=</span><span class=\"n\">mel_bins</span><span class=\"p\">,</span>     <span class=\"c1\"># numero di bande Mel (es. 64)</span>\n    <span class=\"n\">fmin</span><span class=\"o\">=</span><span class=\"n\">fmin</span><span class=\"p\">,</span>           <span class=\"c1\"># frequenza minima (es. 50 Hz)</span>\n    <span class=\"n\">fmax</span><span class=\"o\">=</span><span class=\"n\">fmax</span><span class=\"p\">,</span>           <span class=\"c1\"># frequenza massima (es. 14000 Hz)</span>\n    <span class=\"n\">ref</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span>\n    <span class=\"n\">amin</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span><span class=\"p\">,</span>\n    <span class=\"n\">top_db</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n    <span class=\"n\">freeze_parameters</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Scala Mel</strong>: Conversione da Hz a Mel:</p>\n$$\n\\text{Mel}(f) = 2595 \\log_{10}\\left(1 + \\frac{f}{700}\\right)\n$$\n<p><strong>Applicazione dei filtri triangolari</strong>:</p>\n$$\n\\mathbf{M}_{mel}[b, 1, t, m] = \\sum_{k=0}^{F_{bins}-1} \\mathbf{S}[b, 1, t, k] \\cdot H_m[k]\n$$\n<p>dove $H_m[k]$ sono i filtri triangolari nella scala Mel.</p>\n<p><strong>Conversione in log-scale</strong>:</p>\n$$\n\\mathbf{M}_{log}[b, 1, t, m] = 10 \\log_{10}(\\max(\\mathbf{M}_{mel}[b, 1, t, m], \\text{amin}))\n$$\n<p>con $\\text{amin} = 10^{-10}$ per evitare $\\log(0)$.</p>\n<p><strong>Output</strong>:</p>\n$$\n\\mathbf{M}_{log} \\in \\mathbb{R}^{B \\times 1 \\times 1501 \\times 64}\n$$\n<p><strong>Intuizione</strong>: \n- L&rsquo;orecchio umano non percepisce le frequenze linearmente: la differenza tra 100 e 200 Hz è molto più evidente della differenza tra 10100 e 10200 Hz\n- La scala Mel riflette questa non-linearità percettiva\n- I filtri triangolari aggregano bin di frequenza vicini, riducendo la dimensionalità e catturando &ldquo;bande di frequenza&rdquo; percettivamente rilevanti\n- La scala logaritmica comprime la gamma dinamica, rendendo sia suoni deboli che forti discriminabili dalla rete</p>\n<h2 id=\"4-normalizzazione-batch-bn0\">4. Normalizzazione Batch (bn0)</h2>\n<h3 id=\"41-trasposizione-per-batch-norm\">4.1 Trasposizione per Batch Norm</h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 1, 1501, 64) → (B, 64, 1501, 1)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">bn0</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 64, 1501, 1) → (B, 1, 1501, 64)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Perché questa trasposizione?</strong></p>\n<p><code>BatchNorm2d(64)</code> normalizza lungo la dimensione dei canali (dim=1) e si aspetta \n<strong>64 canali in input</strong>. Il log-Mel spectrogram ha forma (B, 1, 1501, 64), con \n1 canale e 64 bande Mel sull&rsquo;ultima dimensione.</p>\n<p>La trasposizione <strong>temporanea</strong> sposta le 64 bande Mel nella posizione dei canali, \npermettendo a BatchNorm2d di normalizzare ogni banda Mel indipendentemente. \nDopo la normalizzazione, si ritrasporta alla forma originale.</p>\n<p><strong>Nota tecnica</strong>: <code>bn0</code> è definito come <code>BatchNorm2d(64)</code>, quindi normalizza \nesattamente 64 &ldquo;canali&rdquo;, che corrispondono alle nostre 64 bande Mel dopo la \ntrasposizione.</p>\n<h3 id=\"42-operazione-di-batch-normalization\">4.2 Operazione di Batch Normalization</h3>\n<p>Per ogni banda Mel $m$ (ora un &ldquo;canale&rdquo;):</p>\n$$\n\\hat{x}[b, m, t, f] = \\gamma_m \\frac{x[b, m, t, f] - \\mu_m}{\\sqrt{\\sigma_m^2 + \\epsilon}} + \\beta_m\n$$\n<p>dove:\n- $\\mu_m$ = media su tutto il batch e posizioni spazio-temporali per la banda $m$\n- $\\sigma_m^2$ = varianza corrispondente\n- $\\gamma_m, \\beta_m$ = parametri apprendibili (scaling e shift)\n- $\\epsilon = 10^{-5}$ = costante per stabilità numerica</p>\n<p><strong>Calcolo della media</strong>:</p>\n$$\n\\mu_m = \\frac{1}{B \\cdot T_{frames} \\cdot 1} \\sum_{b=1}^{B} \\sum_{t=1}^{T_{frames}} x[b, m, t, 0]\n$$\n<p><strong>Intuizione</strong>: \n- Diverse bande di frequenza possono avere energie molto diverse (es. i bassi sono tipicamente più forti degli alti)\n- La batch normalization standardizza ogni banda indipendentemente, con media 0 e varianza 1\n- Questo aiuta il training permettendo a tutte le bande di contribuire equamente al gradiente\n- I parametri $\\gamma$ e $\\beta$ permettono alla rete di &ldquo;reimparare&rdquo; la scala ottimale per ogni banda</p>\n<h2 id=\"5-data-augmentation-solo-training\">5. Data Augmentation (Solo Training)</h2>\n<h3 id=\"51-specaugmentation\">5.1 SpecAugmentation</h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_augmenter</span> <span class=\"o\">=</span> <span class=\"n\">SpecAugmentation</span><span class=\"p\">(</span>\n    <span class=\"n\">time_drop_width</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span>    <span class=\"c1\"># larghezza maschere temporali</span>\n    <span class=\"n\">time_stripes_num</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>    <span class=\"c1\"># numero maschere temporali</span>\n    <span class=\"n\">freq_drop_width</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span>     <span class=\"c1\"># larghezza maschere frequenziali</span>\n    <span class=\"n\">freq_stripes_num</span><span class=\"o\">=</span><span class=\"mi\">2</span>     <span class=\"c1\"># numero maschere frequenziali</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Time masking</strong>: Azzera 2 strisce verticali casuali di larghezza massima 64 frame</p>\n$$\n\\mathbf{M}[b, 1, t, m] = 0 \\quad \\text{per } t \\in [t_0, t_0 + w_t]\n$$\n<p>dove $t_0$ è casuale e $w_t \\leq 64$.</p>\n<p><strong>Frequency masking</strong>: Azzera 2 strisce orizzontali casuali di larghezza massima 8 bande</p>\n$$\n\\mathbf{M}[b, 1, t, m] = 0 \\quad \\text{per } m \\in [m_0, m_0 + w_m]\n$$\n<p><strong>Intuizione</strong>: \n- Simula occlusioni e distorsioni reali (es. rumori transienti, perdita di banda)\n- Forza la rete a non dipendere da specifiche regioni tempo-frequenza\n- Migliora la robustezza e generalizzazione\n- È come &ldquo;nascondere&rdquo; parti dello spettrogramma per insegnare alla rete a riconoscere i suoni anche con informazioni incomplete</p>\n<h3 id=\"52-mixup\">5.2 Mixup</h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span> <span class=\"ow\">and</span> <span class=\"n\">mixup_lambda</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">do_mixup</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mixup_lambda</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Operazione</strong>:</p>\n$$\n\\tilde{x} = \\lambda x_i + (1-\\lambda) x_j\n$$\n$$\n\\tilde{y} = \\lambda y_i + (1-\\lambda) y_j\n$$\n<p>dove $\\lambda \\sim \\text{Beta}(\\alpha, \\alpha)$ (tipicamente $\\alpha = 1$, distribuzione uniforme).</p>\n<p><strong>Intuizione</strong>:\n- Mixa linearmente due esempi e le loro etichette\n- Crea esempi &ldquo;ibridi&rdquo; che forzano la rete a imparare interpolazioni smooth tra classi\n- Riduce overfitting e migliora calibrazione delle probabilità\n- È come sovrapporre due suoni e chiedere alla rete di riconoscere entrambi proporzionalmente</p>\n<h2 id=\"6-blocchi-convoluzionali-gerarchici\">6. Blocchi Convoluzionali Gerarchici</h2>\n<p>Prima di procedere con i singoli blocchi, è importante comprendere la struttura del <code>ConvBlock</code>, che è l&rsquo;unità fondamentale ripetuta nell&rsquo;architettura CNN14. Ogni <code>ConvBlock</code> è composto da:</p>\n<ol>\n<li><strong>Prima convoluzione 2D</strong> con kernel $3 \\times 3$, stride $(1,1)$, padding $(1,1)$</li>\n<li><strong>Batch Normalization</strong> sulla prima convoluzione</li>\n<li><strong>Attivazione ReLU in-place</strong> ($\\text{ReLU}$)</li>\n<li><strong>Seconda convoluzione 2D</strong> con kernel $3 \\times 3$, stride $(1,1)$, padding $(1,1)$</li>\n<li><strong>Batch Normalization</strong> sulla seconda convoluzione</li>\n<li><strong>Attivazione ReLU in-place</strong></li>\n<li><strong>Pooling operation</strong> (average, max, o avg+max)</li>\n</ol>\n<h3 id=\"61-struttura-del-convblock\">6.1 Struttura del ConvBlock</h3>\n<p>Ogni <code>ConvBlock</code> implementa il pattern:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>Input → Conv2d → BatchNorm → ReLU → Conv2d → BatchNorm → ReLU → Pooling → Output\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Implementazione matematica</strong>:</p>\n<p>Matematicamente, per un <code>ConvBlock</code> che trasforma $C_{in}$ canali in $C_{out}$ canali:</p>\n$$\n\\begin{aligned}\n\\mathbf{h}_1 &= \\text{Conv2d}_{C_{in} \\rightarrow C_{out}}(\\mathbf{x}, \\text{kernel}=3, \\text{padding}=1, \\text{stride}=1) \\\\\n\\mathbf{h}_1 &= \\text{ReLU}(\\text{BN}(\\mathbf{h}_1)) \\\\\n\\mathbf{h}_2 &= \\text{Conv2d}_{C_{out} \\rightarrow C_{out}}(\\mathbf{h}_1, \\text{kernel}=3, \\text{padding}=1, \\text{stride}=1) \\\\\n\\mathbf{h}_2 &= \\text{ReLU}(\\text{BN}(\\mathbf{h}_2)) \\\\\n\\mathbf{x}_{out} &= \\text{Pool}(\\mathbf{h}_2, \\text{pool_size})\n\\end{aligned}\n$$\n<p>dove i parametri sono: </p>\n<ul>\n<li>$\\mathbf{x}$: input di dimensione $(C_{in}, H_{in}, W_{in})$</li>\n<li>$C_{in}$: numero di canali dell&rsquo;input</li>\n<li>$C_{out}$: numero di canali dell&rsquo;output</li>\n<li>pool_size: dimensione del pooling</li>\n<li>pool_type: tipo di pooling (&lsquo;avg&rsquo;, &lsquo;max&rsquo;, &lsquo;avg+max&rsquo;)</li>\n</ul>\n<p><strong>Convoluzione 2D con padding=1</strong>:</p>\n<p>Per un kernel $3 \\times 3$, il padding di 1 pixel preserva le dimensioni spaziali:</p>\n$$\nH_{out} = H_{in}, \\quad W_{out} = W_{in}\n$$\n<p>La convoluzione calcola:</p>\n$$\ny[c_{out}, h, w] = \\sum_{c_{in}} \\sum_{i=-1}^{1} \\sum_{j=-1}^{1} x[c_{in}, h+i, w+j] \\cdot K[c_{out}, c_{in}, i+1, j+1]\n$$\n<p><strong>Nota</strong>: il bias $+ b[c_{out}]$ è omesso nelle convoluzioni perché la BatchNorm successiva include già un parametro di shift (β), rendendo il bias della conv ridondante. Questo è uno standard nelle architetture moderne.</p>\n<p><strong>Batch Normalization dopo Conv</strong>:</p>\n$$\n\\hat{h}[b, c, h, w] = \\gamma_c \\frac{h[b, c, h, w] - \\mu_c}{\\sqrt{\\sigma_c^2 + \\epsilon}} + \\beta_c\n$$\n<p>Normalizza le attivazioni per canale, stabilizzando il training.</p>\n<p><strong><span class=\"text-gray-600\">ReLU (Rectified Linear Unit)</span></strong>:</p>\n$$\n\\text{ReLU}(x) = \\max(0, x)\n$$\n<p><strong>Intuizione di ReLU</strong>:\n- Introduce non-linearità: senza ReLU, stacking di conv sarebbe equivalente a una singola conv\n- &ldquo;Accende&rdquo; i neuroni solo per attivazioni positive\n- Crea rappresentazioni sparse (molti zeri)\n- Permette alla rete di imparare funzioni complesse e gerarchiche</p>\n<p><strong>Average Pooling 2D</strong>:</p>\n$$\ny[c, h', w'] = \\frac{1}{k_h \\cdot k_w} \\sum_{i=0}^{k_h-1} \\sum_{j=0}^{k_w-1} x[c, h' \\cdot s_h + i, w' \\cdot s_w + j]\n$$\n<p>Con pool_size $(2,2)$ e stride $(2,2)$ (default):</p>\n$$\nH_{out} = \\lfloor H_{in} / 2 \\rfloor, \\quad W_{out} = \\lfloor W_{in} / 2 \\rfloor\n$$\n<p>dove:</p>\n<ul>\n<li>$k_h$ e $k_w$ sono le dimensioni del kernel</li>\n<li>$s_h$ e $s_w$ sono le dimensioni dello stride</li>\n<li>$y$ ha dimensioni $(C_{out}, H_{out}, W_{out})$</li>\n</ul>\n<p><strong>Max Pooling 2D</strong>:</p>\n$$\ny[c, h', w'] = \\max_{i=0}^{k_h-1} \\max_{j=0}^{k_w-1} x[c, h' \\cdot s_h + i, w' \\cdot s_w + j]\n$$\n<p>Con pool_size $(2,2)$ e stride $(2,2)$ (default):</p>\n$$\nH_{out} = \\lfloor H_{in} / 2 \\rfloor, \\quad W_{out} = \\lfloor W_{in} / 2 \\rfloor\n$$\n<p>dove:</p>\n<ul>\n<li>$k_h$ e $k_w$ sono le dimensioni del kernel</li>\n<li>$s_h$ e $s_w$ sono le dimensioni dello stride</li>\n<li>$y$ ha dimensioni $(C_{out}, H_{out}, W_{out})$</li>\n</ul>\n<p><strong>Avg Pooling 2D + Max Pooling 2D</strong></p>\n<p>Combinazione di Average Pooling 2D e Max Pooling 2D. Da notare che entrambi devono avere lo stesso pool_size e stride.</p>\n$$\ny[c, h', w'] = \\text{AvgPooling_2D}(x, pool_size, stride) + \\text{MaxPooling_2D}(x, pool_size, stride)\n$$\n<p><strong>Intuizione del pooling</strong>:\n- Riduce le dimensioni spaziali, creando rappresentazioni più compatte\n- Introduce invarianza locale: piccoli spostamenti nell&rsquo;input non cambiano drasticamente l&rsquo;output\n- Aumenta il &ldquo;campo recettivo&rdquo;: neuroni nei layer successivi &ldquo;vedono&rdquo; porzioni sempre più grandi dell&rsquo;input originale\n- Average pooling preserva informazione globale sulla presenza di feature (vs max pooling che preserva solo la più forte)</p>\n<p><strong>Riassumendo:</strong>\nLa convoluzione 2D con padding $(1,1)$ preserva le dimensioni spaziali:</p>\n$$\n\\text{Se } \\mathbf{x}_{in} \\in \\mathbb{R}^{B \\times C_{in} \\times H \\times W} \\text{, dopo Conv2D+BatchNorm+ReLU: } \\mathbf{h} \\in \\mathbb{R}^{B \\times C_{out} \\times H \\times W}\n$$\n<p>Il pooling con pool_size $(2,2)$ dimezza le dimensioni spaziali:</p>\n$$\n\\text{Se } \\mathbf{h} \\in \\mathbb{R}^{B \\times C \\times H \\times W} \\text{, dopo pool: } \\mathbf{x}_{out} \\in \\mathbb{R}^{B \\times C \\times \\lfloor H/2 \\rfloor \\times \\lfloor W/2 \\rfloor}.\n$$\n<h3 id=\"62-progressione-dei-convblock\">6.2 Progressione dei ConvBlock</h3>\n<p><strong>ConvBlock 1</strong>: $1 \\rightarrow 64$ canali</p>\n<p>Il primo blocco convoluzionale espande il canale singolo del Mel spectrogram a 64 feature maps:</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">conv_block1</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">pool_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">pool_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;avg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_1 \\in \\mathbb{R}^{B \\times 1 \\times 1501 \\times 64} \\rightarrow \\boxed{\\text{ConvBlock1}} \\rightarrow \\mathbf{x}_2 \\in \\mathbb{R}^{B \\times 64 \\times 750 \\times 32}\n$$\n<ul>\n<li>Input: log-Mel spectrogram (1 canale)</li>\n<li>Output: 64 feature maps</li>\n<li>Riduzione: $1501 \\rightarrow 750$ frame, $64 \\rightarrow 32$ bande Mel</li>\n</ul>\n<p><strong>Dropout con p=0.2:</strong></p>\n$$\n\\mathbf{x}_2 = \\text{Dropout}_{0.2}(\\mathbf{x}_2)\n$$\n<p>Durante il training, ogni elemento ha probabilità 0.2 di essere azzerato e i valori rimanenti vengono scalati di $1/0.8 = 1.25$ per mantenere l&rsquo;aspettativa.</p>\n<p><strong>Intuizione</strong>: Il primo layer impara feature di basso livello come edge detector, rivelatori di energia locale, pattern di texture semplici.</p>\n<p><strong>ConvBlock 2</strong>: $64 \\rightarrow 128$ canali</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">conv_block2</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">pool_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">pool_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;avg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_2 \\in \\mathbb{R}^{B \\times 64 \\times 750 \\times 32} \\rightarrow \\boxed{\\text{ConvBlock2}} \\rightarrow \\mathbf{x}_3 \\in \\mathbb{R}^{B \\times 128 \\times 375 \\times 16}\n$$\n$$\n\\mathbf{x}_3 = \\text{Dropout}_{0.2}(\\mathbf{x}_3)\n$$\n<p><strong>Intuizione</strong>: Combina feature di basso livello in pattern più complessi (es. sequenze di armoniche, transizioni temporali specifiche).</p>\n<p><strong>ConvBlock 3</strong>: $128 \\rightarrow 256$ canali</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">conv_block3</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">pool_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">pool_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;avg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_3 \\in \\mathbb{R}^{B \\times 128 \\times 375 \\times 16} \\rightarrow \\boxed{\\text{ConvBlock3}} \\rightarrow \\mathbf{x}_4 \\in \\mathbb{R}^{B \\times 256 \\times 187 \\times 8}\n$$\n$$\n\\mathbf{x}_4 = \\text{Dropout}_{0.2}(\\mathbf{x}_4)\n$$\n<p><strong>Intuizione</strong>: Inizia a riconoscere &ldquo;parti di suoni&rdquo; (es. inizio di una nota, parte di una parola, pattern ritmici).</p>\n<p><strong>ConvBlock 4</strong>: $256 \\rightarrow 512$ canali</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">conv_block4</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">pool_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">pool_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;avg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_4 \\in \\mathbb{R}^{B \\times 256 \\times 187 \\times 8} \\rightarrow \\boxed{\\text{ConvBlock4}} \\rightarrow \\mathbf{x}_5 \\in \\mathbb{R}^{B \\times 512 \\times 93 \\times 4}\n$$\n$$\n\\mathbf{x}_5 = \\text{Dropout}_{0.2}(\\mathbf{x}_5)\n$$\n<p><strong>Intuizione</strong>: Riconosce strutture acustiche di medio livello (es. frasi musicali brevi, fonemi, eventi sonori specifici).</p>\n<p><strong>ConvBlock 5</strong>: $512 \\rightarrow 1024$ canali</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">conv_block5</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">pool_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">),</span> <span class=\"n\">pool_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;avg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_5 \\in \\mathbb{R}^{B \\times 512 \\times 93 \\times 4} \\rightarrow \\boxed{\\text{ConvBlock5}} \\rightarrow \\mathbf{x}_6 \\in \\mathbb{R}^{B \\times 1024 \\times 46 \\times 2}\n$$\n$$\n\\mathbf{x}_6 = \\text{Dropout}_{0.2}(\\mathbf{x}_6)\n$$\n<p><strong>Intuizione</strong>: Cattura pattern di alto livello e context (es. stile musicale, tipo di speaker, ambiente acustico).</p>\n<p><strong>ConvBlock 6</strong>: $1024 \\rightarrow 2048$ canali (pooling 1×1)</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">conv_block6</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">pool_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">),</span> <span class=\"n\">pool_type</span><span class=\"o\">=</span><span class=\"s1\">&#39;avg&#39;</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.2</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_6 \\in \\mathbb{R}^{B \\times 1024 \\times 46 \\times 2} \\rightarrow \\boxed{\\text{ConvBlock6}} \\rightarrow \\mathbf{x}_7 \\in \\mathbb{R}^{B \\times 2048 \\times 46 \\times 2}\n$$\n$$\n\\mathbf{x}_7 = \\text{Dropout}_{0.2}(\\mathbf{x}_7)\n$$\n<p><strong>Nota cruciale</strong>: Il pooling $(1,1)$ <strong>non riduce</strong> le dimensioni spaziali. Serve solo per:\n- Aumentare la capacità di rappresentazione (2048 canali)\n- Applicare dropout per regolarizzazione\n- Mantenere coerenza architetturale</p>\n<p><strong>Intuizione</strong>: Questo layer finale di feature extraction crea una rappresentazione molto ricca e astratta, con 2048 dimensioni che codificano caratteristiche semantiche di alto livello del contenuto audio.</p>\n<h2 id=\"7-pooling-temporale-e-globale\">7. Pooling Temporale e Globale</h2>\n<h3 id=\"71-frequency-pooling\">7.1 Frequency Pooling</h3>\n<p>Dopo ConvBlock6, abbiamo $\\mathbf{x}_7 \\in \\mathbb{R}^{B \\times 2048 \\times 46 \\times 2}$.</p>\n<p><strong>Operazione</strong>:</p>\n$$\n\\mathbf{x}_{freq}[b, c, t] = \\frac{1}{2}\\sum_{f=0}^{1} \\mathbf{x}_7[b, c, t, f] = \\frac{\\mathbf{x}_7[b, c, t, 0] + \\mathbf{x}_7[b, c, t, 1]}{2}\n$$\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">3</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Output</strong>:</p>\n$$\n\\mathbf{x}_{freq} \\in \\mathbb{R}^{B \\times 2048 \\times 46}\n$$\n<p><strong>Intuizione</strong>:\n- A questo punto, le 2 &ldquo;bande di frequenza&rdquo; rimaste sono altamente astratte (non più frequenze fisiche)\n- Fare la media collassa completamente l&rsquo;informazione frequenziale\n- Otteniamo una sequenza temporale pura: 46 frame, ciascuno con 2048 feature\n- È come avere una &ldquo;storia&rdquo; del suono in 46 &ldquo;capitoli&rdquo;, dove ogni capitolo ha 2048 caratteristiche</p>\n<h3 id=\"72-global-temporal-pooling-max-average\">7.2 Global Temporal Pooling (Max + Average)</h3>\n<p><strong>Max Pooling temporale</strong>:</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"p\">(</span><span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">_</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">max</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_{max}[b, c] = \\max_{t=1}^{46} \\mathbf{x}_{freq}[b, c, t]\n$$\n<p><strong>Output</strong>: $\\mathbf{x}_{max} \\in \\mathbb{R}^{B \\times 2048}$</p>\n<p><strong>Intuizione di Max Pooling</strong>:\n- Seleziona l&rsquo;attivazione <strong>massima</strong> di ogni feature attraverso tutto il clip audio\n- Cattura le caratteristiche <strong>più prominenti</strong> o <strong>eventi più forti</strong>\n- È invariante alla posizione temporale: non importa <em>quando</em> compare un evento, conta solo che ci sia\n- Ottimo per rilevare presenza/assenza di pattern specifici (es. &ldquo;c&rsquo;è un clacson da qualche parte?&rdquo;)</p>\n<p><strong>Average Pooling temporale</strong>:</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x2</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_{avg}[b, c] = \\frac{1}{46}\\sum_{t=1}^{46} \\mathbf{x}_{freq}[b, c, t]\n$$\n<p><strong>Output</strong>: $\\mathbf{x}_{avg} \\in \\mathbb{R}^{B \\times 2048}$</p>\n<p><strong>Intuizione di Average Pooling</strong>:\n- Calcola l&rsquo;attivazione <strong>media</strong> di ogni feature attraverso tutto il clip\n- Cattura la <strong>distribuzione globale</strong> e le caratteristiche <strong>persistenti</strong>\n- Sensibile alla durata e frequenza di occorrenza di pattern\n- Ottimo per texture e caratteristiche diffuse (es. &ldquo;questa musica è prevalentemente ritmica?&rdquo;)</p>\n<p><strong>Combinazione (somma element-wise)</strong>:</p>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x1</span> <span class=\"o\">+</span> <span class=\"n\">x2</span>\n</code></pre></div>\n</div>\n</div>\n\n$$\n\\mathbf{x}_{global}[b, c] = \\mathbf{x}_{max}[b, c] + \\mathbf{x}_{avg}[b, c]\n$$\n<p><strong>Output</strong>: $\\mathbf{x}_{global} \\in \\mathbb{R}^{B \\times 2048}$</p>\n<p><strong>Intuizione della combinazione</strong>:\n- Unisce due &ldquo;punti di vista&rdquo; complementari sullo stesso audio\n- Max cattura eventi salienti e picchi\n- Average cattura statistiche globali e background\n- La somma permette alla rete di pesare entrambi gli aspetti\n- È come avere sia il &ldquo;momento clou&rdquo; che il &ldquo;riassunto generale&rdquo; di ogni caratteristica</p>\n<p>Questo è l&rsquo;<strong>embedding audio finale</strong>: un vettore di 2048 dimensioni che riassume tutto il contenuto acustico del clip.</p>\n<h2 id=\"8-layer-fully-connected-e-classificazione\">8. Layer Fully Connected e Classificazione</h2>\n<h3 id=\"81-dropout-pre-fc\">8.1 Dropout Pre-FC</h3>\n$$\n\\mathbf{x}_{global} = \\text{Dropout}_{0.5}(\\mathbf{x}_{global})\n$$\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Dropout aggressivo al 50%</strong>: spegne casualmente metà dei neuroni dell&rsquo;embedding.</p>\n<p><strong>Intuizione</strong>: \n- Prima dei layer densi, il dropout deve essere più forte (50% vs 20% nei conv)\n- I fully connected layer hanno molti più parametri e sono più soggetti a overfitting\n- Questo è il dropout più importante per la regolarizzazione</p>\n<h3 id=\"82-primo-layer-fully-connected-fc1\">8.2 Primo Layer Fully Connected (fc1)</h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc1</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"mi\">2048</span><span class=\"p\">,</span> <span class=\"mi\">2048</span><span class=\"p\">,</span> <span class=\"n\">bias</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">relu_</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc1</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"c1\"># (B, 2048)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Operazione</strong>:</p>\n<p><strong>Operazione</strong>:</p>\n$$\n\\mathbf{h}_{fc1} = \\text{ReLU}(\\mathbf{x}_{global} \\mathbf{W}_1^\\top + \\mathbf{b}_1)\n$$\n<p>dove $\\mathbf{W}_1 \\in \\mathbb{R}^{2048 \\times 2048}$, $\\mathbf{b}_1 \\in \\mathbb{R}^{2048}$.</p>\n<p><strong>Dettaglio del linear layer</strong>:</p>\n$$\n\\mathbf{h}_{fc1}[b, j] = \\text{ReLU} \\left( \\sum_{i=1}^{2048} \\mathbf{x}_{global}[b, i] \\cdot \\mathbf{W}_1[j, i] + \\mathbf{b}_1[j] \\right), \\quad b = 1, \\dots, B, \\; j = 1, \\dots, 2048\n$$\n<p><strong>Intuizione</strong>:\n- Proietta l&rsquo;embedding in un nuovo spazio 2048D\n- Permette interazioni non-lineari tra tutte le 2048 feature\n- ReLU introduce non-linearità critica\n- Questo layer &ldquo;ragiona&rdquo; sull&rsquo;embedding: combina e ricombina le feature per creare rappresentazioni ancora più astratte\n- È come un layer di &ldquo;integrazione semantica&rdquo;</p>\n<p><strong>Output</strong>: $\\mathbf{h}_{fc1} \\in \\mathbb{R}^{B \\times 2048}$</p>\n<h3 id=\"83-secondo-dropout\">8.3 Secondo Dropout</h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc_audioset</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"mi\">2048</span><span class=\"p\">,</span> <span class=\"n\">classes_num</span><span class=\"p\">,</span> <span class=\"n\">bias</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">)</span>\n\n<span class=\"n\">embedding</span> <span class=\"o\">=</span> <span class=\"n\">F</span><span class=\"o\">.</span><span class=\"n\">dropout</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">p</span><span class=\"o\">=</span><span class=\"mf\">0.5</span><span class=\"p\">,</span> <span class=\"n\">training</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">)</span> <span class=\"c1\"># (B, 2048)</span>\n<span class=\"n\">clipwise_output</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc_audioset</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span> <span class=\"c1\"># (B, classes_num)</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Dettaglio importante</strong>: Il secondo dropout (50%) viene applicato per creare \nl&rsquo;<code>embedding</code> che viene restituito, ma <strong>NON</strong> viene applicato a $\\mathbf{x}_{global}$ prima della \nclassificazione. Infatti, <code>fc_audioset</code> opera su $\\mathbf{x}_{global}$ (output di fc1+ReLU senza \nil secondo dropout) e non su $embedding$.</p>\n<p>Questo significa che:\n- <strong>Embedding restituito</strong>: Più regolarizzato (con dropout)\n- <strong>Classificazione</strong>: Usa tutte le attivazioni (senza dropout)</p>\n<p>Questa scelta permette di avere un embedding più robusto per task downstream \nmantenendo la massima informazione per la classificazione principale.</p>\n<h3 id=\"84-layer-di-classificazione-fc_audioset\">8.4 Layer di Classificazione (fc_audioset)</h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">clipwise_output</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc_audioset</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">))</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>Operazione</strong>:</p>\n$$\n\\mathbf{z} = \\mathbf{h}_{fc1} \\mathbf{W}_2^\\top + \\mathbf{b}_2\n$$\n<p>dove $\\mathbf{W}_2 \\in \\mathbb{R}^{C \\times 2048}$, $\\mathbf{b}_2 \\in \\mathbb{R}^{C}$, $C$ = numero di classi.</p>\n<p><strong>Sigmoid activation</strong> (multi-label classification):</p>\n$$\n\\mathbf{p}[b, c] = \\sigma(\\mathbf{z}[b, c]) = \\frac{1}{1 + e^{-\\mathbf{z}[b, c]}}\n$$\n<p><strong>Output</strong>: $\\mathbf{p} \\in \\mathbb{R}^{B \\times C}$, con $p[b, c] \\in (0, 1)$</p>\n<p><strong>Intuizione</strong>:\n- Proietta l&rsquo;embedding nelle dimensioni delle classi target\n- Sigmoid converte logits in probabilità indipendenti per ogni classe\n- <strong>Multi-label</strong>: ogni classe può essere presente/assente indipendentemente (es. un audio può contenere sia &ldquo;musica&rdquo; che &ldquo;parlato&rdquo;)\n- Ogni $p[b, c]$ rappresenta la confidenza che la classe $c$ sia presente nel sample $b$\n- Training: Binary Cross-Entropy Loss su ogni classe</p>\n<h2 id=\"9-output-della-rete\">9. Output della Rete</h2>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">output_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">&#39;clipwise_output&#39;</span><span class=\"p\">:</span> <span class=\"n\">clipwise_output</span><span class=\"p\">,</span>  <span class=\"c1\"># (B, classes_num)</span>\n    <span class=\"s1\">&#39;embedding&#39;</span><span class=\"p\">:</span> <span class=\"n\">embedding</span>                <span class=\"c1\"># (B, 2048)</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n</div>\n</div>\n\n<p><strong>clipwise_output</strong>: Probabilità per ciascuna classe audio (es. probabilità che l&rsquo;audio contenga &ldquo;pianoforte&rdquo;, &ldquo;voce umana&rdquo;, &ldquo;traffico&rdquo;, ecc.)</p>\n<p><strong>embedding</strong>: Rappresentazione ad alta dimensionalità dell&rsquo;audio, utile per:\n- Transfer learning\n- Similarity search\n- Clustering\n- Downstream tasks</p>\n<h2 id=\"10-architettura-complessiva-visualizzazione-del-flusso\">10. Architettura Complessiva: Visualizzazione del Flusso</h2>\n<p><img src=\"/images/tikz/cde8894f2cc2931a043bac786c150b9b.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>"
}