{
  "title": "HTS-AT: Hierarchical Token-Semantic Audio Transformer",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n/* Blocchi di codice sempre visibili */\n.code-visible {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    background: #f9fafb;\n    margin: 16px 0;\n}\n.code-visible .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<h2 id=\"introduzione\">Introduzione</h2>\n<p>HTS-AT (Hierarchical Token-Semantic Audio Transformer) è un&rsquo;architettura basata su <strong><a href=\"/theory/deep-learning/Transformers/Swin Transformers/Swin Transformer\" class=\"text-blue-600 hover:underline\">Swin Transformer</a></strong> progettata specificamente per la classificazione e il rilevamento di eventi sonori. A differenza delle architetture CNN tradizionali, HTS-AT utilizza meccanismi di <strong>self-attention</strong> gerarchici per catturare dipendenze a lungo raggio negli spettrogrammi audio.</p>\n<p>Il nome deriva da:\n- <strong>Hierarchical</strong>: elaborazione multi-scala attraverso layer successivi\n- <strong>Token-Semantic</strong>: rappresentazione basata su token (patch) con significato semantico\n- <strong>Audio Transformer</strong>: architettura transformer adattata per l&rsquo;audio</p>\n<p>L&rsquo;architettura elabora l&rsquo;audio attraverso una pipeline che:\n1. Converte il segnale audio in rappresentazione tempo-frequenza (log-mel spectrogram)\n2. Divide lo spettrogramma in patch non sovrapposte (tokenizzazione)\n3. Elabora le patch attraverso blocchi Swin Transformer gerarchici\n4. Produce output di classificazione sia frame-wise che clip-wise</p>\n<h2 id=\"panoramica-del-pipeline\">Panoramica del Pipeline</h2>\n<ol>\n<li><strong>Estrazione dello Spettrogramma</strong> - STFT per conversione tempo-frequenza</li>\n<li><strong>Estrazione Log-Mel</strong> - rappresentazione percettiva con mel-scale</li>\n<li><strong>Normalizzazione Batch</strong> - standardizzazione delle feature mel</li>\n<li><strong>Data Augmentation</strong> (solo training) - SpecAugmentation e Mixup</li>\n<li><strong>Reshape a Immagine 2D</strong> - preparazione per patch embedding</li>\n<li><strong>Patch Embedding</strong> - tokenizzazione dello spettrogramma</li>\n<li><strong>Position Embedding</strong> (opzionale) - encoding posizionale assoluto</li>\n<li><strong>Blocchi Swin Transformer</strong> - elaborazione gerarchica con attention</li>\n<li><strong>Pooling e Classificazione</strong> - aggregazione e predizione</li>\n</ol>\n<p><img src=\"/images/posts/x1.png\" alt=\"Panoramica del Pipeline\" style=\"display: block; margin-left: auto; margin-right: auto;\"></p>\n<h2 id=\"1-input-forma-donda-audio\">1. Input: Forma d&rsquo;Onda Audio</h2>\n<p>L&rsquo;input è un segnale audio campionato digitalmente:</p>\n$$\n\\mathbf{s} \\in \\mathbb{R}^{B \\times N_{samples}}\n$$\n<p>dove:\n- $B$ = dimensione del batch\n- $N_{samples}$ = numero di campioni audio (tipicamente variabile, es. 10 secondi a 32 kHz = 320000 campioni)</p>\n<p>Il segnale $\\mathbf{s}$ rappresenta l’<strong>onda sonora campionata nel tempo</strong>, contenente tutte le informazioni acustiche della clip, incluse frequenze, intensità e dinamiche temporali. A questo livello, il modello non ha ancora estratto caratteristiche significative: ogni campione è semplicemente un valore numerico che descrive l’ampiezza del segnale in un dato istante.  </p>\n<p>Prima di essere passato al successivo step (feature extraction), $\\mathbf{s}$ può subire alcune operazioni preliminari come:<br />\n- <strong>Normalizzazione</strong> per garantire che l’ampiezza rientri in un intervallo standard (ad esempio [-1, 1]),<br />\n- <strong>Rimozione del DC offset</strong> per centrare la waveform intorno a zero,<br />\n- <strong>Eventuale trimming o padding</strong> per uniformare la durata delle clip all’interno del batch.  </p>\n<p>Questo passaggio è cruciale perché definisce la <strong>rappresentazione numerica di base</strong> su cui le successive trasformazioni (come trasformate di Fourier, mel-spectrogrammi o convoluzioni) potranno estrarre caratteristiche semantiche e acustiche rilevanti per l’allenamento contrastivo.</p>\n<h2 id=\"2-estrazione-dello-spettrogramma\">2. Estrazione dello Spettrogramma</h2>\n<h3 id=\"21-short-time-fourier-transform-stft\">2.1 Short-Time Fourier Transform (STFT)</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spectrogram_extractor</span> <span class=\"o\">=</span> <span class=\"n\">Spectrogram</span><span class=\"p\">(</span>\n    <span class=\"n\">n_fft</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span>      <span class=\"c1\"># es. 1024</span>\n    <span class=\"n\">hop_length</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">hop_size</span><span class=\"p\">,</span>     <span class=\"c1\"># es. 320</span>\n    <span class=\"n\">win_length</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span>\n    <span class=\"n\">window</span><span class=\"o\">=</span><span class=\"s1\">&#39;hann&#39;</span><span class=\"p\">,</span>\n    <span class=\"n\">center</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span>\n    <span class=\"n\">pad_mode</span><span class=\"o\">=</span><span class=\"s1\">&#39;reflect&#39;</span><span class=\"p\">,</span>\n    <span class=\"n\">freeze_parameters</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Matematicamente</strong>:</p>\n$$\n\\mathbf{X}_{STFT} = \\text{STFT}(\\mathbf{s}) \\implies \\mathbf{X}_{STFT}[b, m, k] = \\sum_{n=0}^{N-1} \\mathbf{s}[b, n + mH - \\underbrace{\\frac{N}{2}}_\\text{center=True}] \\cdot w[n] \\cdot e^{-j 2 \\pi k n/N_{fft}}\n$$\n<p>Le dimensioni del tensore risultante sono:</p>\n$$\n\\mathbf{X_{STFT}} \\in \\mathbb{C}^{B \\times C \\times T_{frames} \\times F_{bins}}\n$$\n<p>Con:</p>\n<ul>\n<li>Dimensione della finestra $N=1024$</li>\n<li>Numero di punti della FFT $N_{fft} = 1024$</li>\n<li>$C$ numero di canali (1 per il segnale audio mono e 2 per il segnale audio stereo)</li>\n<li>hop size $= 320$ (configurazione tipica)</li>\n<li>$T_{frames} = \\lfloor N_{samples} / 320 \\rfloor + 1$</li>\n<li>$F_{bins} = N_{fft}/2 + 1 = 1024/2 + 1 = 513$</li>\n</ul>\n<p>Se $N_{samples} < N_{fft}$, si effettua zero-padding della finestra prima della FFT per aumentare la risoluzione in frequenza.</p>\n<p><strong>Output dello spettrogramma di potenza</strong>:</p>\n<p>Poiché la STFT produce valori complessi, si calcola il <strong>power spectrogram</strong> per ottenere una rappresentazione reale e positiva:</p>\n<p>Calcolo del modulo quadrato per ogni elemento complesso:</p>\n$$\n\\mathbf{S} = |\\mathbf{X}_{STFT}|^2 = \\text{Re}(\\mathbf{X}_{STFT})^2 + \\text{Im}(\\mathbf{X}_{STFT})^2 \\in \\mathbb{R}^{B \\times 1 \\times T_{frames} \\times F_{bins}}\n$$\n<p>Dove per ogni elemento:</p>\n$$\n\\mathbf{S}[b, 1, t, f] = (\\text{Re}(\\mathbf{X}_{STFT}[b, 1, t, f]))^2 + (\\text{Im}(\\mathbf{X}_{STFT}[b, 1, t, f]))^2\n$$\n<p>Questa operazione element-wise converte i valori complessi della STFT in valori reali positivi che rappresentano l&rsquo;energia del segnale.</p>\n<p>Le dimensioni rimangono le stesse.</p>\n<p>Con $N_{fft} = 1024$ e hop size $= 320$ (configurazione tipica):\n- $T_{frames} = \\lfloor N_{samples} / 320 \\rfloor + 1$\n- $F_{bins} = 1024/2 + 1 = 513$</p>\n<p><strong>Intuizione</strong>: Decompone il segnale nelle sue componenti di frequenza nel tempo, creando una rappresentazione 2D tempo-frequenza.</p>\n<h2 id=\"3-log-mel-spectrogram\">3. Log-Mel Spectrogram</h2>\n<h3 id=\"31-mel-filter-bank\">3.1 Mel Filter Bank</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">logmel_extractor</span> <span class=\"o\">=</span> <span class=\"n\">LogmelFilterBank</span><span class=\"p\">(</span>\n    <span class=\"n\">sr</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">sample_rate</span><span class=\"p\">,</span>          <span class=\"c1\"># es. 32000 Hz</span>\n    <span class=\"n\">n_fft</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span>       <span class=\"c1\"># es. 1024</span>\n    <span class=\"n\">n_mels</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">mel_bins</span><span class=\"p\">,</span>         <span class=\"c1\"># es. 64</span>\n    <span class=\"n\">fmin</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">fmin</span><span class=\"p\">,</span>               <span class=\"c1\"># es. 50 Hz</span>\n    <span class=\"n\">fmax</span><span class=\"o\">=</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">fmax</span><span class=\"p\">,</span>               <span class=\"c1\"># es. 14000 Hz</span>\n    <span class=\"n\">ref</span><span class=\"o\">=</span><span class=\"mf\">1.0</span><span class=\"p\">,</span>\n    <span class=\"n\">amin</span><span class=\"o\">=</span><span class=\"mf\">1e-10</span><span class=\"p\">,</span>\n    <span class=\"n\">top_db</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span>\n    <span class=\"n\">freeze_parameters</span><span class=\"o\">=</span><span class=\"kc\">True</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Scala Mel</strong>:\nLa scala Mel è una trasformazione non lineare che approssima la percezione umana delle frequenze:</p>\n$$\n\\text{Mel}(f) = 2595 \\log_{10}\\left(1 + \\frac{f}{700}\\right)\n$$\n<p><strong>Applicazione filtri triangolari</strong>:</p>\n<p>A partire dallo spettrogramma $\\mathbf{S} \\in \\mathbb{R}^{B \\times 1 \\times T_{frames} \\times F_{bins}}$, si applica una banca di filtri triangolari $H_m[k]$ dove ogni filtro $m$ aggrega i bin di frequenza lineari $k$ per ottenere bande di frequenza percettivamente significative:</p>\n$$\n\\mathbf{M}_{mel} = \\mathbf{S}\\mathbf{H}^\\top \\implies \\mathbf{M}_{mel}[b, 1, t, m] = \\sum_{k=0}^{F_{bins}-1} \\mathbf{S}[b, 1, t, k] \\cdot H_m[k]\n$$\n<ul>\n<li>$H_m[k]$ è la risposta del filtro triangolare $m$-esimo,</li>\n<li>$\\mathbf{H} \\in \\mathbb{R}^{M_{mel} \\times F_{bins}}$ è la matrice completa dei filtri Mel ($M_{mel}=64$),</li>\n<li>La somma avviene lungo la dimensione delle frequenze,</li>\n<li>$b = 0, \\dots, B-1$, $t = 0, \\dots, T_{frames}-1$, $m = 0, \\dots, M_{mel}-1$.</li>\n</ul>\n<p><strong>Conversione in log-scale</strong>:</p>\n$$\n\\mathbf{M}_{log}[b, 1, t, m] = 10 \\log_{10}(\\max(\\mathbf{M}_{mel}[b, 1, t, m], \\epsilon))\n$$\n<p>dove $\\epsilon = 10^{-10}$ previene logaritmi di zero.</p>\n<p><strong>Output</strong>:</p>\n$$\n\\mathbf{M}_{log} \\in \\mathbb{R}^{B \\times 1 \\times T_{frames} \\times 64}\n$$\n<p><strong>Intuizione</strong>: \n- La scala Mel riflette la percezione non-lineare delle frequenze da parte dell&rsquo;orecchio umano\n- I filtri triangolari aggregano bin di frequenza adiacenti in bande percettivamente significative\n- La scala logaritmica comprime la gamma dinamica</p>\n<h2 id=\"4-normalizzazione-batch-bn0\">4. Normalizzazione Batch (bn0)</h2>\n<h3 id=\"41-trasposizione-per-batch-norm\">4.1 Trasposizione per Batch Norm</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 1, T, 64) → (B, 64, T, 1)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">bn0</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 64, T, 1) → (B, 1, T, 64)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Dove <code>self.bn0 = nn.BatchNorm2d(config.mel_bins)</code> con <code>config.mel_bins = 64</code>.</p>\n<p><strong>Perché questa trasposizione?</strong></p>\n<p><code>BatchNorm2d(64)</code> normalizza lungo la dimensione dei canali (dim=1). Il log-Mel ha forma $(B, 1, T, 64)$ con 1 canale e 64 bande Mel sull&rsquo;ultima dimensione. La trasposizione sposta le 64 bande Mel nella posizione dei canali per permettere la normalizzazione indipendente di ogni banda.</p>\n<h3 id=\"42-operazione-di-batch-normalization\">4.2 Operazione di Batch Normalization</h3>\n<p>Per ogni banda Mel $m$:</p>\n$$\n\\hat{x}[b, m, t, f] = \\gamma_m \\frac{x[b, m, t, f] - \\mu_m}{\\sqrt{\\sigma_m^2 + \\epsilon}} + \\beta_m\n$$\n<p>dove:\n- $\\mu_m$ = media su batch e posizioni spazio-temporali per la banda $m$\n- $\\sigma_m^2$ = varianza corrispondente\n- $\\gamma_m, \\beta_m$ = parametri apprendibili\n- $\\epsilon = 10^{-5}$ = costante per stabilità numerica</p>\n<p><strong>Intuizione</strong>: Standardizza ogni banda di frequenza indipendentemente, permettendo a tutte le bande di contribuire equamente al training.</p>\n<h2 id=\"5-data-augmentation-solo-training\">5. Data Augmentation (Solo Training)</h2>\n<h3 id=\"51-specaugmentation\">5.1 SpecAugmentation</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_augmenter</span> <span class=\"o\">=</span> <span class=\"n\">SpecAugmentation</span><span class=\"p\">(</span>\n    <span class=\"n\">time_drop_width</span><span class=\"o\">=</span><span class=\"mi\">64</span><span class=\"p\">,</span>\n    <span class=\"n\">time_stripes_num</span><span class=\"o\">=</span><span class=\"mi\">2</span><span class=\"p\">,</span>\n    <span class=\"n\">freq_drop_width</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span>\n    <span class=\"n\">freq_stripes_num</span><span class=\"o\">=</span><span class=\"mi\">2</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Time masking</strong>: Azzera 2 strisce verticali casuali di larghezza massima 64 frame:</p>\n$$\n\\mathbf{M}[b, 1, t, m] = 0 \\quad \\text{per } t \\in [t_0, t_0 + w_t], \\quad w_t \\leq 64\n$$\n<p><strong>Frequency masking</strong>: Azzera 2 strisce orizzontali casuali di larghezza massima 8 bande:</p>\n$$\n\\mathbf{M}[b, 1, t, m] = 0 \\quad \\text{per } m \\in [m_0, m_0 + w_m], \\quad w_m \\leq 8\n$$\n<p><strong>Intuizione</strong>: Simula occlusioni e distorsioni reali, forzando la rete a non dipendere da specifiche regioni tempo-frequenza.</p>\n<h3 id=\"52-mixup\">5.2 Mixup</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span> <span class=\"ow\">and</span> <span class=\"n\">mixup_lambda</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">do_mixup</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mixup_lambda</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Operazione</strong>:</p>\n$$\n\\tilde{x} = \\lambda x_i + (1-\\lambda) x_j\n$$\n$$\n\\tilde{y} = \\lambda y_i + (1-\\lambda) y_j\n$$\n<p>dove $\\lambda \\sim \\text{Beta}(\\alpha, \\alpha)$.</p>\n<p><strong>Intuizione</strong>: Crea esempi ibridi che migliorano la generalizzazione e riducono l&rsquo;overfitting.</p>\n<h2 id=\"6-reshape-a-immagine-2d\">6. Reshape a Immagine 2D</h2>\n<p>Prima del patch embedding, lo spettrogramma viene trasformato in un formato &ldquo;immagine&rdquo; con dimensioni specifiche.</p>\n<h3 id=\"61-parametri-di-configurazione\">6.1 Parametri di Configurazione</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">=</span> <span class=\"mi\">256</span>              <span class=\"c1\"># dimensione target dell&#39;immagine</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">//</span> <span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">mel_bins</span>  <span class=\"c1\"># es. 256 // 64 = 4</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Questo significa:\n- <strong>Target height</strong>: $256$ pixel\n- <strong>Target width</strong>: $256$ pixel<br />\n- <strong>Freq ratio</strong>: $4$ (numero di ripetizioni delle bande Mel in verticale)</p>\n<h3 id=\"62-funzione-reshape_wav2img\">6.2 Funzione reshape_wav2img</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">reshape_wav2img</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">F</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># es. (B, 1, T_frames, 64)</span>\n    <span class=\"n\">target_T</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span><span class=\"p\">)</span>  <span class=\"c1\"># 256 * 4 = 1024</span>\n    <span class=\"n\">target_F</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span>      <span class=\"c1\"># 256 // 4 = 64</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Step 1: Interpolazione temporale</strong> (se necessario)</p>\n<p>Se $T < 1024$:</p>\n$$\nx = \\text{interpolate}(x, (1024, F), \\text{mode}=\\text{bicubic})\n$$\n<p><strong>Step 2: Interpolazione frequenziale</strong> (se necessario)</p>\n<p>Se $F < 64$ (in realtà già 64, quindi salta):</p>\n$$\nx = \\text{interpolate}(x, (T, 64), \\text{mode}=\\text{bicubic})\n$$\n<p><strong>Step 3: Reshape con freq_ratio</strong></p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>  <span class=\"c1\"># (B, 1, 64, 1024)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">F</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span><span class=\"p\">)</span>\n<span class=\"c1\"># (B, 1, 64, 4, 256)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">3</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">,</span><span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>  <span class=\"c1\"># (B, 1, 4, 64, 256)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span> <span class=\"o\">*</span> <span class=\"n\">F</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span><span class=\"p\">)</span>\n<span class=\"c1\"># (B, 1, 256, 256)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Risultato finale</strong>:</p>\n$$\n\\mathbf{x}_{img} \\in \\mathbb{R}^{B \\times 1 \\times 256 \\times 256}\n$$\n<p><strong>Intuizione</strong>: \n- Lo spettrogramma viene riorganizzato in un&rsquo;immagine quadrata $256 \\times 256$\n- Le 64 bande Mel vengono &ldquo;espanse&rdquo; verticalmente a 256 pixel (4 ripetizioni)\n- La dimensione temporale viene compressa da 1024 a 256 frame\n- Questo formato è ideale per l&rsquo;elaborazione tramite patch embedding</p>\n<h2 id=\"7-patch-embedding\">7. Patch Embedding</h2>\n<p>Il patch embedding converte l&rsquo;immagine $256 \\times 256$ in una sequenza di token (patch).</p>\n<h3 id=\"71-configurazione\">7.1 Configurazione</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_size</span> <span class=\"o\">=</span> <span class=\"mi\">4</span>         <span class=\"c1\"># dimensione della patch</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_stride</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>  <span class=\"c1\"># stride della patch (non sovrapposto)</span>\n\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_embed</span> <span class=\"o\">=</span> <span class=\"n\">PatchEmbed</span><span class=\"p\">(</span>\n    <span class=\"n\">img_size</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span><span class=\"p\">,</span>      <span class=\"c1\"># 256</span>\n    <span class=\"n\">patch_size</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_size</span><span class=\"p\">,</span>   <span class=\"c1\"># 4</span>\n    <span class=\"n\">in_chans</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">in_chans</span><span class=\"p\">,</span>       <span class=\"c1\"># 1</span>\n    <span class=\"n\">embed_dim</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">embed_dim</span><span class=\"p\">,</span>     <span class=\"c1\"># es. 96</span>\n    <span class=\"n\">norm_layer</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm_layer</span><span class=\"p\">,</span>\n    <span class=\"n\">patch_stride</span><span class=\"o\">=</span><span class=\"n\">patch_stride</span>     <span class=\"c1\"># (4, 4)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"72-struttura-del-patchembed\">7.2 Struttura del PatchEmbed</h3>\n<p>Il modulo <code>PatchEmbed</code> contiene:</p>\n<ol>\n<li><strong>Conv2D per proiezione</strong>:</li>\n</ol>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">padding</span> <span class=\"o\">=</span> <span class=\"p\">((</span><span class=\"n\">patch_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span> <span class=\"o\">//</span> <span class=\"mi\">2</span><span class=\"p\">,</span> \n           <span class=\"p\">(</span><span class=\"n\">patch_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span> <span class=\"o\">//</span> <span class=\"mi\">2</span><span class=\"p\">)</span>\n<span class=\"c1\"># Con patch_size=4 e stride=4: padding = (0, 0)</span>\n\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">proj</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Conv2d</span><span class=\"p\">(</span>\n    <span class=\"n\">in_chans</span><span class=\"p\">,</span>      <span class=\"c1\"># 1</span>\n    <span class=\"n\">embed_dim</span><span class=\"p\">,</span>     <span class=\"c1\"># 96</span>\n    <span class=\"n\">kernel_size</span><span class=\"o\">=</span><span class=\"n\">patch_size</span><span class=\"p\">,</span>      <span class=\"c1\"># (4, 4)</span>\n    <span class=\"n\">stride</span><span class=\"o\">=</span><span class=\"n\">patch_stride</span><span class=\"p\">,</span>         <span class=\"c1\"># (4, 4)</span>\n    <span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"n\">padding</span>              <span class=\"c1\"># (0, 0)</span>\n<span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<ol>\n<li><strong>Normalizzazione</strong> (opzionale):</li>\n</ol>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm</span> <span class=\"o\">=</span> <span class=\"n\">norm_layer</span><span class=\"p\">(</span><span class=\"n\">embed_dim</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">norm_layer</span> <span class=\"k\">else</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Identity</span><span class=\"p\">()</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"73-operazione-di-patch-embedding\">7.3 Operazione di Patch Embedding</h3>\n<p><strong>Input</strong>: $\\mathbf{x}_{img} \\in \\mathbb{R}^{B \\times 1 \\times 256 \\times 256}$</p>\n<p><strong>Proiezione Conv2D</strong>:</p>\n<p>La convoluzione con kernel $4 \\times 4$ e stride $(4, 4)$ divide l&rsquo;immagine in patch non sovrapposte:</p>\n$$\n\\mathbf{x}_{conv} = \\text{Conv2d}(\\mathbf{x}_{img})\n$$\n<p><strong>Dimensioni output della convoluzione</strong>:</p>\n$$\nH_{out} = \\frac{256 - 4 + 2 \\cdot 0}{4} + 1 = 64\n$$\n$$\nW_{out} = \\frac{256 - 4 + 2 \\cdot 0}{4} + 1 = 64\n$$\n<p>Quindi: $\\mathbf{x}_{conv} \\in \\mathbb{R}^{B \\times 96 \\times 64 \\times 64}$</p>\n<p><strong>Flatten e Transpose</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 96, 64, 64) → (B, 96, 4096) → (B, 4096, 96)</span>\n</code></pre></div>\n</div>\n</details>\n\n$$\n\\mathbf{x}_{patches} \\in \\mathbb{R}^{B \\times 4096 \\times 96}\n$$\n<p>dove $4096 = 64 \\times 64$ è il numero totale di patch.</p>\n<p><strong>Normalizzazione</strong> (se presente):</p>\n$$\n\\mathbf{x}_{embed} = \\text{LayerNorm}(\\mathbf{x}_{patches})\n$$\n<p><strong>Output finale del patch embedding</strong>:</p>\n$$\n\\mathbf{x}_{embed} \\in \\mathbb{R}^{B \\times 4096 \\times 96}\n$$\n<p><strong>Intuizione</strong>:\n- Ogni patch $4 \\times 4$ dello spettrogramma originale diventa un token di dimensione 96\n- L&rsquo;immagine $256 \\times 256$ viene divisa in $64 \\times 64 = 4096$ patch\n- Ogni token rappresenta una regione locale tempo-frequenza dello spettrogramma\n- Questo è analogo alla tokenizzazione del testo in NLP, ma applicato a regioni spaziali</p>\n<h3 id=\"74-grid-size-e-patches-resolution\">7.4 Grid Size e Patches Resolution</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">grid_size</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">img_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> \n                  <span class=\"n\">img_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"c1\"># self.grid_size = (256 // 4, 256 // 4) = (64, 64)</span>\n\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patches_resolution</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">grid_size</span>  <span class=\"c1\"># (64, 64)</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_patches</span> <span class=\"o\">=</span> <span class=\"mi\">64</span> <span class=\"o\">*</span> <span class=\"mi\">64</span> <span class=\"o\">=</span> <span class=\"mi\">4096</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Questi valori saranno usati dai layer successivi per operazioni che richiedono la struttura spaziale 2D.</p>\n<h2 id=\"8-position-embedding-opzionale\">8. Position Embedding (Opzionale)</h2>\n<h3 id=\"81-absolute-position-embedding\">8.1 Absolute Position Embedding</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">ape</span><span class=\"p\">:</span>  <span class=\"c1\"># Absolute Position Embedding</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">absolute_pos_embed</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Parameter</span><span class=\"p\">(</span>\n        <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">num_patches</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">embed_dim</span><span class=\"p\">)</span>\n    <span class=\"p\">)</span>\n    <span class=\"n\">trunc_normal_</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">absolute_pos_embed</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">=</span><span class=\"mf\">.02</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Se abilitato (<code>ape=True</code>):</p>\n$$\n\\mathbf{x}_{pos} = \\mathbf{x}_{embed} + \\mathbf{P}_{abs}\n$$\n<p>dove $\\mathbf{P}_{abs} \\in \\mathbb{R}^{1 \\times 4096 \\times 96}$ è un parametro apprendibile.</p>\n<p><strong>Intuizione</strong>: \n- I transformer sono permutation-invariant (non hanno nozione di ordine)\n- Il position embedding aggiunge informazione sulla posizione spaziale di ogni patch\n- Questo aiuta il modello a distinguere patch in diverse posizioni dello spettrogramma\n- In HTS-AT, l&rsquo;uso è opzionale perché i Swin Transformer usano <strong>relative position bias</strong> intrinseco</p>\n<h3 id=\"82-position-dropout\">8.2 Position Dropout</h3>\n<p>Applicato sia durante il training che durante l&rsquo;inferenza.</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">pos_drop</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Dropout</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop_rate</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">pos_drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Applica dropout dopo il position embedding per regolarizzazione.</p>\n<h2 id=\"9-stochastic-depth-drop-path\">9. Stochastic Depth (Drop Path)</h2>\n<p>Prima di entrare nei layer, viene definito uno schedule di stochastic depth:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">dpr</span> <span class=\"o\">=</span> <span class=\"p\">[</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">item</span><span class=\"p\">()</span> <span class=\"k\">for</span> <span class=\"n\">x</span> <span class=\"ow\">in</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">linspace</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop_path_rate</span><span class=\"p\">,</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">))]</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Esempio con configurazione tipica</strong>:\n- <code>depths = [2, 2, 6, 2]</code> → totale blocchi = $2 + 2 + 6 + 2 = 12$\n- <code>drop_path_rate = 0.1</code>\n- <code>dpr = [0.000, 0.009, 0.018, 0.027, 0.036, 0.045, 0.055, 0.064, 0.073, 0.082, 0.091, 0.100]</code></p>\n<p><strong>Intuizione</strong>: La probabilità di drop aumenta linearmente con la profondità del layer. Questo migliora la regolarizzazione e facilita il training di reti profonde.</p>\n<p>Quindi, durante training: Drop Path attivo con probabilità crescente nei layer più profondi. Mentre durante inferenza: Drop Path <em>completamente disabilitato</em>.</p>\n<h2 id=\"10-architettura-gerarchica-basiclayer\">10. Architettura Gerarchica: BasicLayer</h2>\n<p>HTS-AT è organizzato in <strong>4 stage gerarchici</strong> (configurazione tipica: <code>depths=[2, 2, 6, 2]</code>):</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_layers</span> <span class=\"o\">=</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">)</span>  <span class=\"c1\"># 4</span>\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">layers</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">ModuleList</span><span class=\"p\">()</span>\n\n<span class=\"k\">for</span> <span class=\"n\">i_layer</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_layers</span><span class=\"p\">):</span>\n    <span class=\"n\">layer</span> <span class=\"o\">=</span> <span class=\"n\">BasicLayer</span><span class=\"p\">(</span>\n        <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">embed_dim</span> <span class=\"o\">*</span> <span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"n\">i_layer</span><span class=\"p\">),</span>\n        <span class=\"n\">input_resolution</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">patches_resolution</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"n\">i_layer</span><span class=\"p\">),</span>\n                          <span class=\"n\">patches_resolution</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"n\">i_layer</span><span class=\"p\">)),</span>\n        <span class=\"n\">depth</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">[</span><span class=\"n\">i_layer</span><span class=\"p\">],</span>\n        <span class=\"n\">num_heads</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span><span class=\"p\">[</span><span class=\"n\">i_layer</span><span class=\"p\">],</span>\n        <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span>\n        <span class=\"n\">mlp_ratio</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mlp_ratio</span><span class=\"p\">,</span>\n        <span class=\"n\">qkv_bias</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">qkv_bias</span><span class=\"p\">,</span>\n        <span class=\"n\">qk_scale</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">qk_scale</span><span class=\"p\">,</span>\n        <span class=\"n\">drop</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop_rate</span><span class=\"p\">,</span>\n        <span class=\"n\">attn_drop</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attn_drop_rate</span><span class=\"p\">,</span>\n        <span class=\"n\">drop_path</span><span class=\"o\">=</span><span class=\"n\">dpr</span><span class=\"p\">[</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">[:</span><span class=\"n\">i_layer</span><span class=\"p\">]):</span><span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">[:</span><span class=\"n\">i_layer</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">])],</span>\n        <span class=\"n\">norm_layer</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm_layer</span><span class=\"p\">,</span>\n        <span class=\"n\">downsample</span><span class=\"o\">=</span><span class=\"n\">PatchMerging</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i_layer</span> <span class=\"o\">&lt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_layers</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"kc\">None</span><span class=\"p\">,</span>\n        <span class=\"n\">use_checkpoint</span><span class=\"o\">=</span><span class=\"n\">use_checkpoint</span><span class=\"p\">,</span>\n        <span class=\"n\">norm_before_mlp</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm_before_mlp</span>\n    <span class=\"p\">)</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">layers</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">layer</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"101-progressione-gerarchica\">10.1 Progressione Gerarchica</h3>\n<p>Con <code>embed_dim=96</code> e <code>num_heads=[4, 8, 16, 32]</code>:</p>\n<table>\n<thead>\n<tr>\n<th>Stage</th>\n<th>Input Dim</th>\n<th>Num Blocks</th>\n<th>Num Heads</th>\n<th>Input Resolution</th>\n<th>Output Dim</th>\n<th>Output Resolution</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>1</td>\n<td>96</td>\n<td>2</td>\n<td>4</td>\n<td>(64, 64)</td>\n<td>192</td>\n<td>(32, 32)</td>\n</tr>\n<tr>\n<td>2</td>\n<td>192</td>\n<td>2</td>\n<td>8</td>\n<td>(32, 32)</td>\n<td>384</td>\n<td>(16, 16)</td>\n</tr>\n<tr>\n<td>3</td>\n<td>384</td>\n<td>6</td>\n<td>16</td>\n<td>(16, 16)</td>\n<td>768</td>\n<td>(8, 8)</td>\n</tr>\n<tr>\n<td>4</td>\n<td>768</td>\n<td>2</td>\n<td>32</td>\n<td>(8, 8)</td>\n<td>768</td>\n<td>(8, 8)</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Note importanti</strong>:\n- Ogni stage (tranne l&rsquo;ultimo) <strong>raddoppia</strong> il numero di canali\n- Ogni stage (tranne l&rsquo;ultimo) <strong>dimezza</strong> la risoluzione spaziale\n- Il numero di attention heads aumenta proporzionalmente ai canali\n- L&rsquo;ultimo stage non fa downsampling</p>\n<p><strong>Intuizione</strong>:\n- <strong>Elaborazione multi-scala</strong>: ogni stage cattura pattern a diversa granularità\n- <strong>Stage 1</strong>: feature di basso livello (texture locali, transizioni frequenziali)\n- <strong>Stage 2-3</strong>: feature di medio livello (pattern temporali, strutture armoniche)\n- <strong>Stage 4</strong>: feature di alto livello (rappresentazioni semantiche globali)</p>\n<h2 id=\"11-basiclayer-struttura-di-uno-stage\">11. BasicLayer: Struttura di uno Stage</h2>\n<p>Ogni <code>BasicLayer</code> contiene:\n1. Una sequenza di <code>SwinTransformerBlock</code> (es. 2, 2, 6, o 2 blocchi)\n2. Un layer di <code>PatchMerging</code> (tranne l&rsquo;ultimo stage)</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">BasicLayer</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">input_resolution</span><span class=\"p\">,</span> <span class=\"n\">depth</span><span class=\"p\">,</span> <span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blocks</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">ModuleList</span><span class=\"p\">([</span>\n            <span class=\"n\">SwinTransformerBlock</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span>\n            <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">depth</span><span class=\"p\">)</span>\n        <span class=\"p\">])</span>\n\n        <span class=\"k\">if</span> <span class=\"n\">downsample</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">downsample</span> <span class=\"o\">=</span> <span class=\"n\">downsample</span><span class=\"p\">(</span><span class=\"n\">input_resolution</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n        <span class=\"k\">else</span><span class=\"p\">:</span>\n            <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">downsample</span> <span class=\"o\">=</span> <span class=\"kc\">None</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"111-forward-pass-di-basiclayer\">11.1 Forward Pass di BasicLayer</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">attns</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n    <span class=\"k\">for</span> <span class=\"n\">blk</span> <span class=\"ow\">in</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blocks</span><span class=\"p\">:</span>\n        <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">blk</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n        <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">:</span>\n            <span class=\"n\">attns</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"n\">attn</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">))</span>\n\n    <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">downsample</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">downsample</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n    <span class=\"k\">if</span> <span class=\"ow\">not</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">training</span><span class=\"p\">:</span>\n        <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">cat</span><span class=\"p\">(</span><span class=\"n\">attns</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">mean</span><span class=\"p\">(</span><span class=\"n\">attn</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">attn</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Flusso</strong>:\n1. Passa attraverso tutti i blocchi Swin Transformer\n2. (Opzionale) Salva le attention maps per visualizzazione\n3. Applica PatchMerging per downsampling\n4. Restituisce output e attention maps aggregate</p>\n<h2 id=\"12-swintransformerblock-il-cuore-dellarchitettura\">12. SwinTransformerBlock: Il Cuore dell&rsquo;Architettura</h2>\n<p><img src=\"/images/posts/sw-mha.png\" alt=\"Immagine di un SwinTransformerBlock\" style=\"display: block; margin-left: auto; margin-right: auto;\"></p>\n<p>Il <code>SwinTransformerBlock</code> è l&rsquo;unità fondamentale di elaborazione, che implementa:\n1. <strong>Window-based Multi-head Self-Attention (W-MSA)</strong> o <strong>Shifted Window MSA (SW-MSA)</strong>\n2. <strong>Multi-Layer Perceptron (MLP)</strong>\n3. <strong>Residual connections</strong>\n4. <strong>Layer Normalization</strong></p>\n<h3 id=\"121-struttura-del-swintransformerblock\">12.1 Struttura del SwinTransformerBlock</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">SwinTransformerBlock</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">input_resolution</span><span class=\"p\">,</span> <span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"mi\">8</span><span class=\"p\">,</span> \n                 <span class=\"n\">shift_size</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">mlp_ratio</span><span class=\"o\">=</span><span class=\"mf\">4.</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"n\">dim</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">input_resolution</span> <span class=\"o\">=</span> <span class=\"n\">input_resolution</span>  <span class=\"c1\"># (H, W)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span> <span class=\"o\">=</span> <span class=\"n\">num_heads</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span> <span class=\"o\">=</span> <span class=\"n\">window_size</span>  <span class=\"c1\"># es. 8</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span> <span class=\"o\">=</span> <span class=\"n\">shift_size</span>    <span class=\"c1\"># 0 per W-MSA, window_size//2 per SW-MSA</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mlp_ratio</span> <span class=\"o\">=</span> <span class=\"n\">mlp_ratio</span>      <span class=\"c1\"># 4.0</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm1</span> <span class=\"o\">=</span> <span class=\"n\">norm_layer</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">WindowAttention</span><span class=\"p\">(</span>\n            <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"o\">=</span><span class=\"n\">to_2tuple</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">),</span> \n            <span class=\"n\">num_heads</span><span class=\"o\">=</span><span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"o\">...</span>\n        <span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop_path</span> <span class=\"o\">=</span> <span class=\"n\">DropPath</span><span class=\"p\">(</span><span class=\"n\">drop_path</span><span class=\"p\">)</span> <span class=\"k\">if</span> <span class=\"n\">drop_path</span> <span class=\"o\">&gt;</span> <span class=\"mf\">0.</span> <span class=\"k\">else</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Identity</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm2</span> <span class=\"o\">=</span> <span class=\"n\">norm_layer</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"p\">)</span>  <span class=\"c1\"># o BatchNorm1d se norm_before_mlp=&#39;bn&#39;</span>\n\n        <span class=\"n\">mlp_hidden_dim</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">dim</span> <span class=\"o\">*</span> <span class=\"n\">mlp_ratio</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mlp</span> <span class=\"o\">=</span> <span class=\"n\">Mlp</span><span class=\"p\">(</span><span class=\"n\">in_features</span><span class=\"o\">=</span><span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">hidden_features</span><span class=\"o\">=</span><span class=\"n\">mlp_hidden_dim</span><span class=\"p\">,</span> <span class=\"o\">...</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Parametri chiave</strong>:\n- <code>window_size</code>: dimensione della finestra locale (tipicamente 8)\n- <code>shift_size</code>: offset per shifted window (0 o <code>window_size//2</code>)\n- <code>mlp_ratio</code>: fattore di espansione del MLP (tipicamente 4)</p>\n<h3 id=\"122-alternanza-w-msa-e-sw-msa\">12.2 Alternanza W-MSA e SW-MSA</h3>\n<p>All&rsquo;interno di ogni <code>BasicLayer</code>, i blocchi alternano tra W-MSA e SW-MSA:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">blocks</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">ModuleList</span><span class=\"p\">([</span>\n    <span class=\"n\">SwinTransformerBlock</span><span class=\"p\">(</span>\n        <span class=\"o\">...</span><span class=\"p\">,</span>\n        <span class=\"n\">shift_size</span><span class=\"o\">=</span><span class=\"mi\">0</span> <span class=\"k\">if</span> <span class=\"p\">(</span><span class=\"n\">i</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">)</span> <span class=\"k\">else</span> <span class=\"n\">window_size</span> <span class=\"o\">//</span> <span class=\"mi\">2</span><span class=\"p\">,</span>\n        <span class=\"o\">...</span>\n    <span class=\"p\">)</span>\n    <span class=\"k\">for</span> <span class=\"n\">i</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">depth</span><span class=\"p\">)</span>\n<span class=\"p\">])</span>\n</code></pre></div>\n</div>\n</details>\n\n<ul>\n<li><strong>Blocco pari</strong> (<code>i=0, 2, 4, ...</code>): <code>shift_size=0</code> → <strong>W-MSA</strong> (window attention senza shift)</li>\n<li><strong>Blocco dispari</strong> (<code>i=1, 3, 5, ...</code>): <code>shift_size=window_size//2</code> → <strong>SW-MSA</strong> (shifted window attention)</li>\n</ul>\n<p><strong>Intuizione</strong>: L&rsquo;alternanza permette di catturare sia interazioni locali che cross-window, superando la limitazione delle finestre isolate.</p>\n<h3 id=\"123-forward-pass-del-swintransformerblock\">12.3 Forward Pass del SwinTransformerBlock</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">input_resolution</span>  <span class=\"c1\"># es. (64, 64) nel primo stage</span>\n    <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>             <span class=\"c1\"># es. (B, 4096, 96)</span>\n    <span class=\"c1\"># L deve essere = H * W</span>\n\n    <span class=\"n\">shortcut</span> <span class=\"o\">=</span> <span class=\"n\">x</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm1</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>  <span class=\"c1\"># reshape a formato spaziale 2D</span>\n\n    <span class=\"c1\"># Cyclic shift (solo per SW-MSA)</span>\n    <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">shifted_x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">roll</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">shifts</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">),</span> \n                               <span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">shifted_x</span> <span class=\"o\">=</span> <span class=\"n\">x</span>\n\n    <span class=\"c1\"># Partition windows</span>\n    <span class=\"n\">x_windows</span> <span class=\"o\">=</span> <span class=\"n\">window_partition</span><span class=\"p\">(</span><span class=\"n\">shifted_x</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (num_windows*B, window_size, window_size, C)</span>\n    <span class=\"n\">x_windows</span> <span class=\"o\">=</span> <span class=\"n\">x_windows</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (num_windows*B, window_size*window_size, C)</span>\n\n    <span class=\"c1\"># W-MSA/SW-MSA</span>\n    <span class=\"n\">attn_windows</span><span class=\"p\">,</span> <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attn</span><span class=\"p\">(</span><span class=\"n\">x_windows</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attn_mask</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Merge windows</span>\n    <span class=\"n\">attn_windows</span> <span class=\"o\">=</span> <span class=\"n\">attn_windows</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"n\">shifted_x</span> <span class=\"o\">=</span> <span class=\"n\">window_reverse</span><span class=\"p\">(</span><span class=\"n\">attn_windows</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Reverse cyclic shift (solo per SW-MSA)</span>\n    <span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">roll</span><span class=\"p\">(</span><span class=\"n\">shifted_x</span><span class=\"p\">,</span> <span class=\"n\">shifts</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">),</span> \n                       <span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">shifted_x</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span> <span class=\"o\">*</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Residual connection + DropPath</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">shortcut</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop_path</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># FFN (MLP)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span> <span class=\"o\">+</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop_path</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">mlp</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm2</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)))</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">attn</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Flusso dettagliato</strong>:\n1. <strong>Layer Norm 1</strong> + reshape a 2D\n2. <strong>Cyclic shift</strong> (solo SW-MSA)\n3. <strong>Window partition</strong> (divisione in finestre)\n4. <strong>Window Attention</strong>\n5. <strong>Window merge</strong> (ricostruzione)\n6. <strong>Reverse shift</strong> (solo SW-MSA)\n7. <strong>Residual connection 1</strong> con DropPath\n8. <strong>Layer Norm 2</strong> + <strong>MLP</strong>\n9. <strong>Residual connection 2</strong> con DropPath</p>\n<h3 id=\"123-forward-pass-concettuale\">12.3 Forward Pass (concettuale)</h3>\n<p>Flusso chiave (concettuale, senza codice):\n1. LayerNorm su x_in\n2. (eventuale) cyclic shift per SW-MSA\n3. partition in finestre\n4. window-attention su ogni finestra\n5. merge delle finestre e reverse shift\n6. residual connection + DropPath (output dell&rsquo;attenzione)\n7. LayerNorm + MLP\n8. residual connection + DropPath (output finale del blocco)</p>\n<h3 id=\"124-formula-semplificata-versione-leggibile\">12.4 Formula semplificata (versione leggibile)</h3>\n<p>Versione con dettagli di normalizzazione e DropPath:</p>\n$$\n\\boxed{%\nx_{\\text{out}} = x_{\\text{in}} \\;+\\; \\text{DropPath}\\big(\\text{SW-MSA}(\\text{LN}(x_{\\text{in}}))\\big)\n\\;+\\; \\text{DropPath}\\big(\\text{MLP}(\\text{LN}(x_{\\text{in}} + \\text{SW-MSA}(\\text{LN}(x_{\\text{in}}))))\\big)\n}\n$$\n<p>Versione ancora più sintetica e intuitiva:</p>\n$$\n\\boxed{%\nx_{\\text{out}} = x_{\\text{in}} \\;+\\; \\text{Attn}(x_{\\text{in}}) \\;+\\; \\text{MLP}\\big(x_{\\text{in}} + \\text{Attn}(x_{\\text{in}})\\big)\n}\n$$\n<p><strong>Dove:</strong>\n- $\\text{LN}$ = Layer Normalization\n- $\\text{SW-MSA}$ = Shifted Window Multi-Head Self-Attention (o W-MSA quando non c&rsquo;è shift)\n- $\\text{Attn}(x_{\\text{in}})$ è una abbreviazione per $\\text{SW-MSA}(\\text{LN}(x_{\\text{in}}))$\n- $\\text{DropPath}(\\cdot)$ = stochastic depth (residual dropout)\n- $\\text{MLP}(\\cdot)$ = feed-forward (due linear + attivazione)</p>\n<p>Queste formule riassumono il comportamento operativo del blocco: l&rsquo;output è la somma residua dell&rsquo;input più l&rsquo;aggiornamento apportato dall&rsquo;attenzione locale e dal successivo MLP di raffinamento.</p>\n<h2 id=\"13-window-partition-e-reverse\">13. Window Partition e Reverse</h2>\n<h3 id=\"131-window-partition\">13.1 Window Partition</h3>\n<p>Divide l&rsquo;input 2D in finestre non sovrapposte:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">window_partition</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        x: (B, H, W, C)</span>\n<span class=\"sd\">        window_size: int (es. 8)</span>\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        windows: (num_windows*B, window_size, window_size, C)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span> <span class=\"o\">//</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> \n               <span class=\"n\">W</span> <span class=\"o\">//</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"n\">windows</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>\n    <span class=\"n\">windows</span> <span class=\"o\">=</span> <span class=\"n\">windows</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">windows</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Esempio con H=64, W=64, window_size=8</strong>:</p>\n<p>Input: $(B, 64, 64, C)$</p>\n<p>Step 1: Reshape\n$$\nx \\rightarrow (B, 8, 8, 8, 8, C)\n$$</p>\n<p>Step 2: Permute per raggruppare le finestre\n$$\nx \\rightarrow (B, 8, 8, 8, 8, C) \\text{ (posizioni: 0,1,3,2,4,5)}\n$$</p>\n<p>Step 3: View per collassare le finestre\n$\nx \\rightarrow (B \\cdot 64, 8, 8, C)\n$</p>\n<p>dove $64 = (64/8) \\times (64/8) = 8 \\times 8$ è il numero di finestre.</p>\n<p><strong>Output</strong>: $(num_windows \\cdot B, window_size, window_size, C)$ con $num_windows = 64$</p>\n<p><strong>Intuizione</strong>: L&rsquo;immagine viene divisa in una griglia di finestre $8 \\times 8$, ognuna contenente $8 \\times 8 = 64$ token. L&rsquo;attention sarà calcolata indipendentemente all&rsquo;interno di ogni finestra.</p>\n<h3 id=\"132-window-reverse\">13.2 Window Reverse</h3>\n<p>Ricostruisce l&rsquo;immagine 2D dalle finestre:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">window_reverse</span><span class=\"p\">(</span><span class=\"n\">windows</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        windows: (num_windows*B, window_size, window_size, C)</span>\n<span class=\"sd\">        window_size: int</span>\n<span class=\"sd\">        H, W: altezza e larghezza dell&#39;immagine originale</span>\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        x: (B, H, W, C)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">B</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"n\">windows</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">H</span> <span class=\"o\">*</span> <span class=\"n\">W</span> <span class=\"o\">/</span> <span class=\"n\">window_size</span> <span class=\"o\">/</span> <span class=\"n\">window_size</span><span class=\"p\">))</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">windows</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span> <span class=\"o\">//</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">W</span> <span class=\"o\">//</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> \n                     <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"mi\">5</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Inverte esattamente le operazioni di <code>window_partition</code>.</p>\n<h2 id=\"14-windowattention-self-attention-locale\">14. WindowAttention: Self-Attention Locale</h2>\n<p>Il modulo <code>WindowAttention</code> implementa la <strong>multi-head self-attention</strong> all&rsquo;interno di ogni finestra, con l&rsquo;aggiunta cruciale del <strong>relative position bias</strong>.</p>\n<h3 id=\"141-struttura-del-windowattention\">14.1 Struttura del WindowAttention</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">WindowAttention</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"n\">qkv_bias</span><span class=\"o\">=</span><span class=\"kc\">True</span><span class=\"p\">,</span> \n                 <span class=\"n\">qk_scale</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">attn_drop</span><span class=\"o\">=</span><span class=\"mf\">0.</span><span class=\"p\">,</span> <span class=\"n\">proj_drop</span><span class=\"o\">=</span><span class=\"mf\">0.</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"n\">dim</span>                      <span class=\"c1\"># es. 96</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span> <span class=\"o\">=</span> <span class=\"n\">window_size</span>      <span class=\"c1\"># (8, 8)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span> <span class=\"o\">=</span> <span class=\"n\">num_heads</span>          <span class=\"c1\"># es. 4</span>\n        <span class=\"n\">head_dim</span> <span class=\"o\">=</span> <span class=\"n\">dim</span> <span class=\"o\">//</span> <span class=\"n\">num_heads</span>         <span class=\"c1\"># 96 // 4 = 24</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">scale</span> <span class=\"o\">=</span> <span class=\"n\">qk_scale</span> <span class=\"ow\">or</span> <span class=\"n\">head_dim</span> <span class=\"o\">**</span> <span class=\"o\">-</span><span class=\"mf\">0.5</span>  <span class=\"c1\"># 1/sqrt(24) ≈ 0.204</span>\n\n        <span class=\"c1\"># Relative position bias table</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">relative_position_bias_table</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Parameter</span><span class=\"p\">(</span>\n            <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">),</span> \n                        <span class=\"n\">num_heads</span><span class=\"p\">)</span>\n        <span class=\"p\">)</span>  <span class=\"c1\"># (15*15, num_heads) = (225, 4)</span>\n\n        <span class=\"c1\"># QKV projection</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">qkv</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">dim</span> <span class=\"o\">*</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"n\">bias</span><span class=\"o\">=</span><span class=\"n\">qkv_bias</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attn_drop</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Dropout</span><span class=\"p\">(</span><span class=\"n\">attn_drop</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">proj</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">proj_drop</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Dropout</span><span class=\"p\">(</span><span class=\"n\">proj_drop</span><span class=\"p\">)</span>\n\n        <span class=\"c1\"># Initialize relative position bias</span>\n        <span class=\"n\">trunc_normal_</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">relative_position_bias_table</span><span class=\"p\">,</span> <span class=\"n\">std</span><span class=\"o\">=</span><span class=\"mf\">.02</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">softmax</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Softmax</span><span class=\"p\">(</span><span class=\"n\">dim</span><span class=\"o\">=-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"142-relative-position-bias-calcolo-degli-indici\">14.2 Relative Position Bias: Calcolo degli Indici</h3>\n<p>Il relative position bias è un&rsquo;innovazione chiave di Swin Transformer. Invece di usare position embedding assoluti, usa bias <strong>relativi</strong> che dipendono dalla distanza tra token.</p>\n<p><strong>Inizializzazione degli indici</strong> (fatto una volta nel costruttore):</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">coords_h</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">])</span>  <span class=\"c1\"># [0, 1, 2, ..., 7]</span>\n<span class=\"n\">coords_w</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">arange</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>  <span class=\"c1\"># [0, 1, 2, ..., 7]</span>\n<span class=\"n\">coords</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">stack</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">meshgrid</span><span class=\"p\">([</span><span class=\"n\">coords_h</span><span class=\"p\">,</span> <span class=\"n\">coords_w</span><span class=\"p\">]))</span>  <span class=\"c1\"># (2, 8, 8)</span>\n<span class=\"n\">coords_flatten</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">coords</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># (2, 64)</span>\n\n<span class=\"c1\"># Calcola coordinate relative per ogni coppia di posizioni</span>\n<span class=\"n\">relative_coords</span> <span class=\"o\">=</span> <span class=\"n\">coords_flatten</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"kc\">None</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">coords_flatten</span><span class=\"p\">[:,</span> <span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"p\">:]</span>\n<span class=\"c1\"># (2, 64, 64)</span>\n\n<span class=\"n\">relative_coords</span> <span class=\"o\">=</span> <span class=\"n\">relative_coords</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>\n<span class=\"c1\"># (64, 64, 2)</span>\n\n<span class=\"c1\"># Shift per rendere le coordinate positive</span>\n<span class=\"n\">relative_coords</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>  <span class=\"c1\"># +7</span>\n<span class=\"n\">relative_coords</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">+=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>  <span class=\"c1\"># +7</span>\n\n<span class=\"c1\"># Conversione a indice 1D</span>\n<span class=\"n\">relative_coords</span><span class=\"p\">[:,</span> <span class=\"p\">:,</span> <span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*=</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span>  <span class=\"c1\"># *15</span>\n<span class=\"n\">relative_position_index</span> <span class=\"o\">=</span> <span class=\"n\">relative_coords</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># (64, 64)</span>\n\n<span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">register_buffer</span><span class=\"p\">(</span><span class=\"s2\">&quot;relative_position_index&quot;</span><span class=\"p\">,</span> <span class=\"n\">relative_position_index</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione del calcolo</strong>:\n- Per ogni coppia di posizioni $(i, j)$ nella finestra $8 \\times 8$, calcola la loro posizione relativa\n- La posizione relativa varia da $-7$ a $+7$ in entrambe le dimensioni\n- Dopo lo shift: varia da $0$ a $14$ (totale 15 valori)\n- L&rsquo;indice 1D varia da $0$ a $224$ (totale $15 \\times 15 = 225$ possibili offset)\n- <code>relative_position_index[i, j]</code> contiene l&rsquo;indice nella tabella dei bias per la coppia $(i,j)$</p>\n<h3 id=\"143-forward-pass-del-windowattention\">14.3 Forward Pass del WindowAttention</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">mask</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        x: (num_windows*B, N, C) dove N = window_size * window_size = 64</span>\n<span class=\"sd\">        mask: (num_windows, N, N) o None</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">B_</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># es. (64*B, 64, 96)</span>\n\n    <span class=\"c1\"># Step 1: Compute Q, K, V</span>\n    <span class=\"n\">qkv</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">qkv</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># (B_, N, 3*C) = (64*B, 64, 288)</span>\n    <span class=\"n\">qkv</span> <span class=\"o\">=</span> <span class=\"n\">qkv</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B_</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (64*B, 64, 3, 4, 24)</span>\n    <span class=\"n\">qkv</span> <span class=\"o\">=</span> <span class=\"n\">qkv</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (3, 64*B, 4, 64, 24)</span>\n\n    <span class=\"n\">q</span><span class=\"p\">,</span> <span class=\"n\">k</span><span class=\"p\">,</span> <span class=\"n\">v</span> <span class=\"o\">=</span> <span class=\"n\">qkv</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">],</span> <span class=\"n\">qkv</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"n\">qkv</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n    <span class=\"c1\"># Ciascuno: (64*B, 4, 64, 24)</span>\n\n    <span class=\"c1\"># Step 2: Scaled dot-product attention</span>\n    <span class=\"n\">q</span> <span class=\"o\">=</span> <span class=\"n\">q</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">scale</span>  <span class=\"c1\"># Scale by 1/sqrt(d_k)</span>\n    <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">q</span> <span class=\"o\">@</span> <span class=\"n\">k</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">))</span>  <span class=\"c1\"># (64*B, 4, 64, 64)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Matematica della self-attention</strong>:</p>\n<p>Per ogni head $h$:</p>\n<p>$\n\\text{Attention}(Q_h, K_h, V_h) = \\text{softmax}\\left(\\frac{Q_h K_h^T}{\\sqrt{d_k}} + B\\right) V_h\n$</p>\n<p>dove:\n- $Q_h, K_h, V_h \\in \\mathbb{R}^{N \\times d_k}$ con $N=64$, $d_k=24$\n- $B \\in \\mathbb{R}^{N \\times N}$ è il relative position bias\n- $\\sqrt{d_k} = \\sqrt{24} \\approx 4.899$</p>\n<p><strong>Step 3: Aggiungi Relative Position Bias</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"c1\"># Retrieve relative position bias</span>\n    <span class=\"n\">relative_position_bias</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">relative_position_bias_table</span><span class=\"p\">[</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">relative_position_index</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"p\">]</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> \n           <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (64, 64, num_heads) = (64, 64, 4)</span>\n\n    <span class=\"n\">relative_position_bias</span> <span class=\"o\">=</span> <span class=\"n\">relative_position_bias</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>\n    <span class=\"c1\"># (4, 64, 64)</span>\n\n    <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">attn</span> <span class=\"o\">+</span> <span class=\"n\">relative_position_bias</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (64*B, 4, 64, 64) + (1, 4, 64, 64)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione del relative position bias</strong>:\n- Ogni coppia di posizioni $(i,j)$ ha un bias apprendibile diverso per ogni head\n- Il bias dipende solo dalla <strong>distanza relativa</strong>, non dalla posizione assoluta\n- Questo permette alla rete di apprendere preferenze per interazioni a diverse distanze\n- Ad esempio: un head potrebbe imparare a dare più peso a token vicini, un altro a token lontani</p>\n<p><strong>Step 4: Maschera per Shifted Window (opzionale)</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"k\">if</span> <span class=\"n\">mask</span> <span class=\"ow\">is</span> <span class=\"ow\">not</span> <span class=\"kc\">None</span><span class=\"p\">:</span>\n        <span class=\"n\">nW</span> <span class=\"o\">=</span> <span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>  <span class=\"c1\"># numero di finestre</span>\n        <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">attn</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B_</span> <span class=\"o\">//</span> <span class=\"n\">nW</span><span class=\"p\">,</span> <span class=\"n\">nW</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">)</span> <span class=\"o\">+</span> \\\n               <span class=\"n\">mask</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">)</span>\n        <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"n\">attn</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_heads</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">)</span>\n        <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">softmax</span><span class=\"p\">(</span><span class=\"n\">attn</span><span class=\"p\">)</span>\n    <span class=\"k\">else</span><span class=\"p\">:</span>\n        <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">softmax</span><span class=\"p\">(</span><span class=\"n\">attn</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>La maschera è usata solo in SW-MSA per impedire l&rsquo;attenzione tra token di finestre originali diverse (dopo lo shift).</p>\n<p><strong>Step 5: Applica Attention e Proietta</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"n\">attn</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">attn_drop</span><span class=\"p\">(</span><span class=\"n\">attn</span><span class=\"p\">)</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">attn</span> <span class=\"o\">@</span> <span class=\"n\">v</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B_</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (64*B, 4, 64, 24) @ (64*B, 4, 64, 24) → (64*B, 4, 64, 24)</span>\n    <span class=\"c1\"># transpose → (64*B, 64, 4, 24)</span>\n    <span class=\"c1\"># reshape → (64*B, 64, 96)</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">proj</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>      <span class=\"c1\"># Linear projection</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">proj_drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">attn</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Output</strong>: \n- $x \\in \\mathbb{R}^{B' \\times 64 \\times 96}$ dove $B' = num_windows \\cdot B$\n- $attn \\in \\mathbb{R}^{B' \\times 4 \\times 64 \\times 64}$ (attention weights)</p>\n<p><strong>Intuizione complessiva del WindowAttention</strong>:\n- Ogni finestra di $8 \\times 8 = 64$ token viene elaborata indipendentemente\n- La multi-head attention permette di catturare diversi tipi di relazioni\n- Il relative position bias aggiunge informazione spaziale senza position embedding globali\n- Questo design è molto più efficiente della global attention ($O(N^2)$ vs $O(n \\cdot (N/n)^2)$ dove $n$ è il numero di finestre)</p>\n<h2 id=\"15-shifted-window-attention-sw-msa\">15. Shifted Window Attention (SW-MSA)</h2>\n<p>Il problema del W-MSA è che le finestre sono isolate: non c&rsquo;è comunicazione tra finestre diverse. La <strong>Shifted Window Attention</strong> risolve questo problema.</p>\n<h3 id=\"151-cyclic-shift\">15.1 Cyclic Shift</h3>\n<p>Per i blocchi con <code>shift_size = window_size // 2 = 4</code>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n    <span class=\"n\">shifted_x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">roll</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">shifts</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">),</span> \n                           <span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Operazione</strong>:</p>\n<p>$\n\\text{shifted_x}[b, h, w, c] = x[b, (h + 4) \\mod H, (w + 4) \\mod W, c]\n$</p>\n<p><strong>Visualizzazione dello shift</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>Prima dello shift:         Dopo shift di (-4, -4):\n┌─────┬─────┐             ┌─────┬─────┐\n│  A  │  B  │             │  D  │  C  │\n│     │     │             │     │     │\n├─────┼─────┤      →      ├─────┼─────┤\n│  C  │  D  │             │  B  │  A  │\n│     │     │             │     │     │\n└─────┴─────┘             └─────┴─────┘\n</code></pre></div>\n</div>\n</details>\n\n<p>Ogni lettera rappresenta una finestra $8 \\times 8$.</p>\n<p><strong>Intuizione dello shift</strong>:\n- Dopo lo shift, le nuove finestre contengono parti di <strong>4 finestre originali diverse</strong>\n- Questo permette la comunicazione cross-window\n- Il cyclic shift è computazionalmente gratuito (solo reindexing)</p>\n<h3 id=\"152-attention-mask-per-sw-msa\">15.2 Attention Mask per SW-MSA</h3>\n<p>Il problema: dopo lo shift, ogni nuova finestra contiene token da finestre originali diverse. Vogliamo permettere attenzione solo tra token della <strong>stessa finestra originale</strong>.</p>\n<p><strong>Creazione della maschera</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n    <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">input_resolution</span>\n    <span class=\"n\">img_mask</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">zeros</span><span class=\"p\">((</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>  <span class=\"c1\"># (1, 64, 64, 1)</span>\n\n    <span class=\"n\">h_slices</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">),</span>\n                <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">),</span>\n                <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">))</span>\n    <span class=\"n\">w_slices</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">),</span>\n                <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">),</span>\n                <span class=\"nb\">slice</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">,</span> <span class=\"kc\">None</span><span class=\"p\">))</span>\n\n    <span class=\"n\">cnt</span> <span class=\"o\">=</span> <span class=\"mi\">0</span>\n    <span class=\"k\">for</span> <span class=\"n\">h</span> <span class=\"ow\">in</span> <span class=\"n\">h_slices</span><span class=\"p\">:</span>\n        <span class=\"k\">for</span> <span class=\"n\">w</span> <span class=\"ow\">in</span> <span class=\"n\">w_slices</span><span class=\"p\">:</span>\n            <span class=\"n\">img_mask</span><span class=\"p\">[:,</span> <span class=\"n\">h</span><span class=\"p\">,</span> <span class=\"n\">w</span><span class=\"p\">,</span> <span class=\"p\">:]</span> <span class=\"o\">=</span> <span class=\"n\">cnt</span>\n            <span class=\"n\">cnt</span> <span class=\"o\">+=</span> <span class=\"mi\">1</span>\n\n    <span class=\"c1\"># img_mask ora contiene 9 regioni numerate da 0 a 8</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Visualizzazione della maschera</strong> (con window_size=8, shift_size=4, per una griglia 64x64):</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>┌───────┬───┬───────┬───┐\n│   0   │ 1 │   2   │ 3 │\n│       │   │       │   │\n├───────┼───┼───────┼───┤\n│   4   │ 5 │   6   │ 7 │\n├───────┼───┼───────┼───┤\n│   8   │ 9 │  10   │11 │\n│       │   │       │   │\n├───────┼───┼───────┼───┤\n│  12   │13 │  14   │15 │\n└───────┴───┴───────┴───┘\n</code></pre></div>\n</div>\n</details>\n\n<p>Ogni numero identifica una regione della finestra originale.</p>\n<p><strong>Conversione a maschera di attenzione</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>    <span class=\"n\">mask_windows</span> <span class=\"o\">=</span> <span class=\"n\">window_partition</span><span class=\"p\">(</span><span class=\"n\">img_mask</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (num_windows, window_size*window_size, 1)</span>\n    <span class=\"n\">mask_windows</span> <span class=\"o\">=</span> <span class=\"n\">mask_windows</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">window_size</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (num_windows, 64)</span>\n\n    <span class=\"n\">attn_mask</span> <span class=\"o\">=</span> <span class=\"n\">mask_windows</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"n\">mask_windows</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">2</span><span class=\"p\">)</span>\n    <span class=\"c1\"># (num_windows, 64, 64)</span>\n\n    <span class=\"n\">attn_mask</span> <span class=\"o\">=</span> <span class=\"n\">attn_mask</span><span class=\"o\">.</span><span class=\"n\">masked_fill</span><span class=\"p\">(</span><span class=\"n\">attn_mask</span> <span class=\"o\">!=</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"o\">-</span><span class=\"mf\">100.0</span><span class=\"p\">))</span>\n    <span class=\"n\">attn_mask</span> <span class=\"o\">=</span> <span class=\"n\">attn_mask</span><span class=\"o\">.</span><span class=\"n\">masked_fill</span><span class=\"p\">(</span><span class=\"n\">attn_mask</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"nb\">float</span><span class=\"p\">(</span><span class=\"mf\">0.0</span><span class=\"p\">))</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Risultato</strong>:\n- $\\text{attn_mask}[w, i, j] = 0$ se i token $i$ e $j$ provengono dalla stessa regione originale\n- $\\text{attn_mask}[w, i, j] = -100$ altrimenti</p>\n<p>Quando questo viene aggiunto ai logits di attenzione prima del softmax, i valori $-100$ diventano effettivamente $0$ dopo il softmax (mascheratura dell&rsquo;attenzione).</p>\n<h3 id=\"153-reverse-cyclic-shift\">15.3 Reverse Cyclic Shift</h3>\n<p>Dopo l&rsquo;attenzione, lo shift viene invertito:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">roll</span><span class=\"p\">(</span><span class=\"n\">shifted_x</span><span class=\"p\">,</span> <span class=\"n\">shifts</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">shift_size</span><span class=\"p\">),</span> \n                   <span class=\"n\">dims</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Questo riporta i token alle loro posizioni originali.</p>\n<p><strong>Intuizione complessiva di SW-MSA</strong>:\n- Lo shift permette la comunicazione tra finestre diverse\n- La maschera garantisce che ogni token attenda solo a token della stessa finestra originale\n- L&rsquo;alternanza W-MSA/SW-MSA crea connessioni sia locali che cross-window\n- Questo design mantiene l&rsquo;efficienza computazionale di W-MSA ma supera la limitazione delle finestre isolate</p>\n<h2 id=\"16-multi-layer-perceptron-mlp\">16. Multi-Layer Perceptron (MLP)</h2>\n<p>Dopo ogni attention block, c&rsquo;è un MLP per elaborazione non-lineare:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">Mlp</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">in_features</span><span class=\"p\">,</span> <span class=\"n\">hidden_features</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> <span class=\"n\">out_features</span><span class=\"o\">=</span><span class=\"kc\">None</span><span class=\"p\">,</span> \n                 <span class=\"n\">act_layer</span><span class=\"o\">=</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">GELU</span><span class=\"p\">,</span> <span class=\"n\">drop</span><span class=\"o\">=</span><span class=\"mf\">0.</span><span class=\"p\">):</span>\n        <span class=\"n\">out_features</span> <span class=\"o\">=</span> <span class=\"n\">out_features</span> <span class=\"ow\">or</span> <span class=\"n\">in_features</span>\n        <span class=\"n\">hidden_features</span> <span class=\"o\">=</span> <span class=\"n\">hidden_features</span> <span class=\"ow\">or</span> <span class=\"n\">in_features</span>\n\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc1</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"n\">in_features</span><span class=\"p\">,</span> <span class=\"n\">hidden_features</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">act</span> <span class=\"o\">=</span> <span class=\"n\">act_layer</span><span class=\"p\">()</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc2</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"n\">hidden_features</span><span class=\"p\">,</span> <span class=\"n\">out_features</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Dropout</span><span class=\"p\">(</span><span class=\"n\">drop</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Forward pass</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc1</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>       <span class=\"c1\"># (B, N, C) → (B, N, 4*C)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">act</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>       <span class=\"c1\"># GELU activation</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">fc2</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>       <span class=\"c1\"># (B, N, 4*C) → (B, N, C)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">drop</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"k\">return</span> <span class=\"n\">x</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Con mlp_ratio=4 e dim=96</strong>:</p>\n<p>$\n\\mathbf{x} \\in \\mathbb{R}^{B \\times N \\times 96} \\xrightarrow{\\text{fc1}} \\mathbb{R}^{B \\times N \\times 384} \\xrightarrow{\\text{GELU}} \\mathbb{R}^{B \\times N \\times 384} \\xrightarrow{\\text{fc2}} \\mathbb{R}^{B \\times N \\times 96}\n$</p>\n<p><strong>GELU (Gaussian Error Linear Unit)</strong>:</p>\n<p>$\n\\text{GELU}(x) = x \\cdot \\Phi(x) = x \\cdot \\frac{1}{2}\\left[1 + \\text{erf}\\left(\\frac{x}{\\sqrt{2}}\\right)\\right]\n$</p>\n<p>dove $\\Phi(x)$ è la CDF della distribuzione normale standard.</p>\n<p><strong>Intuizione</strong>:\n- Il MLP espande le feature a 4x la dimensione originale (bottleneck invertito)\n- GELU introduce non-linearità smooth (simile a ReLU ma più morbido)\n- Dropout per regolarizzazione\n- Ogni token viene elaborato indipendentemente (elaborazione point-wise)</p>\n<h2 id=\"17-patchmerging-downsampling-gerarchico\">17. PatchMerging: Downsampling Gerarchico</h2>\n<p>Al termine di ogni stage (tranne l&rsquo;ultimo), <code>PatchMerging</code> riduce la risoluzione spaziale e aumenta i canali.</p>\n<h3 id=\"171-struttura-del-patchmerging\">17.1 Struttura del PatchMerging</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">class</span><span class=\"w\"> </span><span class=\"nc\">PatchMerging</span><span class=\"p\">(</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Module</span><span class=\"p\">):</span>\n    <span class=\"k\">def</span><span class=\"w\"> </span><span class=\"fm\">__init__</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">input_resolution</span><span class=\"p\">,</span> <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">norm_layer</span><span class=\"o\">=</span><span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">LayerNorm</span><span class=\"p\">):</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">input_resolution</span> <span class=\"o\">=</span> <span class=\"n\">input_resolution</span>  <span class=\"c1\"># (H, W)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">dim</span> <span class=\"o\">=</span> <span class=\"n\">dim</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reduction</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"mi\">2</span> <span class=\"o\">*</span> <span class=\"n\">dim</span><span class=\"p\">,</span> <span class=\"n\">bias</span><span class=\"o\">=</span><span class=\"kc\">False</span><span class=\"p\">)</span>\n        <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm</span> <span class=\"o\">=</span> <span class=\"n\">norm_layer</span><span class=\"p\">(</span><span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"n\">dim</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"172-forward-pass-del-patchmerging\">17.2 Forward Pass del PatchMerging</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">forward</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    x: (B, H*W, C)</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">input_resolution</span>\n    <span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">L</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n    <span class=\"k\">assert</span> <span class=\"n\">L</span> <span class=\"o\">==</span> <span class=\"n\">H</span> <span class=\"o\">*</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"s2\">&quot;input feature has wrong size&quot;</span>\n    <span class=\"k\">assert</span> <span class=\"n\">H</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"ow\">and</span> <span class=\"n\">W</span> <span class=\"o\">%</span> <span class=\"mi\">2</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"s2\">&quot;H and W must be even&quot;</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">H</span><span class=\"p\">,</span> <span class=\"n\">W</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Estrai 4 sottogriglie con stride 2</span>\n    <span class=\"n\">x0</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># top-left: (B, H/2, W/2, C)</span>\n    <span class=\"n\">x1</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[:,</span> <span class=\"mi\">1</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">0</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># bottom-left: (B, H/2, W/2, C)</span>\n    <span class=\"n\">x2</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[:,</span> <span class=\"mi\">0</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># top-right: (B, H/2, W/2, C)</span>\n    <span class=\"n\">x3</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"p\">[:,</span> <span class=\"mi\">1</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">::</span><span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">:]</span>  <span class=\"c1\"># bottom-right: (B, H/2, W/2, C)</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">cat</span><span class=\"p\">([</span><span class=\"n\">x0</span><span class=\"p\">,</span> <span class=\"n\">x1</span><span class=\"p\">,</span> <span class=\"n\">x2</span><span class=\"p\">,</span> <span class=\"n\">x3</span><span class=\"p\">],</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, H/2, W/2, 4*C)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">view</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">4</span> <span class=\"o\">*</span> <span class=\"n\">C</span><span class=\"p\">)</span>             <span class=\"c1\"># (B, H/2*W/2, 4*C)</span>\n\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reduction</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>                <span class=\"c1\"># (B, H/2*W/2, 2*C)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">x</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Visualizzazione</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>Input (H, W, C):           Output (H/2, W/2, 2*C):\n┌───┬───┬───┬───┐         ┌───────┬───────┐\n│ 0 │ 2 │ 0 │ 2 │         │  0123 │  0123 │\n├───┼───┼───┼───┤   →     │concat │concat │\n│ 1 │ 3 │ 1 │ 3 │         ├───────┼───────┤\n├───┼───┼───┼───┤         │  0123 │  0123 │\n│ 0 │ 2 │ 0 │ 2 │         │concat │concat │\n├───┼───┼───┼───┤         └───────┴───────┘\n│ 1 │ 3 │ 1 │ 3 │\n└───┴───┴───┴───┘\n</code></pre></div>\n</div>\n</details>\n\n<p>Ogni gruppo di 4 patch (0,1,2,3) viene concatenato e poi proiettato.</p>\n<p><strong>Matematica</strong>:</p>\n<p>Input: $\\mathbf{x} \\in \\mathbb{R}^{B \\times HW \\times C}$</p>\n<p>Dopo concatenazione: $\\mathbf{x}_{cat} \\in \\mathbb{R}^{B \\times \\frac{HW}{4} \\times 4C}$</p>\n<p>Dopo proiezione lineare:</p>\n<p>$\n\\mathbf{x}_{out} = \\text{LayerNorm}(\\mathbf{x}_{cat}) \\cdot \\mathbf{W}_{reduction}\n$</p>\n<p>dove $\\mathbf{W}_{reduction} \\in \\mathbb{R}^{4C \\times 2C}$.</p>\n<p>Output: $\\mathbf{x}_{out} \\in \\mathbb{R}^{B \\times \\frac{HW}{4} \\times 2C}$</p>\n<p><strong>Esempio con Stage 1 → Stage 2</strong>:\n- Input: $(B, 4096, 96)$ con risoluzione $(64, 64)$\n- Dopo PatchMerging: $(B, 1024, 192)$ con risoluzione $(32, 32)$</p>\n<p><strong>Intuizione</strong>:\n- Riduce risoluzione di 2x in entrambe le dimensioni (downsampling 4x totale)\n- Raddoppia il numero di canali (da $C$ a $2C$)\n- Simile al pooling nelle CNN ma apprendibile\n- Permette elaborazione gerarchica: feature più astratte a risoluzioni più basse</p>\n<h2 id=\"18-elaborazione-completa-attraverso-i-4-stage\">18. Elaborazione Completa attraverso i 4 Stage</h2>\n<p><img src=\"/images/posts/HTS-AT-swin.png\" alt=\"Elaborazione attraverso i 4 Stage\" style=\"display: block; margin-left: auto; margin-right: auto;\"></p>\n<p>Riassumiamo il flusso attraverso l&rsquo;intera architettura con un esempio concreto.</p>\n<p><strong>Configurazione</strong>: <code>embed_dim=96</code>, <code>depths=[2,2,6,2]</code>, <code>num_heads=[4,8,16,32]</code>, <code>window_size=8</code></p>\n<h3 id=\"stage-1-feature-di-basso-livello\">Stage 1: Feature di Basso Livello</h3>\n<p><strong>Input</strong>: $(B, 4096, 96)$ con risoluzione $(64, 64)$</p>\n<p><strong>Blocco 1</strong> (W-MSA):\n- Window partition: $64 \\times 64 \\rightarrow 64$ finestre $8 \\times 8$\n- WindowAttention con 4 heads\n- MLP con espansione 4x\n- Output: $(B, 4096, 96)$</p>\n<p><strong>Blocco 2</strong> (SW-MSA):\n- Cyclic shift di $(-4, -4)$\n- Window partition con maschera\n- WindowAttention con 4 heads\n- Reverse shift\n- MLP\n- Output: $(B, 4096, 96)$</p>\n<p><strong>PatchMerging</strong>:\n- Output: $(B, 1024, 192)$ con risoluzione $(32, 32)$</p>\n<p><strong>Intuizione Stage 1</strong>: Cattura pattern locali e texture di base dello spettrogramma.</p>\n<h3 id=\"stage-2-feature-di-medio-basso-livello\">Stage 2: Feature di Medio-Basso Livello</h3>\n<p><strong>Input</strong>: $(B, 1024, 192)$ con risoluzione $(32, 32)$</p>\n<p><strong>Blocco 1</strong> (W-MSA):\n- $32 \\times 32 \\rightarrow 16$ finestre $8 \\times 8$\n- WindowAttention con 8 heads\n- Output: $(B, 1024, 192)$</p>\n<p><strong>Blocco 2</strong> (SW-MSA):\n- Shift + attention + reverse\n- WindowAttention con 8 heads\n- Output: $(B, 1024, 192)$</p>\n<p><strong>PatchMerging</strong>:\n- Output: $(B, 256, 384)$ con risoluzione $(16, 16)$</p>\n<p><strong>Intuizione Stage 2</strong>: Inizia a catturare relazioni temporali e pattern armonici.</p>\n<h3 id=\"stage-3-feature-di-alto-livello\">Stage 3: Feature di Alto Livello</h3>\n<p><strong>Input</strong>: $(B, 256, 384)$ con risoluzione $(16, 16)$</p>\n<p><strong>6 Blocchi alternati</strong> (W-MSA, SW-MSA, W-MSA, SW-MSA, W-MSA, SW-MSA):\n- $16 \\times 16 \\rightarrow 4$ finestre $8 \\times 8$\n- WindowAttention con 16 heads\n- Output dopo 6 blocchi: $(B, 256, 384)$</p>\n<p><strong>PatchMerging</strong>:\n- Output: $(B, 64, 768)$ con risoluzione $(8, 8)$</p>\n<p><strong>Intuizione Stage 3</strong>: Stage più profondo che cattura dipendenze semantiche complesse e pattern a lungo raggio.</p>\n<h3 id=\"stage-4-feature-semantiche-globali\">Stage 4: Feature Semantiche Globali</h3>\n<p><strong>Input</strong>: $(B, 64, 768)$ con risoluzione $(8, 8)$</p>\n<p><strong>Blocco 1</strong> (W-MSA):\n- $8 \\times 8 \\rightarrow 1$ finestra $8 \\times 8$\n- WindowAttention con 32 heads (global attention!)\n- Output: $(B, 64, 768)$</p>\n<p><strong>Blocco 2</strong> (SW-MSA):\n- Con risoluzione $8 \\times 8$ e window_size $8$, lo shift non ha effetto pratico\n- Output: $(B, 64, 768)$</p>\n<p><strong>Nessun PatchMerging</strong> (ultimo stage)</p>\n<p><strong>Output finale dopo normalization</strong>: $(B, 64, 768)$</p>\n<p><strong>Intuizione Stage 4</strong>: Con solo 1 finestra, questo stage fa effettivamente <strong>global attention</strong> su tutta la rappresentazione compressa, catturando il context semantico completo.</p>\n<h2 id=\"19-classificazione-tscam-token-semantic-convolutional-attention-map\">19. Classificazione: TSCAM (Token-Semantic Convolutional Attention Map)</h2>\n<p>Dopo i 4 stage, HTS-AT usa un approccio innovativo chiamato <strong>TSCAM</strong> per la classificazione.</p>\n<h3 id=\"191-configurazione-tscam\">19.1 Configurazione TSCAM</h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">config</span><span class=\"o\">.</span><span class=\"n\">enable_tscam</span><span class=\"p\">:</span>\n    <span class=\"n\">SF</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">//</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span>\n    <span class=\"c1\"># SF = 256 // 8 // 4 // 4 = 2</span>\n\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tscam_conv</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Conv2d</span><span class=\"p\">(</span>\n        <span class=\"n\">in_channels</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_features</span><span class=\"p\">,</span>     <span class=\"c1\"># 768</span>\n        <span class=\"n\">out_channels</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_classes</span><span class=\"p\">,</span>     <span class=\"c1\"># es. 527</span>\n        <span class=\"n\">kernel_size</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">SF</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">),</span>               <span class=\"c1\"># (2, 3)</span>\n        <span class=\"n\">padding</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"p\">)</span>\n    <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">head</span> <span class=\"o\">=</span> <span class=\"n\">nn</span><span class=\"o\">.</span><span class=\"n\">Linear</span><span class=\"p\">(</span><span class=\"n\">num_classes</span><span class=\"p\">,</span> <span class=\"n\">num_classes</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<h3 id=\"192-forward-pass-con-tscam\">19.2 Forward Pass con TSCAM</h3>\n<p><strong>Input</strong>: $\\mathbf{x} \\in \\mathbb{R}^{B \\times 64 \\times 768}$ dopo l&rsquo;ultimo stage</p>\n<p><strong>Step 1: Layer Normalization</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># LayerNorm(768)</span>\n<span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">N</span><span class=\"p\">,</span> <span class=\"n\">C</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># (B, 64, 768)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Step 2: Reshape a formato spaziale 2D</strong>:</p>\n<p>Ricordiamo che <code>frames_num</code> è il numero di frame temporali originali dello spettrogramma (prima del reshape_wav2img). Con configurazione tipica:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">SF</span> <span class=\"o\">=</span> <span class=\"n\">frames_num</span> <span class=\"o\">//</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">0</span><span class=\"p\">]</span>\n<span class=\"c1\"># frames_num / 8 / 4</span>\n<span class=\"n\">ST</span> <span class=\"o\">=</span> <span class=\"n\">frames_num</span> <span class=\"o\">//</span> <span class=\"p\">(</span><span class=\"mi\">2</span> <span class=\"o\">**</span> <span class=\"p\">(</span><span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">depths</span><span class=\"p\">)</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">))</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">]</span>\n<span class=\"c1\"># frames_num / 8 / 4</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">SF</span><span class=\"p\">,</span> <span class=\"n\">ST</span><span class=\"p\">)</span>\n<span class=\"c1\"># (B, 768, SF, ST)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Con <code>frames_num = 1024</code> (dopo interpolazione):\n- $SF = 1024 / 8 / 4 = 32$\n- $ST = 1024 / 8 / 4 = 32$</p>\n<p>Quindi: $\\mathbf{x} \\in \\mathbb{R}^{B \\times 768 \\times 32 \\times 32}$</p>\n<p><strong>Nota</strong>: Questo non corrisponde alla risoluzione $(8, 8)$ dell&rsquo;ultimo stage! Il reshape utilizza <code>frames_num</code> (numero di frame temporali dello spettrogramma originale dopo interpolazione) per ricostruire la struttura spazio-temporale originale, non la risoluzione ridotta dei token dopo i stage.</p>\n<p><strong>Step 3: Group 2D CNN (Frequency Grouping)</strong>:</p>\n<p>Il codice raggruppa le feature lungo la dimensione di frequenza usando <code>freq_ratio</code>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">F</span><span class=\"p\">,</span> <span class=\"n\">T</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span>  <span class=\"c1\"># (B, 768, 32, 32)</span>\n<span class=\"n\">c_freq_bin</span> <span class=\"o\">=</span> <span class=\"n\">F</span> <span class=\"o\">//</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span>  <span class=\"c1\"># 32 // 4 = 8</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">F</span> <span class=\"o\">//</span> <span class=\"n\">c_freq_bin</span><span class=\"p\">,</span> <span class=\"n\">c_freq_bin</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"p\">)</span>\n<span class=\"c1\"># (B, 768, 4, 8, 32)</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">3</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">4</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">()</span>\n<span class=\"c1\"># (B, 768, 8, 4, 32)</span>\n\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">reshape</span><span class=\"p\">(</span><span class=\"n\">B</span><span class=\"p\">,</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">c_freq_bin</span><span class=\"p\">,</span> <span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\"># (B, 768, 8, 128)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione del grouping</strong>:\n- Raggruppa le 32 bande di frequenza in 8 &ldquo;meta-bande&rdquo; di 4 bande ciascuna\n- Riorganizza la dimensione temporale: da $(4, 32)$ a $(128)$\n- Risultato: $(B, 768, 8, 128)$ dove 8 è il numero di bande frequenziali aggregate e 128 è la dimensione temporale estesa</p>\n<p><strong>Step 4: Latent Output (Embedding)</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">latent_output</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">avgpool</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>\n<span class=\"c1\"># flatten(x, 2): (B, 768, 8, 128) → (B, 768, 1024)</span>\n<span class=\"c1\"># avgpool: (B, 768, 1024) → (B, 768, 1)</span>\n<span class=\"n\">latent_output</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">latent_output</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"c1\"># (B, 768)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Questo è l&rsquo;<strong>embedding</strong> che verrà restituito come rappresentazione densa dell&rsquo;audio.</p>\n<p><strong>Step 5: TSCAM Convolution</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">tscam_conv</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 768, 8, 128) → (B, 527, 6, 128)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>La convoluzione con kernel $(2, 3)$ e padding $(0, 1)$:</p>\n<p>$\nF_{out} = \\frac{8 - 2 + 2 \\cdot 0}{1} + 1 = 7 \\quad \\text{(ma viene troncato a 6)}\n$</p>\n<p>$\nT_{out} = \\frac{128 - 3 + 2 \\cdot 1}{1} + 1 = 128\n$</p>\n<p>Output: $(B, 527, 6, 128)$ dove 527 è il numero di classi (AudioSet).</p>\n<p><strong>Step 6: Flatten e Interpolazione Temporale</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 527, 6, 128) → (B, 527, 768)</span>\n\n<span class=\"c1\"># Interpolazione temporale per frame-wise prediction</span>\n<span class=\"n\">fpx</span> <span class=\"o\">=</span> <span class=\"n\">interpolate</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">permute</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span><span class=\"o\">.</span><span class=\"n\">contiguous</span><span class=\"p\">(),</span> \n                  <span class=\"mi\">8</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">patch_stride</span><span class=\"p\">[</span><span class=\"mi\">1</span><span class=\"p\">])</span>\n<span class=\"c1\"># Interpola da 768 frame a 8 * 4 = 32 frame (o altro target)</span>\n<span class=\"c1\"># Output: (B, target_frames, 527)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione dell&rsquo;interpolazione</strong>:\n- L&rsquo;output viene interpolato alla risoluzione temporale desiderata per le predizioni frame-wise\n- <code>8 * self.patch_stride[1]</code> calcola il numero di frame target basato sulla configurazione\n- Questo permette di avere predizioni temporali dettagliate per il rilevamento di eventi</p>\n<p><strong>Step 7: Pooling Temporale per Clip-wise Output</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">avgpool</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 527, 768) → (B, 527, 1)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 527)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Step 8: Output Finale</strong>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">output_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">&#39;framewise_output&#39;</span><span class=\"p\">:</span> <span class=\"n\">fpx</span><span class=\"p\">,</span>              <span class=\"c1\"># (B, target_frames, 527)</span>\n    <span class=\"s1\">&#39;clipwise_output&#39;</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">),</span>  <span class=\"c1\"># (B, 527)</span>\n    <span class=\"s1\">&#39;latent_output&#39;</span><span class=\"p\">:</span> <span class=\"n\">latent_output</span>        <span class=\"c1\"># (B, 768)</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione complessiva del TSCAM</strong>:\n- <strong>Token</strong>: rappresentazioni locali tempo-frequenza (dai Swin Transformer blocks)\n- <strong>Semantic</strong>: la convoluzione aggrega semanticamente le informazioni\n- <strong>Convolutional Attention Map</strong>: crea mappe di attenzione per ogni classe\n- Il design permette sia predizioni clip-wise (intero audio) che frame-wise (temporalmente risolte)\n- Questo è essenziale per task di sound event detection dove serve sapere <em>quando</em> avviene un evento</p>\n<h3 id=\"193-alternative-classificazione-senza-tscam\">19.3 Alternative: Classificazione Senza TSCAM</h3>\n<p>Se <code>enable_tscam=False</code>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 64, 768)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">avgpool</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">transpose</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">2</span><span class=\"p\">))</span>  <span class=\"c1\"># (B, 768, 1)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">flatten</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 768)</span>\n\n<span class=\"k\">if</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">num_classes</span> <span class=\"o\">&gt;</span> <span class=\"mi\">0</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">head</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># Linear(768 → 527)</span>\n\n<span class=\"n\">output_dict</span> <span class=\"o\">=</span> <span class=\"p\">{</span>\n    <span class=\"s1\">&#39;clipwise_output&#39;</span><span class=\"p\">:</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">sigmoid</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>  <span class=\"c1\"># (B, 527)</span>\n<span class=\"p\">}</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Questo è un approccio più semplice: global average pooling + layer fully connected.</p>\n<h2 id=\"20-gestione-di-audio-di-lunghezza-variabile\">20. Gestione di Audio di Lunghezza Variabile</h2>\n<p>HTS-AT implementa diverse strategie per gestire audio di lunghezza variabile, specialmente durante l&rsquo;inferenza.</p>\n<h3 id=\"201-modalita-repeat\">20.1 Modalità Repeat</h3>\n<p>Con <code>config.enable_repeat_mode=True</code>:</p>\n<p><strong>Training</strong>: Selezione casuale di una posizione e ripetizione:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">cur_pos</span> <span class=\"o\">=</span> <span class=\"n\">random</span><span class=\"o\">.</span><span class=\"n\">randint</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">repeat_wat2img</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">cur_pos</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Inference</strong>: Elaborazione multipla e media:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">output_dicts</span> <span class=\"o\">=</span> <span class=\"p\">[]</span>\n<span class=\"k\">for</span> <span class=\"n\">cur_pos</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span><span class=\"p\">):</span>\n    <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">clone</span><span class=\"p\">()</span>\n    <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">repeat_wat2img</span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">,</span> <span class=\"n\">cur_pos</span><span class=\"p\">)</span>\n    <span class=\"n\">output_dicts</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">forward_features</span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Media delle predizioni</span>\n<span class=\"n\">clipwise_output</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s2\">&quot;clipwise_output&quot;</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">output_dicts</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">output_dicts</span><span class=\"p\">)</span>\n<span class=\"n\">framewise_output</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"n\">d</span><span class=\"p\">[</span><span class=\"s2\">&quot;framewise_output&quot;</span><span class=\"p\">]</span> <span class=\"k\">for</span> <span class=\"n\">d</span> <span class=\"ow\">in</span> <span class=\"n\">output_dicts</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">output_dicts</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione</strong>: Elabora l&rsquo;audio da diverse &ldquo;prospettive temporali&rdquo; e fa la media per robustezza.</p>\n<h3 id=\"202-modalita-crop-default\">20.2 Modalità Crop (Default)</h3>\n<p>Per audio più lunghi del target:</p>\n<p><strong>Training</strong>: Crop casuale:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">if</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">&gt;</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span><span class=\"p\">:</span>\n    <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">crop_wav</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">crop_size</span><span class=\"o\">=</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Inference</strong>: Crop sovrapposti con media:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">overlap_size</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"mi\">4</span>\n<span class=\"n\">crop_size</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">)</span> <span class=\"o\">//</span> <span class=\"mi\">2</span>\n\n<span class=\"k\">for</span> <span class=\"n\">cur_pos</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span> <span class=\"o\">-</span> <span class=\"n\">crop_size</span> <span class=\"o\">-</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">overlap_size</span><span class=\"p\">):</span>\n    <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">crop_wav</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">,</span> <span class=\"n\">crop_size</span><span class=\"o\">=</span><span class=\"n\">crop_size</span><span class=\"p\">,</span> <span class=\"n\">spe_pos</span><span class=\"o\">=</span><span class=\"n\">cur_pos</span><span class=\"p\">)</span>\n    <span class=\"n\">tx</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reshape_wav2img</span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">)</span>\n    <span class=\"n\">output_dicts</span><span class=\"o\">.</span><span class=\"n\">append</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">forward_features</span><span class=\"p\">(</span><span class=\"n\">tx</span><span class=\"p\">))</span>\n\n<span class=\"c1\"># Media delle predizioni</span>\n<span class=\"n\">clipwise_output</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">output_dicts</span><span class=\"p\">)</span>\n<span class=\"n\">framewise_output</span> <span class=\"o\">=</span> <span class=\"nb\">sum</span><span class=\"p\">(</span><span class=\"o\">...</span><span class=\"p\">)</span> <span class=\"o\">/</span> <span class=\"nb\">len</span><span class=\"p\">(</span><span class=\"n\">output_dicts</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione</strong>: Per audio lunghi, elabora segmenti sovrapposti e fa ensemble delle predizioni.</p>\n<h3 id=\"203-modalita-infer\">20.3 Modalità Infer</h3>\n<p>Con <code>infer_mode=True</code>:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"n\">frame_num</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">shape</span><span class=\"p\">[</span><span class=\"mi\">2</span><span class=\"p\">]</span>\n<span class=\"n\">target_T</span> <span class=\"o\">=</span> <span class=\"nb\">int</span><span class=\"p\">(</span><span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">spec_size</span> <span class=\"o\">*</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">freq_ratio</span><span class=\"p\">)</span>\n<span class=\"n\">repeat_ratio</span> <span class=\"o\">=</span> <span class=\"n\">math</span><span class=\"o\">.</span><span class=\"n\">floor</span><span class=\"p\">(</span><span class=\"n\">target_T</span> <span class=\"o\">/</span> <span class=\"n\">frame_num</span><span class=\"p\">)</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"n\">x</span><span class=\"o\">.</span><span class=\"n\">repeat</span><span class=\"p\">(</span><span class=\"n\">repeats</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"n\">repeat_ratio</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">))</span>\n<span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">reshape_wav2img</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n<span class=\"n\">output_dict</span> <span class=\"o\">=</span> <span class=\"bp\">self</span><span class=\"o\">.</span><span class=\"n\">forward_features</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">)</span>\n</code></pre></div>\n</div>\n</details>\n\n<p><strong>Intuizione</strong>: Per audio corti, ripete i frame per raggiungere la lunghezza target.</p>\n<h2 id=\"21-architettura-completa-visualizzazione-del-flusso\">21. Architettura Completa: Visualizzazione del Flusso</h2>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>Input Audio (B, N_samples)\n    ↓\nSTFT → Power Spectrogram (B, 1, T_frames, 513)\n    ↓\nMel Filterbank → Log-Mel (B, 1, T_frames, 64)\n    ↓\nBatchNorm2d(64) [con transpose]\n    ↓\nSpecAugmentation + Mixup [training only]\n    ↓\nReshape to Image (B, 1, 256, 256)\n    ↓\n╔══════════════════════════════════════════════════╗\n║             PATCH EMBEDDING                      ║\n║  Conv2d(1→96, kernel=4, stride=4)               ║\n║  Output: (B, 4096, 96)  [64×64 patches]         ║\n╚══════════════════════════════════════════════════╝\n    ↓\nPosition Embedding [optional] + Dropout\n    ↓\n╔══════════════════════════════════════════════════╗\n║              STAGE 1: (64×64, 96)                ║\n║  ┌────────────────────────────────────────┐     ║\n║  │ SwinBlock 1 (W-MSA, 4 heads)           │     ║\n║  │   • Window Partition (8×8 windows)     │     ║\n║  │   • WindowAttention + Rel. Pos. Bias   │     ║\n║  │   • MLP (96 → 384 → 96)                │     ║\n║  └────────────────────────────────────────┘     ║\n║  ┌────────────────────────────────────────┐     ║\n║  │ SwinBlock 2 (SW-MSA, 4 heads)          │     ║\n║  │   • Cyclic Shift (-4, -4)              │     ║\n║  │   • Masked WindowAttention             │     ║\n║  │   • Reverse Shift                      │     ║\n║  │   • MLP (96 → 384 → 96)                │     ║\n║  └────────────────────────────────────────┘     ║\n║  PatchMerging: (B, 4096, 96) → (B, 1024, 192)   ║\n╚══════════════════════════════════════════════════╝\n    ↓\n╔══════════════════════════════════════════════════╗\n║              STAGE 2: (32×32, 192)               ║\n║  2× SwinBlocks (W-MSA, SW-MSA) 8 heads          ║\n║  PatchMerging: (B, 1024, 192) → (B, 256, 384)   ║\n╚══════════════════════════════════════════════════╝\n    ↓\n╔══════════════════════════════════════════════════╗\n║              STAGE 3: (16×16, 384)               ║\n║  6× SwinBlocks alternati, 16 heads              ║\n║  PatchMerging: (B, 256, 384) → (B, 64, 768)     ║\n╚══════════════════════════════════════════════════╝\n    ↓\n╔══════════════════════════════════════════════════╗\n║              STAGE 4: (8×8, 768)                 ║\n║  2× SwinBlocks (global attention) 32 heads      ║\n║  No PatchMerging                                 ║\n║  Output: (B, 64, 768)                            ║\n╚══════════════════════════════════════════════════╝\n    ↓\nLayerNorm(768)\n    ↓\n╔══════════════════════════════════════════════════╗\n║              TSCAM HEAD                          ║\n║  Reshape → (B, 768, 8, 128)                     ║\n║  Conv2d(768→527, kernel=(2,3))                  ║\n║  ├─→ AvgPool → Clipwise (B, 527)                ║\n║  └─→ Interpolate → Framewise (B, T, 527)       ║\n╚══════════════════════════════════════════════════╝\n    ↓\nOutput: {\n  &#39;clipwise_output&#39;: (B, 527),    # predizioni per clip\n  &#39;framewise_output&#39;: (B, T, 527), # predizioni temporali\n  &#39;latent_output&#39;: (B, 768)        # embedding\n}\n</code></pre></div>\n</div>\n</details>\n\n<h2 id=\"22-differenze-chiave-tra-hts-at-e-cnn14\">22. Differenze Chiave tra HTS-AT e CNN14</h2>\n<table>\n<thead>\n<tr>\n<th>Aspetto</th>\n<th>CNN14</th>\n<th>HTS-AT</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Architettura base</strong></td>\n<td>Convolutional Neural Network</td>\n<td>Vision Transformer (Swin)</td>\n</tr>\n<tr>\n<td><strong>Receptive field</strong></td>\n<td>Locale, aumenta gradualmente</td>\n<td>Global tramite self-attention</td>\n</tr>\n<tr>\n<td><strong>Inductive bias</strong></td>\n<td>Forte (località, traslazione)</td>\n<td>Debole (appreso dai dati)</td>\n</tr>\n<tr>\n<td><strong>Complessità</strong></td>\n<td>$O(N)$</td>\n<td>$O(N)$ grazie a windowed attention</td>\n</tr>\n<tr>\n<td><strong>Parametri</strong></td>\n<td>~80M</td>\n<td>Variabile (tipicamente 30-90M)</td>\n</tr>\n<tr>\n<td><strong>Feature extraction</strong></td>\n<td>Convoluzione gerarchica</td>\n<td>Self-attention gerarchica</td>\n</tr>\n<tr>\n<td><strong>Position encoding</strong></td>\n<td>Implicito (convoluzione)</td>\n<td>Explicit (relative position bias)</td>\n</tr>\n<tr>\n<td><strong>Long-range dependencies</strong></td>\n<td>Limitato</td>\n<td>Eccellente</td>\n</tr>\n<tr>\n<td><strong>Output</strong></td>\n<td>Solo clip-wise</td>\n<td>Clip-wise + frame-wise</td>\n</tr>\n</tbody>\n</table>\n<h2 id=\"23-punti-di-forza-di-hts-at\">23. Punti di Forza di HTS-AT</h2>\n<h3 id=\"231-attention-mechanism\">23.1 Attention Mechanism</h3>\n<p><strong>Vantaggio</strong>: Cattura dipendenze a lungo raggio nello spettrogramma.</p>\n<p><strong>Esempio pratico</strong>: In musica, può collegare note distanti che fanno parte della stessa melodia. Nelle registrazioni ambientali, può associare eventi sonori correlati ma temporalmente separati.</p>\n<h3 id=\"232-hierarchical-processing\">23.2 Hierarchical Processing</h3>\n<p><strong>Vantaggio</strong>: Elaborazione multi-scala naturale attraverso i 4 stage.</p>\n<ul>\n<li>Stage 1-2: Texture e pattern locali</li>\n<li>Stage 3: Strutture temporali complesse</li>\n<li>Stage 4: Context semantico globale</li>\n</ul>\n<h3 id=\"233-tscam-per-frame-wise-prediction\">23.3 TSCAM per Frame-wise Prediction</h3>\n<p><strong>Vantaggio</strong>: Output temporalmente risolto per sound event detection.</p>\n<p><strong>Utilizzo</strong>: Non solo &ldquo;questo audio contiene un cane che abbaia&rdquo;, ma &ldquo;il cane abbaia dal secondo 2.5 al secondo 4.8&rdquo;.</p>\n<h3 id=\"234-relative-position-bias\">23.4 Relative Position Bias</h3>\n<p><strong>Vantaggio</strong>: Encoding posizionale più flessibile rispetto agli absolute position embedding.</p>\n<p><strong>Beneficio</strong>: Il modello impara preferenze per distanze relative (es. &ldquo;guarda i token a distanza 3&rdquo;) piuttosto che posizioni assolute.</p>\n<h3 id=\"235-efficient-windowed-attention\">23.5 Efficient Windowed Attention</h3>\n<p><strong>Vantaggio</strong>: Complessità lineare rispetto alla lunghezza della sequenza.</p>\n<ul>\n<li>Global self-attention: $O(N^2)$ dove $N$ è il numero di token</li>\n<li>Windowed attention: $O(N \\cdot M)$ dove $M$ è la dimensione della finestra (costante)</li>\n</ul>\n<p>Con $N = 4096$ e $M = 64$, il risparmio computazionale è enorme.</p>\n<h2 id=\"24-considerazioni-pratiche\">24. Considerazioni Pratiche</h2>\n<h3 id=\"241-requisiti-computazionali\">24.1 Requisiti Computazionali</h3>\n<ul>\n<li><strong>Memoria GPU</strong>: Richiede più memoria di CNN14 per il training (attention matrices)</li>\n<li><strong>Velocità di inferenza</strong>: Comparabile a CNN14 per audio singoli, più lenta per batch grandi</li>\n<li><strong>Training time</strong>: Generalmente più lungo per convergenza</li>\n</ul>\n<h3 id=\"242-transfer-learning\">24.2 Transfer Learning</h3>\n<p>HTS-AT può utilizzare <strong>checkpoint pre-trained</strong> da Swin Transformer per computer vision:</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"c1\"># I pesi dei Swin Transformer blocks possono essere inizializzati</span>\n<span class=\"c1\"># da modelli pre-trained su ImageNet</span>\n</code></pre></div>\n</div>\n</details>\n\n<p>Questo accelera significativamente il training per task audio-specifici.</p>\n<h3 id=\"243-data-augmentation\">24.3 Data Augmentation</h3>\n<p>La combinazione di SpecAugmentation e Mixup è cruciale:</p>\n<ul>\n<li><strong>SpecAugmentation</strong>: Previene overfitting su specifiche regioni tempo-frequenza</li>\n<li><strong>Mixup</strong>: Migliora generalizzazione e calibrazione delle probabilità</li>\n</ul>\n<h3 id=\"244-hyperparameter-tuning\">24.4 Hyperparameter Tuning</h3>\n<p>Parametri critici:\n- <code>window_size</code>: Trade-off tra local vs global attention (tipicamente 8)\n- <code>depths</code>: Profondità di ogni stage (tipicamente [2,2,6,2])\n- <code>embed_dim</code>: Dimensione base degli embedding (tipicamente 96)\n- <code>num_heads</code>: Numero di attention heads per stage (tipicamente [4,8,16,32])</p>\n<h2 id=\"25-conclusioni\">25. Conclusioni</h2>\n<p>HTS-AT rappresenta un&rsquo;evoluzione significativa nell&rsquo;elaborazione audio tramite deep learning:</p>\n<ol>\n<li><strong>Self-attention gerarchica</strong> permette di catturare dipendenze complesse a diverse scale temporali</li>\n<li><strong>Windowed attention</strong> mantiene l&rsquo;efficienza computazionale</li>\n<li><strong>TSCAM</strong> fornisce output temporalmente risolti essenziali per event detection</li>\n<li><strong>Relative position bias</strong> offre encoding posizionale flessibile</li>\n<li><strong>Architettura modulare</strong> facilita transfer learning e customizzazione</li>\n</ol>\n<p>L&rsquo;architettura è particolarmente efficace per:\n- Sound event detection (localizzazione temporale)\n- Audio tagging multi-label\n- Music information retrieval\n- Environmental sound classification</p>\n<p>La complessità aggiuntiva rispetto a CNN14 è giustificata quando il task richiede:\n- Comprensione di context a lungo raggio\n- Localizzazione temporale precisa degli eventi\n- Handling di relazioni complesse nello spettrogramma</p>\n<p><strong>Trade-off finale</strong>: HTS-AT offre maggiore espressività e flessibilità a costo di maggiore complessità computazionale e necessità di più dati per il training.</p>"
}