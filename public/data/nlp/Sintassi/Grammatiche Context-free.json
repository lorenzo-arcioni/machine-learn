{
  "title": "Grammatiche libere dal contesto (CFG)",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<p>Le <strong>grammatiche libere dal contesto</strong> (in inglese <em>Context-Free Grammars</em>, CFG) sono una sottoclasse delle grammatiche formali ampiamente utilizzata per rappresentare la sintassi dei linguaggi naturali e dei linguaggi di programmazione.</p>\n<p>Sono chiamate <em>libere dal contesto</em> perch√© le regole di produzione si applicano indipendentemente dal contesto in cui si trova il simbolo non terminale.</p>\n<h2 id=\"definizione-formale\">üìê Definizione formale</h2>\n<p>Una grammatica libera dal contesto √® una quadrupla:</p>\n$$\nG = (N, T, P, S)\n$$\n<p>dove:</p>\n<ul>\n<li>$N$ √® l&rsquo;insieme dei simboli <em>non terminali</em> (categorie sintattiche come frasi o sintagmi)</li>\n<li>$T$ √® l&rsquo;insieme dei simboli <em>terminali</em> (le parole o i simboli del lessico)</li>\n<li>$P$ √® l&rsquo;insieme delle <em>produzioni</em> o <em>regole</em> della forma $A \\rightarrow \\alpha$, con $A \\in N$ e $\\alpha \\in (N \\cup T)^*$. Quindi $P \\subseteq N \\times ((N \\cup T)^*)$, con $A \\in N$.</li>\n<li>$S$ √® il simbolo iniziale, da cui parte la derivazione. Quindi, $S \\in N \\land \\exists(S, \\beta) \\in P \\land \\beta = \\epsilon$.</li>\n</ul>\n<h2 id=\"esempio-pratico-di-cfg\">üß† Esempio pratico di CFG</h2>\n<p>Considera la seguente grammatica:</p>\n$$\n\\begin{align*}\n  N & = \\{ S, NP, Nom, Det, Noun \\} \\\\\n  T & = \\{ \\text{a}, \\text{the}, \\text{winter}, \\text{night} \\} \\\\\n  P & = \\{\\\\\n  &\\quad S     \\rightarrow NP,\\\\\n  &\\quad NP    \\rightarrow Det\\ Nom,\\\\\n  &\\quad Nom   \\rightarrow Noun \\mid Nom\\ Noun,\\\\\n  &\\quad Det   \\rightarrow \\text{a} \\mid \\text{the},\\\\\n  &\\quad Noun  \\rightarrow \\text{winter},\\\\\n  &\\quad Noun  \\rightarrow \\text{night}\\\\\n  \\}\\\\\n  S & = S\n\\end{align*}\n$$\n<p>Con questa grammatica possiamo generare frasi come:</p>\n<ul>\n<li><em>the winter</em></li>\n</ul>\n<p><img src=\"/images/tikz/0b7274dea633ee2a22e28408698abbb4.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>\n<ul>\n<li><em>a night</em></li>\n</ul>\n<p><img src=\"/images/tikz/e86264129766ca5c4fb2071894c9d9fe.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>\n<ul>\n<li><em>the winter night</em></li>\n</ul>\n<p><img src=\"/images/tikz/7dde49430529afeb60ef72caf403ac76.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>\n<h2 id=\"linguaggio-generato-da-una-grammatica-math_inline_18\">Linguaggio generato da una grammatica ($L(G)$)</h2>\n<p>Il linguaggio generato da una grammatica $G = (N, T, P, S)$ √® definito come:</p>\n$$\nL(G) = \\{ w \\in T^* \\mid S \\Rightarrow^{*} w \\}\n$$\n<p>Ovvero: l&rsquo;insieme di tutte le stringhe composte solo da simboli terminali che possono essere derivate dal simbolo iniziale $S$, applicando una sequenza di produzioni.</p>\n<p>Se $G$ √® una grammatica libera dal contesto, allora $L(G)$ √® un <strong>linguaggio libero dal contesto</strong>.</p>\n<h2 id=\"forma-normale-di-chomsky-cnf\">Forma Normale di Chomsky (CNF)</h2>\n<p>Una grammatica √® in <strong>forma normale di Chomsky (Chomsky Normal Form)</strong> se tutte le produzioni hanno una delle due forme seguenti:</p>\n<ul>\n<li>$A \\rightarrow B\\ C$, con $A, B, C \\in N$</li>\n<li>$A \\rightarrow a$, con $A \\in N, a \\in T$</li>\n</ul>\n<p>Non sono permesse produzioni vuote ($\\epsilon$-free) e la struttura generata √® sempre <strong>binaria</strong> (alberi binari).</p>\n<p>Qualsiasi grammatica libera dal contesto pu√≤ essere convertita in una <strong>CNF equivalente</strong> (in modo <em>weakly equivalent</em>), ad esempio:</p>\n$$\nA \\rightarrow B\\ C\\ D \\quad \\Rightarrow \\quad\nA \\rightarrow B\\ X,\\quad X \\rightarrow C\\ D\n$$\n<p>üëâ Vedi anche: <a href=\"/theory/nlp/Sintassi/Forma Normale di Chomsky\" class=\"text-blue-600 hover:underline\">Forma Normale di Chomsky</a></p>\n<h2 id=\"grammatiche-a-dipendenze\">Grammatiche a dipendenze</h2>\n<p>Le <strong>grammatiche a dipendenze</strong> rappresentano le relazioni sintattiche (e talvolta semantiche) tra le parole di una frase, senza l&rsquo;uso di costituenti frasali (NP, VP&hellip;).</p>\n<ul>\n<li>Le produzioni sono <strong>relazioni tra parole</strong></li>\n<li>Gli archi tra parole sono etichettati (es. <code>nsubj</code>, <code>det</code>, <code>dobj</code>, &hellip;), formando un <strong>grafo orientato</strong></li>\n<li>Non si utilizzano simboli non terminali</li>\n</ul>\n<h3 id=\"vantaggi\">Vantaggi</h3>\n<ul>\n<li>Maggiore flessibilit√† per lingue con <strong>ordine libero</strong> delle parole (es. italiano, ceco)</li>\n<li>Riduce la complessit√† delle regole rispetto ai costituenti</li>\n</ul>\n<h3 id=\"esempio-they-did-the-right-thing\">Esempio: <em>&ldquo;They did the right thing&rdquo;</em></h3>\n<p><img src=\"/images/tikz/454268bba13ecf6c5b8502365372f9c4.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>\n<h3 id=\"relazioni-sintattiche\">Relazioni sintattiche</h3>\n<p>Nell&rsquo;albero disegnato per la frase <strong>&ldquo;They did the right thing&rdquo;</strong>, ogni nodo rappresenta una parola e ogni freccia indica una relazione di dipendenza <strong>lessicale</strong> e <strong>sintattica</strong> tra due parole. Le etichette sopra le frecce specificano il tipo di relazione.</p>\n<ul>\n<li>\n<p><strong>Nodo principale (radice)</strong>: <code>did</code> √® il verbo principale della frase e funge da radice dell&rsquo;albero.</p>\n</li>\n<li>\n<p><strong>nsubj (nominal subject)</strong>: <code>they</code> √® il soggetto nominale del verbo <code>did</code>. La freccia va da <code>did</code> a <code>they</code> con etichetta <code>nsubj</code>.</p>\n</li>\n<li>\n<p><strong>dobj (direct object)</strong>: <code>thing</code> √® il complemento oggetto diretto del verbo <code>did</code>. La freccia va da <code>did</code> a <code>thing</code> con etichetta <code>dobj</code>.</p>\n</li>\n<li>\n<p><strong>det (determiner)</strong>: <code>the</code> √® un determinante (articolo) che modifica il sostantivo <code>thing</code>. La freccia va da <code>thing</code> a <code>the</code> con etichetta <code>det</code>.</p>\n</li>\n<li>\n<p><strong>mod (modifier)</strong>: <code>right</code> √® un modificatore (aggettivo) che specifica ulteriormente <code>thing</code>. La freccia va da <code>thing</code> a <code>right</code> con etichetta <code>mod</code>.</p>\n</li>\n</ul>\n<h4 id=\"struttura-gerarchica\">Struttura gerarchica</h4>\n<ul>\n<li><code>did</code> √® al vertice dell&rsquo;albero</li>\n<li><code>they</code> √® collegato come soggetto (<code>nsubj</code>)</li>\n<li><code>thing</code> √® collegato come oggetto (<code>dobj</code>)<ul>\n<li><code>thing</code> ha come figli <code>the</code> (<code>det</code>) e <code>right</code> (<code>mod</code>)</li>\n</ul>\n</li>\n</ul>\n<p>In sintesi, la struttura mostra come <strong>&ldquo;they&rdquo;</strong> compie l&rsquo;azione <strong>&ldquo;did&rdquo;</strong>, e l&rsquo;azione ha come oggetto diretto <strong>&ldquo;thing&rdquo;</strong>, che √® ulteriormente descritto da <strong>&ldquo;the&rdquo;</strong> e <strong>&ldquo;right&rdquo;</strong>.</p>\n<p>Le strutture delle grammatiche a dipendenze <strong>non dipendono dall&rsquo;ordine delle parole</strong>.</p>\n<p>Questa rappresentazione evita nodi astratti (come NP o VP) e si concentra sulle <strong>relazioni dirette tra le parole</strong>, facilitando l‚Äôanalisi del significato e l‚Äôelaborazione automatica del linguaggio.</p>\n<h2 id=\"treebank-e-universal-dependencies\">Treebank e Universal Dependencies</h2>\n<ul>\n<li>Un <strong>treebank</strong> √® un corpus di frasi annotate con alberi di analisi sintattica. L&rsquo;esempio pi√π noto √® il <strong>Penn Treebank</strong>, che include:</li>\n<li>Wall Street Journal: 1.3 milioni di parole</li>\n<li>Brown Corpus: 1 milione di parole</li>\n<li>\n<p>Switchboard: 1 milione di parole</p>\n</li>\n<li>\n<p>Il progetto <strong><a href=\"https://universaldependencies.org/\">Universal Dependencies</a></strong> fornisce:</p>\n</li>\n<li>Annotazioni coerenti cross-linguistiche</li>\n<li>Dati per l&rsquo;addestramento di parser multilingue</li>\n<li>Strumenti per il parsing e lo studio della sintassi in pi√π lingue</li>\n</ul>\n<h2 id=\"grammatiche-context-free-probabilistiche-pcfg\">üåü Grammatiche Context-Free Probabilistiche (PCFG)</h2>\n<p>Le <strong>PCFG (Probabilistic Context-Free Grammars)</strong> sono un&rsquo;estensione delle grammatiche libere dal contesto (CFG) che associano una <strong>probabilit√† a ciascuna regola di produzione</strong>. Questo permette di modellare <strong>l&rsquo;ambiguit√† sintattica</strong> in modo quantitativo, selezionando l&rsquo;albero di derivazione pi√π probabile per una frase.</p>\n<h3 id=\"definizione-di-pcfg\">üßÆ Definizione di PCFG</h3>\n<p>Una PCFG √® una quintuppla:</p>\n$$\nG = (N, \\Sigma, R, S, P)\n$$\n<p>dove:</p>\n<ul>\n<li>$N$: insieme finito di simboli non terminali</li>\n<li>$\\Sigma$: insieme finito di simboli terminali</li>\n<li>$R$: insieme finito di regole di produzione del tipo $A \\rightarrow \\alpha$</li>\n<li>$S \\in N$: simbolo iniziale</li>\n<li>$P$: funzione che assegna una probabilit√† a ciascuna produzione $A \\rightarrow \\alpha$, con:</li>\n</ul>\n$$\n\\sum_{\\alpha \\in (N \\cup \\Sigma)^*} P(A \\rightarrow \\alpha) = 1 \\quad \\text{per ogni } A \\in N\n$$\n<h3 id=\"ma-qual-e-la-probabilita-di-un-albero-di-parsing\">ü§î Ma qual √® la probabilit√† di un albero di parsing?</h3>\n<p>La <strong>probabilit√† di un albero di derivazione</strong> $T$ per una frase $s$ √® definita come il <strong>prodotto delle probabilit√†</strong> di tutte le produzioni usate nel derivarlo:</p>\n$$\nP(T, s) = \\prod_{i=1}^{n} P(\\text{RHS}_i \\mid \\text{LHS}_i)\n$$\n<p>üìå Dove:\n- $\\text{LHS}_i \\rightarrow \\text{RHS}_i$ √® la <em>i</em>-esima produzione usata nell&rsquo;albero\n- $s$ √® la frase generata da $T$</p>\n<h3 id=\"probabilita-congiunta-e-marginale\">üîó Probabilit√† congiunta e marginale</h3>\n<p>La <strong>probabilit√† congiunta</strong> della frase $s$ e dell&rsquo;albero $T$ √®:</p>\n$$\nP(T, s) = P(T)P(s \\mid T) = P(T)\n$$\n<p>üí° Questo perch√© un albero $T$ determina completamente la frase $s$: contiene tutte le parole terminali in ordine.</p>\n<h3 id=\"utilizzo-delle-pcfg\">üìç Utilizzo delle PCFG</h3>\n<p>Le PCFG sono fondamentali per:</p>\n<ul>\n<li><strong>Disambiguazione sintattica</strong>: tra molteplici alberi validi, si seleziona il pi√π probabile.</li>\n<li><strong>Parsing statistico</strong>: come nei parser probabilistici top-down o bottom-up.</li>\n<li><strong>Apprendimento automatico</strong> delle probabilit√† da corpus annotati (es. Treebank).</li>\n</ul>\n<h3 id=\"esempio-pratico\">üß∞ Esempio pratico</h3>\n<p>Immagina due alberi sintattici validi per la frase <em>&ldquo;I saw the man with the telescope.&rdquo;</em> La PCFG assegna probabilit√† diverse a ciascun albero, favorendo quello che riflette la lettura pi√π comune secondo i dati osservati.</p>\n<h2 id=\"utilizzi-delle-cfg-nel-nlp\">üîç Utilizzi delle CFG nel NLP</h2>\n<p>Le grammatiche libere dal contesto sono utili per:</p>\n<ul>\n<li>Analizzare la struttura sintattica delle frasi (<a href=\"/theory/nlp/Sintassi/Parsing Sintattico\" class=\"text-blue-600 hover:underline\">Parsing sintattico</a>)</li>\n<li>Costruire <span class=\"text-gray-600\">Treebank</span> con annotazioni strutturate</li>\n<li>Implementare algoritmi di parsing come <span class=\"text-gray-600\">Algoritmo CKY (Cocke-Kasami-Younger)</span> o <span class=\"text-gray-600\">Algoritmo di Earley</span></li>\n<li>Definire regole di base in linguaggi di programmazione</li>\n</ul>\n<p>üìå Le CFG offrono un equilibrio tra espressivit√† e semplicit√† computazionale, rendendole uno strumento potente ma gestibile nel contesto del trattamento automatico del linguaggio.</p>\n<p><a href=\"/theory/nlp/Sintassi/Grammatiche Formali\" class=\"text-blue-600 hover:underline\">Grammatiche formali</a> ‚Üí <span class=\"text-gray-600\">Grammatiche libere dal contesto</span> ‚Üí <a href=\"/theory/nlp/Sintassi/Forma Normale di Chomsky\" class=\"text-blue-600 hover:underline\">Forma normale di Chomsky</a> / <a href=\"/theory/nlp/Sintassi/Parsing Sintattico\" class=\"text-blue-600 hover:underline\">Parsing sintattico</a></p>"
}