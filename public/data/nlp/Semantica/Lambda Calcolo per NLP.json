{
  "title": "üßë‚Äçüíª Lambda Calcolo per NLP",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n/* Blocchi di codice sempre visibili */\n.code-visible {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    background: #f9fafb;\n    margin: 16px 0;\n}\n.code-visible .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<p>Il <strong>lambda calcolo</strong> √® un sistema matematico inventato da <strong>Alonzo Church</strong> negli anni &lsquo;30 per descrivere in modo preciso cosa significa <strong>eseguire un calcolo</strong>.<br />\n√à una base teorica della programmazione (soprattutto funzionale) e trova <strong>applicazioni importanti nel Natural Language Processing (NLP)</strong>, ovvero nella comprensione e rappresentazione del linguaggio naturale da parte dei computer.</p>\n<h2 id=\"concetti-base-del-lambda-calcolo\">üß© Concetti Base del Lambda Calcolo</h2>\n<p>Il lambda calcolo √® costruito su <strong>3 concetti fondamentali</strong>:</p>\n<h3 id=\"1-variabili\">1Ô∏è‚É£ Variabili</h3>\n<p>Una <strong>variabile</strong> √® un simbolo (come $x$, $y$, $z$) che rappresenta un valore o un&rsquo;entit√† generica.</p>\n<p>üìå Esempio:</p>\n<ul>\n<li>$x$ pu√≤ rappresentare un numero, una parola, un concetto, ecc.</li>\n</ul>\n<h3 id=\"2-astrazione-definizione-di-funzione\">2Ô∏è‚É£ Astrazione (Definizione di funzione)</h3>\n<p>L&rsquo;<strong>astrazione</strong> √® il modo per <strong>definire una funzione anonima</strong> (cio√® senza nome).<br />\nSi scrive cos√¨:</p>\n$$\n\\lambda x.t\n$$\n<p>Significa: &ldquo;una funzione che prende $x$ e restituisce il risultato dell&rsquo;espressione $t$&rdquo;.</p>\n<p>üìå Esempio:</p>\n$$\n\\lambda x. x + 1\n$$\n<p>Questa √® una funzione che prende un numero $x$ e restituisce $x + 1$.</p>\n<h3 id=\"3-applicazione-uso-della-funzione\">3Ô∏è‚É£ Applicazione (Uso della funzione)</h3>\n<p>L&rsquo;<strong>applicazione</strong> √® quando <strong>si fornisce un argomento (input)</strong> a una funzione.</p>\n<p>üìå Esempio:</p>\n$$\n(\\lambda x. x + 1) \\ 5\n$$\n<p>Significa: &ldquo;applica la funzione $\\lambda x. x + 1$ all&rsquo;argomento $5$&rdquo;.</p>\n<p>üëâ Risultato:</p>\n$$\n5 + 1 = 6\n$$\n<h2 id=\"operazioni-importanti-nel-lambda-calcolo\">üîÑ Operazioni Importanti nel Lambda Calcolo</h2>\n<p>Per manipolare le espressioni, si usano principalmente due operazioni:</p>\n<h3 id=\"alpha-conversion-rinominare-variabili\">üîÅ Alpha Conversion (Rinominare variabili)</h3>\n<p>Serve per <strong>evitare conflitti tra variabili</strong>.<br />\nPuoi cambiare il nome di una <strong>variabile legata</strong> (cio√® usata dentro una funzione) senza cambiare il significato.</p>\n<p>üìå Esempio:</p>\n$$\n\\lambda x.x \\equiv \\lambda y.y\n$$\n<p>Queste due funzioni sono <strong>equivalenti</strong>: entrambe prendono un input e lo restituiscono senza modificarlo.</p>\n<h3 id=\"beta-reduction-applicare-una-funzione\">üßÆ Beta Reduction (Applicare una funzione)</h3>\n<p>√à l‚Äôoperazione principale: <strong>esegue effettivamente la funzione</strong>.</p>\n<p>Se hai una funzione:</p>\n$$\n(\\lambda x.t) \\ s\n$$\n<p>Si sostituisce la variabile $x$ con il valore $s$ nell‚Äôespressione $t$:</p>\n$$\nt(s)\n$$\n<p>üìå Esempio $t(x) = x+1$:</p>\n$$\n(\\lambda x.t) \\ 4 \\Rightarrow (\\lambda x. x + 1) \\ 4 \\Rightarrow t(4) \\Rightarrow 4 + 1 = 5\n$$\n<h2 id=\"esempi-pratici-di-lambda-espressioni\">üîç Esempi Pratici di Lambda Espressioni</h2>\n<p>Vediamo alcune funzioni comuni scritte con il lambda calcolo:</p>\n<h3 id=\"identita\">‚úÖ Identit√†</h3>\n<p>Restituisce l&rsquo;input senza modificarlo:</p>\n$$\n\\lambda x. x\n$$\n<p>üìå Esempio:</p>\n$$\n(\\lambda x.x)\\ 7 = 7\n$$\n<h3 id=\"funzione-costante\">üî¢ Funzione Costante</h3>\n<p>Restituisce sempre lo stesso valore, ignorando l&rsquo;input:</p>\n$$\n\\lambda x. y\n$$\n<p>üìå Esempio:<br />\n$$\n(\\lambda x.42)\\ 100 = 42\n$$</p>\n<h3 id=\"funzione-quadrato\">‚èπÔ∏è Funzione Quadrato</h3>\n<p>Restituisce il quadrato del numero dato:</p>\n$$\n\\lambda x. x \\cdot x\n$$\n<p>üìå Esempio:</p>\n$$\n(\\lambda x. x \\cdot x) \\ 4 = 4 \\cdot 4 = 16\n$$\n<h3 id=\"funzione-con-piu-argomenti\">‚ûï Funzione con pi√π argomenti</h3>\n<p>Una funzione che moltiplica due numeri pu√≤ essere scritta usando <strong>funzioni nidificate</strong>:</p>\n$$\n\\lambda x. \\lambda y. x \\cdot y\n$$\n<p>üìå Esempio di applicazione:</p>\n$$\n((\\lambda x. \\lambda y. x \\cdot y) \\ 3) \\ 4 = (\\lambda y. 3 \\cdot y) \\ 4 = 12\n$$\n<h2 id=\"lambda-calcolo-in-linguistica\">üáÆüáπ Lambda Calcolo in Linguistica</h2>\n<p>In <strong>NLP</strong>, il lambda calcolo viene utilizzato per rappresentare le espressioni semantiche del linguaggio naturale. Ci√≤ implica l&rsquo;uso di costanti, connettivi e quantificatori per modellare il significato delle frasi.</p>\n<h3 id=\"costanti-linguistiche\">Costanti Linguistiche</h3>\n<p>Per costruire frasi, utilizziamo costanti come &ldquo;due&rdquo;, &ldquo;rosso&rdquo;, &ldquo;ama&rdquo;, &ldquo;mangiato&rdquo;, &ldquo;Giovanni&rdquo;, &ldquo;Maria&rdquo;, ecc. Ogni parola o concetto nel linguaggio pu√≤ essere rappresentato come una costante nel lambda calcolo.</p>\n<h3 id=\"connettivi-e-quantificatori\">Connettivi e Quantificatori</h3>\n<p>Nel linguaggio naturale, possiamo avere connettivi logici come <strong>o</strong>, <strong>e</strong>, <strong>non</strong>, <strong>se &hellip; allora</strong>, <strong>per tutti</strong>, <strong>esiste</strong>. Questi connettivi sono rappresentati in lambda calcolo come combinazioni di astrazioni e applicazioni.</p>\n<p>Esempio di una frase:\n$$ loves(John, Mary) $$</p>\n<p>In lambda calcolo, questa potrebbe essere rappresentata come:\n$$ \\lambda x.\\lambda y.loves(x, y)(John)(Mary) $$</p>\n<h4 id=\"esempio-di-frase-complessa\">Esempio di Frase Complessa</h4>\n<p>Consideriamo una frase come:\n&ldquo;<strong>Mozzarella √® rossa e Giovanni ha mangiato mozzarella.</strong>&rdquo;\nIn lambda calcolo, possiamo rappresentarlo come:\n$$\n(\\lambda x.mozzarella(x) \\land \\lambda x.rossa(x) \\land \\lambda x.ate(giovanni, x))(m)\n$$</p>\n<p>Qui, ogni verbo e aggettivo viene trattato come una funzione che applica determinati predicati (come <code>mozarella</code>, <code>rossa</code>, <code>ate</code>) ai rispettivi argomenti.</p>\n<p>Applicando le $\\beta$-riduzioni a queste funzioni, otteniamo la frase complessa rappresentata in logica FOL:</p>\n$$\nmozzarella(m) \\land rossa(m) \\land ate(giovanni, m).\n$$\n<h2 id=\"lambda-calcolo-e-modellizzazione-degli-eventi\">Lambda Calcolo e Modellizzazione degli Eventi</h2>\n<p>Il lambda calcolo √® anche molto utile per rappresentare eventi temporali. Un evento pu√≤ essere definito come una relazione tra un&rsquo;azione e il tempo in cui essa si verifica.</p>\n<p>Esempio di evento nel lambda calcolo:</p>\n$$\n\\begin{aligned}\n\\mathrm{MANGIARE} &= \\lambda e.\\;\\mathrm{mangiare}(e)\\\\\n\\mathrm{AGENTE}  &= \\lambda x.\\;\\lambda e.\\;\\mathrm{agente}(e,x)\\\\\n\\mathrm{TEMA}    &= \\lambda y.\\;\\lambda e.\\;\\mathrm{tema}(e,y)\\\\\n\\mathrm{TEMPO}   &= \\lambda t.\\;\\lambda e.\\;\\mathrm{tempo}(e,t)\\\\\n\\mathrm{AND}     &= \\lambda P.\\;\\lambda Q.\\;\\lambda z.\\;P(z)\\land Q(z)\n\\end{aligned}\n$$\n<p>Componiamo queste funzioni per rappresentare:</p>\n<blockquote>\n<p><strong>‚ÄúGiovanni ha mangiato una mela alle 12.‚Äù</strong></p>\n</blockquote>\n$$\n(\\mathrm{AND}\\;\\mathrm{MANGIARE}\\;\n  (\\mathrm{AND}\\;(\\mathrm{AGENTE}\\;\\mathit{giovanni})\\;\n    (\\mathrm{AND}\\;(\\mathrm{TEMA}\\;\\mathit{mela})\\;\n      (\\mathrm{TEMPO}\\;12)\n    )\n  )\n)\n$$\n<p>Applicando le Œ≤‚Äêriduzioni otteniamo la funzione evento:</p>\n$$\n\\exists e \\;\\mathrm{mangiare}(e)\\;\\land\\;\\mathrm{agente}(e,\\mathit{Giovanni})\\;\\land\\;\\mathrm{tema}(e,\\mathit{mela})\\;\\land\\;\\mathrm{tempo}(e,12)\n$$\n<p>Questo modello semantico rappresenta un evento in cui Giovanni mangia una mela, con un&rsquo;azione che avviene nel passato. Ogni argomento dell&rsquo;evento √® rappresentato da un termine del lambda calcolo, permettendo una rappresentazione formale dell&rsquo;evento.</p>\n<h2 id=\"come-estrarre-la-semantica-dalle-frasi\">üß† Come estrarre la semantica dalle frasi?</h2>\n<p>Il <strong>processo di composizione semantica</strong> in NLP si basa sull&rsquo;idea che il significato di una frase possa essere derivato in modo <strong>composizionale</strong>, partendo dal significato delle parole singole e combinandole secondo la struttura sintattica.</p>\n<h3 id=\"tabella-grammar-rule-semantic-attachment\">üìö Tabella: Grammar Rule + Semantic Attachment</h3>\n<table>\n<thead>\n<tr>\n<th><strong>Grammar Rule</strong></th>\n<th><strong>Semantic Attachment</strong></th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>$S \\rightarrow NP\\ VP$</td>\n<td>$\\{NP.sem(VP.sem)\\}$</td>\n</tr>\n<tr>\n<td>$NP \\rightarrow Det\\ Nominal$</td>\n<td>$\\{Det.sem(Nominal.sem)\\}$</td>\n</tr>\n<tr>\n<td>$NP \\rightarrow ProperNoun$</td>\n<td>$\\{ProperNoun.sem\\}$</td>\n</tr>\n<tr>\n<td>$Nominal \\rightarrow Noun$</td>\n<td>$\\{Noun.sem\\}$</td>\n</tr>\n<tr>\n<td>$VP \\rightarrow Verb$</td>\n<td>$\\{Verb.sem\\}$</td>\n</tr>\n<tr>\n<td>$VP \\rightarrow Verb\\ NP$</td>\n<td>$\\{Verb.sem(NP.sem)\\}$</td>\n</tr>\n<tr>\n<td>$Det \\rightarrow every$</td>\n<td>$\\{\\lambda P.\\lambda Q.\\forall x[P(x) \\Rightarrow Q(x)]\\}$</td>\n</tr>\n<tr>\n<td>$Det \\rightarrow a$</td>\n<td>$\\{\\lambda P.\\lambda Q.\\exists x[P(x) \\land Q(x)]\\}$</td>\n</tr>\n<tr>\n<td>$Noun \\rightarrow restaurant$</td>\n<td>$\\{\\lambda r.\\ Restaurant(r)\\}$</td>\n</tr>\n<tr>\n<td>$ProperNoun \\rightarrow Matthew$</td>\n<td>$\\{\\lambda m.\\ m(\\text{Matthew})\\}$</td>\n</tr>\n<tr>\n<td>$ProperNoun \\rightarrow Franco$</td>\n<td>$\\{\\lambda f.\\ f(\\text{Franco})\\}$</td>\n</tr>\n<tr>\n<td>$ProperNoun \\rightarrow Frasca$</td>\n<td>$\\{\\lambda f.\\ f(\\text{Frasca})\\}$</td>\n</tr>\n<tr>\n<td>$Verb \\rightarrow closed$</td>\n<td>$\\{\\lambda x.\\exists e[\\text{Closing}(e) \\land \\text{Closed}(e,x)]\\}$</td>\n</tr>\n<tr>\n<td>$Verb \\rightarrow opened$</td>\n<td>$\\{\\lambda w.\\lambda z.\\ w(\\lambda x.\\exists e[\\text{Opening}(e) \\land \\text{Opener}(e,z) \\land \\text{Opened}(e,x)])\\}$</td>\n</tr>\n</tbody>\n</table>\n<p>Ecco i <strong>passaggi fondamentali</strong> per costruire la semantica di una frase tramite il lambda calcolo:</p>\n<h3 id=\"1-analisi-sintattica-costruzione-dellalbero-sintattico\">1Ô∏è‚É£ Analisi sintattica: costruzione dell&rsquo;albero sintattico</h3>\n<p>La frase viene prima <strong>analizzata sintatticamente</strong> per produrre un <strong>albero di parsing</strong>.<br />\nOgni nodo dell&rsquo;albero rappresenta una categoria grammaticale (come S, NP, VP, ecc.).</p>\n<p>üìå <strong>Esempio:</strong></p>\n<blockquote>\n<p><em>Franco opened a restaurant</em></p>\n</blockquote>\n<p>L&rsquo;albero generato avr√† struttura:</p>\n<p><img src=\"/images/tikz/db082d3fc019182e48a347e0a02abda7.svg\" style=\"display: block; width: 100%; height: auto; max-height: 600px;\" class=\"tikz-svg\" /></p>\n<h3 id=\"2-semantica-lessicale-assegnazione-di-significati-ai-terminali\">2Ô∏è‚É£ Semantica lessicale: assegnazione di significati ai terminali</h3>\n<p>A ciascun <strong>terminale dell&rsquo;albero</strong> (cio√® ogni parola) viene assegnata una <strong>forma semantica in lambda calcolo</strong>.</p>\n<h4 id=\"terminali-foglie-dellalbero\">üìå Terminali (foglie dell‚Äôalbero)</h4>\n<ul>\n<li>\n<p><code>Franco</code><br />\n  $$ \\lambda f.\\,f(\\text{Franco}) $$</p>\n</li>\n<li>\n<p><code>opened</code><br />\n  $$ \\lambda w.\\lambda z.\\,w(\\lambda x.\\exists e\\,[Opening(e) \\land Opener(e,z) \\land Opened(e,x)]) $$</p>\n</li>\n<li>\n<p><code>a</code><br />\n  $$ \\lambda P.\\lambda Q.\\,\\exists x\\,[P(x) \\land Q(x)] $$</p>\n</li>\n<li>\n<p><code>restaurant</code><br />\n  $$ \\lambda r.\\,Restaurant(r) $$</p>\n</li>\n</ul>\n<h4 id=\"composizione-semantica-bottom-up\">üìå Composizione semantica (Bottom-up)</h4>\n<ul>\n<li>\n<p><strong>Nominal ‚Üí Noun</strong><br />\n  $$ \\text{Nominal.sem} = \\text{Noun.sem} = \\lambda r.\\,Restaurant(r) $$</p>\n</li>\n<li>\n<p><strong>Det + Nominal ‚Üí NP</strong><br />\n  $$ \\text{NP.sem} = \\text{Det.sem}(\\text{Nominal.sem}) $$\n  $$ = (\\lambda P.\\lambda Q.\\,\\exists x\\,[P(x) \\land Q(x)])(\\lambda r.\\,Restaurant(r)) $$\n  $$ = \\lambda Q.\\,\\exists x\\,[Restaurant(x) \\land Q(x)] $$</p>\n</li>\n<li>\n<p><strong>VP ‚Üí Verb + NP</strong><br />\n  $$ \\text{VP.sem} = \\text{Verb.sem}(\\text{NP.sem}) $$\n  $$ = (\\lambda w.\\lambda z.\\,w(\\lambda x.\\exists e\\,[Opening(e) \\land Opener(e,z) \\land Opened(e,x)]))(\\lambda Q.\\,\\exists x\\,[Restaurant(x) \\land Q(x)]) $$\n  $$ = \\lambda z.\\,(\\lambda Q.\\,\\exists x\\,[Restaurant(x) \\land Q(x)])(\\lambda x.\\exists e\\,[Opening(e) \\land Opener(e,z) \\land Opened(e,x)]) $$\n  $$ = \\lambda z.\\,\\exists x\\,[Restaurant(x) \\land \\exists e\\,[Opening(e) \\land Opener(e,z) \\land Opened(e,x)]] $$</p>\n</li>\n<li>\n<p><strong>NP ‚Üí ProperNoun (<code>Franco</code>)</strong><br />\n  $$ \\lambda f.\\,f(\\text{Franco}) $$</p>\n</li>\n<li>\n<p><strong>S ‚Üí NP + VP</strong><br />\n  $$ \\text{S.sem} = \\text{NP.sem}(\\text{VP.sem}) $$\n  $$ = (\\lambda f.\\,f(\\text{Franco}))(\\lambda z.\\,\\exists x\\,[Restaurant(x) \\land \\exists e\\,[Opening(e) \\land Opener(e,z) \\land Opened(e,x)]]) $$\n  $$ = \\exists x\\,[Restaurant(x) \\land \\exists e\\,[Opening(e) \\land Opener(e,\\text{Franco}) \\land Opened(e,x)]] $$</p>\n</li>\n</ul>\n<p>‚úÖ <strong>Risultato finale (Semantica della frase)</strong></p>\n<p><strong>Franco opened a restaurant</strong><br />\n$$ \\exists x\\,[Restaurant(x) \\land \\exists e\\,[Opening(e) \\land Opener(e,\\text{Franco}) \\land Opened(e,x)]] $$</p>\n<h2 id=\"limiti-dellapproccio-composizionale-basato-sul-lambda-calcolo\">‚ö†Ô∏è Limiti dell&rsquo;approccio composizionale basato sul Lambda Calcolo</h2>\n<p>Sebbene il lambda calcolo sia uno strumento molto potente per rappresentare la <strong>semantica formale</strong> del linguaggio naturale, presenta diversi limiti importanti quando viene applicato direttamente in NLP.</p>\n<h3 id=\"1-e-difficile\">1Ô∏è‚É£ √à Difficile!</h3>\n<p>L&rsquo;analisi semantica formale richiede:</p>\n<ul>\n<li>Conoscenze avanzate di logica e lambda calcolo.</li>\n<li>Una grammatica sintattica/semantica dettagliata e ben definita.</li>\n<li>Un processo di parsing robusto per generare alberi sintattici corretti.</li>\n<li>Meccanismi per eseguire <strong>beta-riduzioni</strong> e <strong>composizione funzionale</strong> tra i costituenti.</li>\n</ul>\n<p>‚û°Ô∏è Anche per frasi semplici, la derivazione formale pu√≤ diventare <strong>complessa e poco scalabile</strong>.</p>\n<h3 id=\"2-assunzioni-semplificative-e-pericolose\">2Ô∏è‚É£ Assunzioni semplificative (e pericolose!)</h3>\n<p>Una semplificazione comune √® quella di assumere che <strong>ogni terminale</strong> (cio√® ogni parola) abbia <strong>un solo significato preciso</strong>.</p>\n<p>üî¥ Esempi:</p>\n<ul>\n<li><code>Franco</code> ‚Üí $\\text{Franco}$  </li>\n<li><code>Opening</code> ‚Üí $\\text{Opening}(e)$  </li>\n<li><code>Restaurant</code> ‚Üí $\\text{Restaurant}(x)$  </li>\n</ul>\n<p>‚ùó In realt√†, <strong>le parole sono ambigue</strong>:<br />\n- <code>Opening</code> pu√≤ essere un verbo (es. &ldquo;he is opening&rdquo;) o un nome (&ldquo;the grand opening&rdquo;).\n- <code>Bank</code> pu√≤ indicare un edificio o il lato di un fiume.\n- <code>Franco</code> potrebbe anche essere un aggettivo (&ldquo;un tono franco&rdquo;).</p>\n<h3 id=\"3-serve-la-semantica-lessicale\">3Ô∏è‚É£ Serve la Semantica Lessicale</h3>\n<p>Per trattare <strong>l‚Äôambiguit√† del significato delle parole</strong>, dobbiamo <strong>andare oltre la semantica composizionale</strong> e occuparci della <strong><a href=\"/theory/nlp/Semantica/Semantica Lessicale\" class=\"text-blue-600 hover:underline\">semantica lessicale</a></strong>:</p>\n<ul>\n<li>Capire <strong>i diversi sensi di una parola</strong> in base al contesto.</li>\n<li>Costruire <strong>rappresentazioni concettuali</strong> (come frame, ontologie, word sense).</li>\n<li>Integrare risorse come <strong>WordNet</strong>, <strong>FrameNet</strong>, o modelli <strong>word embeddings</strong>.</li>\n</ul>\n<h3 id=\"conclusione\">‚úÖ Conclusione</h3>\n<p>Il lambda calcolo √® fondamentale per modellare la <strong>composizione del significato</strong>, ma da solo <strong>non basta</strong>. Per interpretare correttamente una frase, dobbiamo prima <strong>capire le parole</strong>, poi possiamo comporre i loro significati.</p>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"gi\">+ Prima la semantica lessicale, poi quella composizionale!</span>\n</code></pre></div>\n</div>\n</details>"
}