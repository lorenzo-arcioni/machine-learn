{
  "title": "CatBoost: Unbiased Boosting with Categorical Features",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n/* Blocchi di codice sempre visibili */\n.code-visible {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    background: #f9fafb;\n    margin: 16px 0;\n}\n.code-visible .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<h2 id=\"indice\">Indice</h2>\n<ol>\n<li><a href=\"#introduzione\">Introduzione</a></li>\n<li><a href=\"#background-teorico\">Background Teorico</a></li>\n<li><a href=\"#il-problema-delle-feature-categoriche\">Il Problema delle Feature Categoriche</a></li>\n<li><a href=\"#target-statistics\">Target Statistics</a></li>\n<li><a href=\"#prediction-shift-e-ordered-boosting\">Prediction Shift e Ordered Boosting</a></li>\n<li><a href=\"#implementazione-pratica\">Implementazione Pratica</a></li>\n<li><a href=\"#risultati-sperimentali\">Risultati Sperimentali</a></li>\n<li><a href=\"#conclusioni\">Conclusioni</a></li>\n</ol>\n<hr />\n<h2 id=\"introduzione\">Introduzione</h2>\n<p><strong>CatBoost</strong> (abbreviazione di &ldquo;Categorical Boosting&rdquo;) è una libreria open-source per il gradient boosting sviluppata da Yandex che introduce due innovazioni algoritmiche fondamentali:</p>\n<ol>\n<li><strong>Ordered Boosting</strong>: un&rsquo;alternativa basata su permutazioni all&rsquo;algoritmo classico di gradient boosting</li>\n<li><strong>Algoritmo innovativo per il processing delle feature categoriche</strong></li>\n</ol>\n<p>Entrambe queste tecniche sono state create per combattere il <strong>prediction shift</strong>, un particolare tipo di target leakage presente in tutte le implementazioni esistenti di gradient boosting.</p>\n<h3 id=\"motivazione\">Motivazione</h3>\n<p>Il gradient boosting è una delle tecniche di machine learning più potenti e viene utilizzato con successo in moltissimi ambiti applicativi:\n- Ricerca web\n- Sistemi di raccomandazione\n- Previsioni meteorologiche\n- Problemi con feature eterogenee, dati rumorosi e dipendenze complesse</p>\n<p>Nonostante il suo successo, <strong>tutti gli algoritmi esistenti soffrono di un problema statistico fondamentale</strong> che porta a un bias sistematico nelle predizioni.</p>\n<hr />\n<h2 id=\"background-teorico\">Background Teorico</h2>\n<h3 id=\"il-problema-di-apprendimento\">Il Problema di Apprendimento</h3>\n<p>Consideriamo un dataset $\\mathcal{D} = \\{(\\mathbf{x}_k, y_k)\\}_{k=1}^n$ dove:\n- $\\mathbf{x}_k = (x_k^1, \\ldots, x_k^m)$ è un vettore casuale di $m$ <strong>feature</strong>\n- $y_k \\in \\mathbb{R}$ è il <strong>target</strong> (può essere binario o una risposta numerica)\n- Gli esempi sono indipendenti e identicamente distribuiti secondo una distribuzione sconosciuta $P(\\cdot, \\cdot)$</p>\n<p><strong>Obiettivo</strong>: Addestrare una funzione $F: \\mathbb{R}^m \\to \\mathbb{R}$ che minimizza la perdita attesa:</p>\n$$\\mathcal{L}(F) := \\mathbb{E} L(y, F(\\mathbf{x}))$$\n<p>dove:\n- $L(\\cdot, \\cdot)$ è una funzione di perdita liscia\n- $(\\mathbf{x}, y)$ è un esempio di test campionato da $P$ indipendentemente dal training set</p>\n<h3 id=\"gradient-boosting-principio-di-base\">Gradient Boosting: Principio di Base</h3>\n<p>Il gradient boosting costruisce iterativamente una sequenza di <strong>approssimazioni</strong> $F^t: \\mathbb{R}^m \\to \\mathbb{R}$, per $t = 0, 1, \\ldots$ in modo greedy.</p>\n<p>Ad ogni step, la nuova approssimazione è ottenuta in modo additivo:</p>\n$$F^t = F^{t-1} + \\alpha h^t$$\n<p>dove:\n- $\\alpha$ è lo <strong>step size</strong> (learning rate)\n- $h^t: \\mathbb{R}^m \\to \\mathbb{R}$ è il <strong>base predictor</strong> (predittore di base)</p>\n<p>Il base predictor viene scelto da una famiglia di funzioni $\\mathcal{H}$ per minimizzare la perdita attesa:</p>\n$$h^t = \\arg\\min_{h \\in \\mathcal{H}} \\mathcal{L}(F^{t-1} + h) = \\arg\\min_{h \\in \\mathcal{H}} \\mathbb{E} L(y, F^{t-1}(\\mathbf{x}) + h(\\mathbf{x}))$$\n<h4 id=\"gradient-step\">Gradient Step</h4>\n<p>In pratica, questo problema di minimizzazione viene affrontato con il <strong>metodo di Newton</strong> o con uno <strong>step di gradiente negativo</strong>. Nel caso dello step di gradiente, $h^t$ viene scelto in modo che $h^t(\\mathbf{x})$ approssimi $-g^t(\\mathbf{x}, y)$, dove:</p>\n$$g^t(\\mathbf{x}, y) := \\frac{\\partial L(y, s)}{\\partial s}\\bigg|_{s=F^{t-1}(\\mathbf{x})}$$\n<p>Tipicamente si usa l&rsquo;approssimazione ai minimi quadrati:</p>\n$$h^t = \\arg\\min_{h \\in \\mathcal{H}} \\mathbb{E}\\left(-g^t(\\mathbf{x}, y) - h(\\mathbf{x})\\right)^2$$\n<p><strong>Punto chiave</strong>: Questa è la formulazione teorica. In pratica, l&rsquo;aspettazione è sconosciuta e viene approssimata usando il training set $\\mathcal{D}$.</p>\n<h3 id=\"decision-trees-come-base-predictors\">Decision Trees come Base Predictors</h3>\n<p>CatBoost utilizza <strong>alberi di decisione binari</strong> come base predictors. Un albero di decisione è un modello costruito attraverso una partizione ricorsiva dello spazio delle feature $\\mathbb{R}^m$ in diverse regioni disgiunte (nodi dell&rsquo;albero).</p>\n<h4 id=\"struttura-di-un-albero\">Struttura di un Albero</h4>\n<p>La partizione avviene secondo i valori di alcuni <strong>attributi di splitting</strong> $a$, che sono tipicamente variabili binarie del tipo:</p>\n$$a = \\mathbb{1}_{\\{x^k > t\\}}$$\n<p>dove:\n- $x^k$ è una feature numerica o binaria\n- $t$ è una <strong>soglia</strong> (threshold)\n- Nel caso di feature binarie, $t = 0.5$</p>\n<p><strong>Perché split binari?</strong> \n- Split non binari (es. basati su tutti i valori di una feature categorica) porterebbero a:\n  - Alberi poco profondi (incapaci di catturare dipendenze complesse), oppure\n  - Alberi molto complessi con numero esponenziale di nodi terminali (con statistiche target più deboli in ciascuno)\n- La complessità dell&rsquo;albero ha un effetto cruciale sull&rsquo;accuratezza: alberi meno complessi sono meno soggetti a overfitting</p>\n<h4 id=\"rappresentazione-matematica\">Rappresentazione Matematica</h4>\n<p>Ogni foglia (regione finale) dell&rsquo;albero è associata a un valore che stima la risposta $y$. Un albero $h$ può essere scritto come:</p>\n$$h(\\mathbf{x}) = \\sum_{j=1}^J b_j \\mathbb{1}_{\\{\\mathbf{x} \\in R_j\\}}$$\n<p>dove:\n- $R_j$ sono le regioni disgiunte corrispondenti alle foglie\n- $b_j$ sono i valori assegnati a ciascuna foglia\n- $J$ è il numero totale di foglie</p>\n<p>Nel gradient boosting, gli attributi di split e i valori delle foglie sono tipicamente scelti secondo il criterio dei minimi quadrati, poiché l&rsquo;albero è costruito per approssimare il gradiente negativo.</p>\n<hr />\n<h2 id=\"il-problema-delle-feature-categoriche\">Il Problema delle Feature Categoriche</h2>\n<h3 id=\"cosa-sono-le-feature-categoriche\">Cosa sono le Feature Categoriche?</h3>\n<p>Una <strong>feature categorica</strong> è una variabile con un insieme discreto di valori chiamati <strong>categorie</strong>, che non sono confrontabili tra loro. Esempi tipici:\n- User ID\n- Regione geografica\n- Tipo di prodotto\n- Publisher\n- Categoria di annuncio</p>\n<p>Queste feature sono fondamentali in molte applicazioni pratiche, specialmente nel click prediction (previsione dei click su annunci pubblicitari).</p>\n<h3 id=\"approcci-esistenti\">Approcci Esistenti</h3>\n<h4 id=\"1-one-hot-encoding\">1. One-Hot Encoding</h4>\n<p>La tecnica più popolare consiste nel <strong>one-hot encoding</strong>: per ogni categoria si aggiunge una nuova feature binaria che indica se quella categoria è presente.</p>\n<p><strong>Problema</strong>: Per feature con <strong>alta cardinalità</strong> (molte categorie possibili, come &ldquo;user ID&rdquo;), questo approccio porta a un numero impraticabile di nuove feature.</p>\n<p><strong>Soluzione comune</strong>: Raggruppare le categorie in un numero limitato di cluster e poi applicare one-hot encoding.</p>\n<h4 id=\"2-target-statistics-ts\">2. Target Statistics (TS)</h4>\n<p>Un metodo popolare consiste nel raggruppare le categorie in base alle <strong>target statistics</strong>: si stima il valore atteso del target in ogni categoria.</p>\n<p>Micci-Barreca (2001) propose di considerare le TS come nuove feature numeriche invece dell&rsquo;one-hot encoding.</p>\n<p><strong>Vantaggio importante</strong>: Tra tutte le possibili partizioni delle categorie in due insiemi, uno split ottimale sui dati di training (in termini di logloss, Gini index, MSE) può essere trovato tra le soglie sulla feature numerica TS.</p>\n<h4 id=\"3-gradient-statistics-lightgbm\">3. Gradient Statistics (LightGBM)</h4>\n<p>LightGBM converte le feature categoriche in <strong>gradient statistics</strong> ad ogni step del gradient boosting.</p>\n<p><strong>Problemi</strong>:\n1. Aumento drammatico del tempo di computazione (calcola le statistiche per ogni valore categorico ad ogni step)\n2. Aumento del consumo di memoria (deve memorizzare quale categoria appartiene a quale nodo per ogni split)\n3. Per risolvere questi problemi, LightGBM raggruppa le categorie meno frequenti in un cluster unico, perdendo parte dell&rsquo;informazione</p>\n<h3 id=\"conclusione-sullapproccio\">Conclusione sull&rsquo;Approccio</h3>\n<p><strong>Le Target Statistics come feature numeriche sembrano essere il metodo più efficiente</strong> per gestire le feature categoriche con minima perdita di informazione. Richiedono di calcolare e memorizzare solo un numero per categoria.</p>\n<p>Le TS sono ampiamente utilizzate, ad esempio nel click prediction (click-through rates), dove feature categoriche come user, region, ad, publisher giocano un ruolo cruciale.</p>\n<hr />\n<h2 id=\"target-statistics\">Target Statistics</h2>\n<h3 id=\"definizione\">Definizione</h3>\n<p>Come discusso, un modo efficace ed efficiente per gestire una feature categorica $i$ è sostituire la categoria $x_k^i$ del $k$-esimo esempio di training con <strong>una</strong> feature numerica uguale a una <strong>target statistic</strong> $\\hat{x}_k^i$.</p>\n<p>Comunemente, questa stima il target atteso $y$ condizionato alla categoria:</p>\n$$\\hat{x}_k^i \\approx \\mathbb{E}(y \\mid x^i = x_k^i)$$\n<h3 id=\"greedy-ts-lapproccio-diretto-e-problematico\">Greedy TS: L&rsquo;Approccio Diretto (e Problematico)</h3>\n<p>Un approccio diretto consiste nello stimare $\\mathbb{E}(y \\mid x^i = x_k^i)$ come la media di $y$ sugli esempi di training con la stessa categoria $x_k^i$.</p>\n<p>Per ridurre il rumore per categorie a bassa frequenza, si applica uno <strong>smoothing</strong> con un prior $p$:</p>\n$$\\hat{x}_k^i = \\frac{\\sum_{j=1}^n \\mathbb{1}_{\\{x_j^i = x_k^i\\}} \\cdot y_j + a \\cdot p}{\\sum_{j=1}^n \\mathbb{1}_{\\{x_j^i = x_k^i\\}} + a}$$\n<p>dove:\n- $a > 0$ è un parametro di smoothing\n- $p$ è tipicamente il valore medio del target nel dataset\n- Il numeratore somma tutti i target degli esempi con la stessa categoria, più un termine di prior\n- Il denominatore conta quanti esempi hanno quella categoria, più il peso del prior</p>\n<p><strong>Spiegazione intuitiva dello smoothing</strong>: \n- Se una categoria appare poche volte, la media dei target potrebbe essere molto rumorosa\n- Aggiungendo $a \\cdot p$ al numeratore e $a$ al denominatore, &ldquo;mescoliamo&rdquo; la stima empirica con il prior $p$\n- Quando il numero di osservazioni è piccolo, la stima si avvicina a $p$\n- Quando il numero di osservazioni è grande, la stima si avvicina alla media empirica</p>\n<h3 id=\"il-problema-del-target-leakage\">Il Problema del Target Leakage</h3>\n<p>Il problema di questo approccio <strong>greedy</strong> è il <strong>target leakage</strong>: la feature $\\hat{x}_k^i$ è calcolata usando $y_k$, il target di $\\mathbf{x}_k$ stesso!</p>\n<p>Questo porta a un <strong>conditional shift</strong>: la distribuzione di $\\hat{x}^i \\mid y$ differisce tra esempi di training e test.</p>\n<h4 id=\"esempio-estremo\">Esempio Estremo</h4>\n<p>Consideriamo un caso estremo per illustrare quanto questo possa influenzare drasticamente l&rsquo;errore di generalizzazione:</p>\n<p><strong>Setup</strong>:\n- La $i$-esima feature è categorica\n- Tutti i suoi valori sono unici (ogni esempio ha una categoria diversa)\n- Per ogni categoria $A$: $P(y=1 \\mid x^i = A) = 0.5$ (classificazione binaria)</p>\n<p><strong>Sul training set</strong>:\n- $\\hat{x}_k^i = \\frac{y_k + ap}{1 + a}$\n- È sufficiente uno split con soglia $t = \\frac{0.5 + ap}{1 + a}$ per classificare perfettamente tutti gli esempi di training</p>\n<p><strong>Sul test set</strong>:\n- Per tutti gli esempi test, la greedy TS vale $p$\n- Il modello predice $0$ per tutti se $p < t$, oppure $1$ se $p \\geq t$\n- <strong>Accuracy = 0.5</strong> in entrambi i casi!</p>\n<h3 id=\"proprieta-desiderata-p1\">Proprietà Desiderata P1</h3>\n<p>Formuliamo la seguente proprietà desiderata per le TS:</p>\n<p><strong>P1</strong>: $\\mathbb{E}(\\hat{x}^i \\mid y = v) = \\mathbb{E}(\\hat{x}_k^i \\mid y_k = v)$</p>\n<p>dove $(\\mathbf{x}_k, y_k)$ è il $k$-esimo esempio di training.</p>\n<p>Nell&rsquo;esempio sopra: \n- $\\mathbb{E}(\\hat{x}_k^i \\mid y_k) = \\frac{y_k + ap}{1 + a}$ (dipende da $y_k$!)\n- $\\mathbb{E}(\\hat{x}^i \\mid y) = p$ (costante)\n- Le due distribuzioni sono diverse → violazione di P1</p>\n<h3 id=\"approcci-per-evitare-il-conditional-shift\">Approcci per Evitare il Conditional Shift</h3>\n<p>L&rsquo;idea generale è calcolare la TS per $\\mathbf{x}_k$ su un sottoinsieme di esempi $\\mathcal{D}_k \\subset \\mathcal{D} \\setminus \\{\\mathbf{x}_k\\}$ che <strong>esclude</strong> $\\mathbf{x}_k$:</p>\n$$\\hat{x}_k^i = \\frac{\\sum_{\\mathbf{x}_j \\in \\mathcal{D}_k} \\mathbb{1}_{\\{x_j^i = x_k^i\\}} \\cdot y_j + a \\cdot p}{\\sum_{\\mathbf{x}_j \\in \\mathcal{D}_k} \\mathbb{1}_{\\{x_j^i = x_k^i\\}} + a}$$\n<h4 id=\"holdout-ts\">Holdout TS</h4>\n<p>Un modo è partizionare il training set in due parti: $\\mathcal{D} = \\hat{\\mathcal{D}}_0 \\sqcup \\hat{\\mathcal{D}}_1$</p>\n<ul>\n<li>Si usa $\\mathcal{D}_k = \\hat{\\mathcal{D}}_0$ per calcolare le TS</li>\n<li>Si usa $\\hat{\\mathcal{D}}_1$ per il training</li>\n</ul>\n<p><strong>Vantaggi</strong>: Questo approccio holdout soddisfa P1.</p>\n<p><strong>Svantaggi</strong>: Riduce significativamente la quantità di dati usati sia per il training che per il calcolo delle TS. Viola la seguente proprietà desiderata:</p>\n<p><strong>P2</strong>: <em>Uso efficace di tutti i dati di training sia per calcolare le TS che per apprendere il modello</em></p>\n<h4 id=\"leave-one-out-ts\">Leave-One-Out TS</h4>\n<p>A prima vista, la tecnica <strong>leave-one-out</strong> potrebbe sembrare funzionare bene:\n- Per esempi di training $\\mathbf{x}_k$: si prende $\\mathcal{D}_k = \\mathcal{D} \\setminus \\{\\mathbf{x}_k\\}$\n- Per esempi di test: si prende $\\mathcal{D}_k = \\mathcal{D}$</p>\n<p><strong>Sorprendentemente, questo NON previene il target leakage!</strong></p>\n<p><strong>Controesempio</strong>: Consideriamo una feature categorica costante: $x_k^i = A$ per tutti gli esempi.</p>\n<p>Sia $n^+$ il numero di esempi con $y = 1$. Allora:</p>\n$$\\hat{x}_k^i = \\frac{n^+ - y_k + a \\cdot p}{n - 1 + a}$$\n<p>Si può classificare perfettamente il training set con uno split alla soglia:</p>\n$$t = \\frac{n^+ - 0.5 + a \\cdot p}{n - 1 + a}$$\n<p>Infatti:\n- Se $y_k = 1$: $\\hat{x}_k^i = \\frac{n^+ - 1 + ap}{n - 1 + a} < t$\n- Se $y_k = 0$: $\\hat{x}_k^i = \\frac{n^+ + ap}{n - 1 + a} > t$</p>\n<h3 id=\"ordered-ts-la-soluzione-di-catboost\">Ordered TS: La Soluzione di CatBoost</h3>\n<p>CatBoost usa una strategia più efficace basata sul <strong>principio di ordinamento</strong> (ordering principle), idea centrale dell&rsquo;intero paper.</p>\n<p><strong>Ispirazione</strong>: Algoritmi di online learning che ricevono esempi di training sequenzialmente nel tempo. In questi algoritmi, i valori delle TS per ogni esempio dipendono solo dalla &ldquo;storia&rdquo; osservata fino a quel momento.</p>\n<p><strong>Adattamento all&rsquo;offline setting</strong>:</p>\n<ol>\n<li>Introduciamo un &ldquo;tempo&rdquo; artificiale: una <strong>permutazione casuale</strong> $\\sigma$ degli esempi di training</li>\n<li>Per ogni esempio, usiamo tutta la &ldquo;storia&rdquo; disponibile per calcolare la sua TS:</li>\n<li>$\\mathcal{D}_k = \\{\\mathbf{x}_j : \\sigma(j) < \\sigma(k)\\}$ per un esempio di training</li>\n<li>$\\mathcal{D}_k = \\mathcal{D}$ per un esempio di test</li>\n</ol>\n<p><strong>Proprietà delle Ordered TS</strong>:\n- ✓ Soddisfa P1 (nessun conditional shift)\n- ✓ Soddisfa P2 (usa tutti i dati per il training)\n- <strong>Problema</strong>: Se usiamo una sola permutazione, gli esempi iniziali hanno TS con varianza molto più alta degli esempi successivi</p>\n<p><strong>Soluzione</strong>: CatBoost usa <strong>diverse permutazioni</strong> per diversi step del gradient boosting (dettagli in Sezione Implementazione).</p>\n<hr />\n<h2 id=\"prediction-shift-e-ordered-boosting\">Prediction Shift e Ordered Boosting</h2>\n<h3 id=\"identificazione-del-problema\">Identificazione del Problema</h3>\n<p>In questa sezione riveliamo il problema del <strong>prediction shift</strong> nel gradient boosting, che non era stato precedentemente riconosciuto né affrontato.</p>\n<p>Come nel caso delle TS, il prediction shift è causato da un particolare tipo di target leakage.</p>\n<h3 id=\"il-problema-nella-pratica\">Il Problema nella Pratica</h3>\n<p>Ricordiamo che nella teoria (Sezione Background) il gradient step è definito come:</p>\n$$h^t = \\arg\\min_{h \\in \\mathcal{H}} \\mathbb{E}\\left(-g^t(\\mathbf{x}, y) - h(\\mathbf{x})\\right)^2$$\n<p><strong>In pratica</strong>, l&rsquo;aspettazione è sconosciuta e viene approssimata usando lo stesso dataset $\\mathcal{D}$:</p>\n$$h^t = \\arg\\min_{h \\in \\mathcal{H}} \\frac{1}{n} \\sum_{k=1}^n \\left(-g^t(\\mathbf{x}_k, y_k) - h(\\mathbf{x}_k)\\right)^2$$\n<p>dove ricordiamo che:</p>\n$$g^t(\\mathbf{x}_k, y_k) = \\frac{\\partial L(y_k, s)}{\\partial s}\\bigg|_{s=F^{t-1}(\\mathbf{x}_k)}$$\n<h3 id=\"la-catena-di-shift\">La Catena di Shift</h3>\n<p>Descriviamo la seguente catena di problemi:</p>\n<ol>\n<li>\n<p><strong>Shift dei gradienti</strong>: La distribuzione condizionale del gradiente $g^t(\\mathbf{x}_k, y_k) \\mid \\mathbf{x}_k$ (considerando la casualità di $\\mathcal{D} \\setminus \\{\\mathbf{x}_k\\}$) è shifted rispetto alla distribuzione su un esempio test $g^t(\\mathbf{x}, y) \\mid \\mathbf{x}$</p>\n</li>\n<li>\n<p><strong>Bias del base predictor</strong>: Il base predictor $h^t$ definito dall&rsquo;equazione pratica è biased rispetto alla soluzione dell&rsquo;equazione teorica</p>\n</li>\n<li>\n<p><strong>Impatto sulla generalizzazione</strong>: Questo influenza infine la capacità di generalizzazione del modello addestrato $F^t$</p>\n</li>\n</ol>\n<h3 id=\"causa-target-leakage\">Causa: Target Leakage</h3>\n<p>Questi problemi sono causati da <strong>target leakage</strong>. I gradienti usati ad ogni step sono stimati usando i valori target degli stessi data point su cui è stato costruito il modello corrente $F^{t-1}$.</p>\n<p><strong>Il problema fondamentale</strong>: La distribuzione condizionale $F^{t-1}(\\mathbf{x}_k) \\mid \\mathbf{x}_k$ per un esempio di training $\\mathbf{x}_k$ è shifted, in generale, rispetto alla distribuzione $F^{t-1}(\\mathbf{x}) \\mid \\mathbf{x}$ per un esempio test $\\mathbf{x}$.</p>\n<p>Questo è chiamato <strong>prediction shift</strong>.</p>\n<h3 id=\"letteratura-esistente\">Letteratura Esistente</h3>\n<p>Il problema è stato menzionato in precedenza ma mai formalmente definito:</p>\n<h4 id=\"iterated-bagging-breiman-2001\">Iterated Bagging (Breiman, 2001)</h4>\n<p>Basato sulla stima out-of-bag, costruisce un weak learner bagged ad ogni iterazione basandosi su stime residue &ldquo;out-of-bag&rdquo;.</p>\n<p><strong>Problema</strong>: Come dimostrato formalmente dagli autori nell&rsquo;Appendice, queste stime residue sono ancora shifted!</p>\n<p>Inoltre, lo schema di bagging aumenta il tempo di apprendimento di un fattore pari al numero di bucket di dati.</p>\n<h4 id=\"subsampling-friedman-2002\">Subsampling (Friedman, 2002)</h4>\n<p>Proposto il subsampling del dataset ad ogni iterazione.</p>\n<p><strong>Problema</strong>: Affronta il problema in modo molto più euristico e solo lo allevia, non lo risolve.</p>\n<h3 id=\"analisi-formale-caso-semplificato\">Analisi Formale: Caso Semplificato</h3>\n<p>Analizziamo formalmente il prediction shift in un caso semplice:\n- Task di regressione con funzione di perdita quadratica: $L(y, \\hat{y}) = (y - \\hat{y})^2$</p>\n<p>In questo caso, il gradiente negativo $-g^t(\\mathbf{x}_k, y_k)$ può essere sostituito dalla <strong>funzione residuo</strong>:</p>\n$$r^{t-1}(\\mathbf{x}_k, y_k) := y_k - F^{t-1}(\\mathbf{x}_k)$$\n<p>(abbiamo rimosso il moltiplicatore 2, che non è rilevante per l&rsquo;analisi)</p>\n<h4 id=\"setup-del-teorema\">Setup del Teorema</h4>\n<p>Assumiamo:\n- $m = 2$ feature: $x^1, x^2$\n- Entrambe sono variabili di Bernoulli i.i.d. con $p = 1/2$\n- $y = f^*(\\mathbf{x}) = c_1 x^1 + c_2 x^2$ (dipendenza lineare vera)\n- Facciamo $N = 2$ step di gradient boosting con decision stumps (alberi di profondità 1)\n- Step size $\\alpha = 1$\n- Otteniamo un modello $F = F^2 = h^1 + h^2$\n- Assumiamo (senza perdita di generalità) che $h^1$ sia basato su $x^1$ e $h^2$ su $x^2$</p>\n<h3 id=\"teorema-1-risultato-principale\">Teorema 1 (Risultato Principale)</h3>\n<p><strong>Parte 1</strong>: Se due campioni indipendenti $\\mathcal{D}_1$ e $\\mathcal{D}_2$ di dimensione $n$ sono usati per stimare $h^1$ e $h^2$ rispettivamente, allora:</p>\n$$\\mathbb{E}_{\\mathcal{D}_1, \\mathcal{D}_2} F^2(\\mathbf{x}) = f^*(\\mathbf{x}) + O(1/2^n)$$\n<p>per ogni $\\mathbf{x} \\in \\{0,1\\}^2$.</p>\n<p><strong>Interpretazione</strong>: Il modello addestrato è una stima <strong>unbiased</strong> della vera dipendenza $y = f^*(\\mathbf{x})$ (fino a un termine esponenzialmente piccolo, che si verifica per ragioni tecniche).</p>\n<p><strong>Parte 2</strong>: Se lo stesso dataset $\\mathcal{D} = \\mathcal{D}_1 = \\mathcal{D}_2$ è usato per entrambi $h^1$ e $h^2$, allora:</p>\n$$\\mathbb{E}_{\\mathcal{D}} F^2(\\mathbf{x}) = f^*(\\mathbf{x}) - \\frac{1}{n-1} c_2 \\left(x^2 - \\frac{1}{2}\\right) + O(1/2^n)$$\n<p><strong>Interpretazione</strong>: Soffriamo di un <strong>bias</strong> pari a $-\\frac{1}{n-1} c_2(x^2 - 1/2)$, che è:\n- Inversamente proporzionale alla dimensione dei dati $n$\n- Dipendente dalla relazione vera $f^*$ (proporzionale a $c_2$)</p>\n<h4 id=\"sketch-della-dimostrazione-parte-2\">Sketch della Dimostrazione (Parte 2)</h4>\n<p>Denotiamo con $\\xi_{st}$, $s,t \\in \\{0,1\\}$, il numero di esempi $(\\mathbf{x}_k, y_k) \\in \\mathcal{D}$ con $\\mathbf{x}_k = (s,t)$.</p>\n<p><strong>Step 1 - Primo stump</strong>: </p>\n$$h^1(s,t) = c_1 s + \\frac{c_2 \\xi_{s1}}{\\xi_{s0} + \\xi_{s1}}$$\n<p>Il valore atteso su un <strong>esempio test</strong> $\\mathbf{x}$ è:</p>\n$$\\mathbb{E}(h^1(\\mathbf{x})) = c_1 x^1 + \\frac{c_2}{2}$$\n<p>Il valore atteso su un <strong>esempio di training</strong> $\\mathbf{x}_k$ è diverso:</p>\n$$\\mathbb{E}(h^1(\\mathbf{x}_k)) = \\left(c_1 x^1 + \\frac{c_2}{2}\\right) - c_2 \\left(\\frac{2x^2 - 1}{n}\\right) + O(2^{-n})$$\n<p><strong>Questo è il prediction shift di $h^1$!</strong></p>\n<p><strong>Step 2 - Conseguenza sul secondo stump</strong>: Come conseguenza di questo shift, il valore atteso di $h^2$ è:</p>\n$$\\mathbb{E}(h^2(\\mathbf{x})) = c_2\\left(x^2 - \\frac{1}{2}\\right)\\left(1 - \\frac{1}{n-1}\\right) + O(2^{-n})$$\n<p>su un esempio test $\\mathbf{x}$.</p>\n<p><strong>Step 3 - Risultato finale</strong>:</p>\n$$\\mathbb{E}(h^1(\\mathbf{x}) + h^2(\\mathbf{x})) = f^*(\\mathbf{x}) - \\frac{1}{n-1} c_2\\left(x^2 - \\frac{1}{2}\\right) + O(1/2^n)$$\n<h3 id=\"connessione-con-le-greedy-ts\">Connessione con le Greedy TS</h3>\n<p>Ricordiamo che le greedy TS $\\hat{x}^i$ possono essere considerate come un semplice modello statistico che predice il target $y$.</p>\n<p>Soffrono di un problema simile: conditional shift di $\\hat{x}_k^i \\mid y_k$, causato dal target leakage (usare $y_k$ per calcolare $\\hat{x}_k^i$).</p>\n<hr />\n<h2 id=\"ordered-boosting\">Ordered Boosting</h2>\n<h3 id=\"idea-di-base\">Idea di Base</h3>\n<p>Proponiamo un algoritmo di boosting che non soffre del problema di prediction shift.</p>\n<p><strong>Scenario ideale</strong> (con dati illimitati): Ad ogni step del boosting, campioniamo un nuovo dataset $\\mathcal{D}_t$ indipendentemente e otteniamo residui unshifted applicando il modello corrente ai nuovi esempi di training.</p>\n<p><strong>Problema pratico</strong>: I dati etichettati sono limitati!</p>\n<h3 id=\"lapproccio-con-modelli-multipli\">L&rsquo;Approccio con Modelli Multipli</h3>\n<p>Assumiamo di voler imparare un modello con $I$ alberi.</p>\n<p><strong>Osservazione chiave</strong>: Per rendere il residuo $r^{I-1}(\\mathbf{x}_k, y_k)$ unshifted, abbiamo bisogno che $F^{I-1}$ sia addestrato <strong>senza</strong> l&rsquo;esempio $\\mathbf{x}_k$.</p>\n<p><strong>Problema apparente</strong>: Poiché abbiamo bisogno di residui unbiased per tutti gli esempi di training, nessun esempio può essere usato per training $F^{I-1}$, il che sembrerebbe rendere impossibile il processo di training.</p>\n<p><strong>Soluzione</strong>: È possibile mantenere un insieme di modelli che differiscono per gli esempi usati nel loro training. Poi, per calcolare il residuo su un esempio, usiamo un modello addestrato senza di esso.</p>\n<h3 id=\"applicazione-del-principio-di-ordinamento\">Applicazione del Principio di Ordinamento</h3>\n<p>Per costruire tale insieme di modelli, usiamo il <strong>principio di ordinamento</strong> (già applicato alle TS).</p>\n<p><strong>Algoritmo concettuale</strong>:\n1. Prendiamo una permutazione casuale $\\sigma$ degli esempi di training\n2. Manteniamo $n$ diversi <strong>modelli di supporto</strong> $M_1, \\ldots, M_n$ tali che il modello $M_i$ è appreso usando solo i primi $i$ esempi nella permutazione\n3. Ad ogni step, per ottenere il residuo per il $j$-esimo esempio, usiamo il modello $M_{j-1}$</p>\n<h3 id=\"algoritmo-1-ordered-boosting-versione-concettuale\">Algoritmo 1: Ordered Boosting (Versione Concettuale)</h3>\n<p><strong>Input</strong>: $\\{(\\mathbf{x}_k, y_k)\\}_{k=1}^n$, $I$ (numero di iterazioni)</p>\n<ol>\n<li>$\\sigma \\leftarrow$ permutazione casuale di $[1,n]$</li>\n<li>$M_i \\leftarrow 0$ per $i = 1, \\ldots, n$</li>\n<li><strong>Per</strong> $t \\leftarrow 1$ <strong>a</strong> $I$:</li>\n<li><strong>Per</strong> $i \\leftarrow 1$ <strong>a</strong> $n$:<ul>\n<li>$r_i \\leftarrow y_i - M_{\\sigma(i)-1}(\\mathbf{x}_i)$ (calcola residuo usando modello precedente)</li>\n</ul>\n</li>\n<li><strong>Per</strong> $i \\leftarrow 1$ <strong>a</strong> $n$:<ul>\n<li>$\\Delta M \\leftarrow \\text{LearnModel}((\\mathbf{x}_j, r_j) : \\sigma(j) \\leq i)$</li>\n<li>$M_i \\leftarrow M_i + \\Delta M$ (aggiorna modello)</li>\n</ul>\n</li>\n<li><strong>Return</strong> $M_n$</li>\n</ol>\n<p><strong>Problema pratico</strong>: Questo algoritmo non è fattibile nella maggior parte dei task pratici a causa della necessità di addestrare $n$ modelli diversi, il che aumenta la complessità e i requisiti di memoria di un fattore $n$.</p>\n<p><strong>Soluzione</strong>: In CatBoost, è implementata una modifica efficiente di questo algoritmo basata su GBDT con alberi di decisione come base predictors.</p>\n<h3 id=\"ordered-boosting-con-feature-categoriche\">Ordered Boosting con Feature Categoriche</h3>\n<p>Abbiamo proposto di usare permutazioni casuali per:\n- $\\sigma_{cat}$: per il calcolo delle TS\n- $\\sigma_{boost}$: per l&rsquo;ordered boosting</p>\n<p><strong>Domanda cruciale</strong>: Quando le combiniamo in un unico algoritmo, queste due permutazioni devono essere in qualche modo dipendenti?</p>\n<p><strong>Risposta</strong>: Sì! Devono coincidere: $\\sigma_{cat} = \\sigma_{boost}$</p>\n<p><strong>Perché?</strong> Se le permutazioni fossero diverse, esisterebbero esempi $\\mathbf{x}_i$ e $\\mathbf{x}_j$ tali che:\n- $\\sigma_{boost}(i) < \\sigma_{boost}(j)$, ma\n- $\\sigma_{cat}(i) > \\sigma_{cat}(j)$</p>\n<p>In questo caso:\n- Il modello $M_{\\sigma_{boost}(j)}$ è addestrato usando, in particolare, le TS dell&rsquo;esempio $\\mathbf{x}_i$\n- Ma queste TS sono calcolate usando $y_j$ (il target di $\\mathbf{x}_j$)\n- Questo può causare uno shift nella predizione $M_{\\sigma_{boost}(j)}(\\mathbf{x}_j)$</p>\n<p><strong>Garanzia teorica</strong>: Impostando $\\sigma_{cat} = \\sigma_{boost}$, garantiamo che il target $y_i$ non sia usato per addestrare $M_i$ (né per il calcolo delle TS, né per la stima del gradiente).</p>\n<hr />\n<h2 id=\"implementazione-pratica\">Implementazione Pratica</h2>\n<p>CatBoost ha due modalità di boosting:</p>\n<ol>\n<li><strong>Plain</strong>: L&rsquo;algoritmo GBDT standard con TS ordinate incorporate</li>\n<li><strong>Ordered</strong>: Una modifica efficiente dell&rsquo;Algoritmo 1 (Ordered Boosting)</li>\n</ol>\n<h3 id=\"permutazioni-multiple\">Permutazioni Multiple</h3>\n<p>All&rsquo;inizio, CatBoost genera $s+1$ permutazioni casuali indipendenti del dataset di training:</p>\n<ul>\n<li><strong>$\\sigma_1, \\ldots, \\sigma_s$</strong>: Usate per la valutazione degli split che definiscono le strutture degli alberi (nodi interni)</li>\n<li><strong>$\\sigma_0$</strong>: Usata per scegliere i valori delle foglie $b_j$ degli alberi ottenuti</li>\n</ul>\n<p><strong>Perché multiple permutazioni?</strong></p>\n<p>Per esempi con &ldquo;storia&rdquo; breve in una data permutazione:\n- Le TS hanno alta varianza\n- Le predizioni usate dall&rsquo;ordered boosting ($M_{\\sigma(i)-1}(\\mathbf{x}_i)$) hanno alta varianza</p>\n<p>Usare solo una permutazione aumenterebbe la varianza delle predizioni finali del modello.</p>\n<p><strong>Più permutazioni</strong> permettono di ridurre questo effetto, come confermato dagli esperimenti.</p>\n<h3 id=\"oblivious-decision-trees\">Oblivious Decision Trees</h3>\n<p>CatBoost usa come base predictors gli <strong>oblivious decision trees</strong> (anche chiamati decision tables).</p>\n<p><strong>Definizione</strong>: Un albero si dice &ldquo;oblivious&rdquo; se lo stesso criterio di splitting è usato attraverso un intero livello dell&rsquo;albero.</p>\n<p><strong>Proprietà</strong>:\n- Alberi bilanciati\n- Meno inclini all&rsquo;overfitting\n- Permettono di accelerare significativamente l&rsquo;esecuzione al tempo di test</p>\n<h3 id=\"procedura-di-costruzione-di-un-albero\">Procedura di Costruzione di un Albero</h3>\n<h4 id=\"modalita-ordered\">Modalità Ordered</h4>\n<p>Durante il processo di apprendimento, manteniamo i <strong>modelli di supporto</strong> $M_{r,j}$, dove:\n- $M_{r,j}(i)$ è la predizione corrente per il $i$-esimo esempio\n- Basata sui primi $j$ esempi nella permutazione $\\sigma_r$</p>\n<p><strong>Ad ogni iterazione $t$</strong>:</p>\n<ol>\n<li>\n<p><strong>Selezione permutazione</strong>: Campioniamo una permutazione casuale $\\sigma_r$ da $\\{\\sigma_1, \\ldots, \\sigma_s\\}$</p>\n</li>\n<li>\n<p><strong>Calcolo TS</strong>: Per le feature categoriche, tutte le TS sono calcolate secondo questa permutazione</p>\n</li>\n<li>\n<p><strong>Calcolo gradienti</strong>: Basandoci su $M_{r,j}(i)$, calcoliamo i gradienti corrispondenti:\n   $g_{r,j}(i) = \\frac{\\partial L(y_i, s)}{\\partial s}\\bigg|_{s=M_{r,j}(i)}$</p>\n</li>\n<li>\n<p><strong>Costruzione albero</strong>: Durante la costruzione dell&rsquo;albero, approssimiamo il gradiente $G$ in termini di similarità del coseno $\\cos(\\cdot, \\cdot)$, dove per ogni esempio $i$ prendiamo il gradiente $g_{r,\\sigma(i)-1}(i)$ (basato solo sugli esempi precedenti in $\\sigma_r$)</p>\n</li>\n<li>\n<p><strong>Valutazione split candidati</strong>: Il valore della foglia $\\Delta(i)$ per l&rsquo;esempio $i$ è ottenuto individualmente facendo la media dei gradienti $g_{r,\\sigma_r(i)-1}$ degli esempi precedenti $p$ che si trovano nella stessa foglia $\\text{leaf}_r(i)$ a cui appartiene l&rsquo;esempio $i$</p>\n</li>\n<li>\n<p><strong>Struttura comune</strong>: Quando la struttura dell&rsquo;albero $T_t$ (sequenza di attributi di splitting) è costruita, la usiamo per boostare <strong>tutti</strong> i modelli $M_{r',j}$. Una struttura comune è usata per tutti i modelli, ma l&rsquo;albero è aggiunto a diversi $M_{r',j}$ con diversi insiemi di valori delle foglie</p>\n</li>\n</ol>\n<h4 id=\"modalita-plain\">Modalità Plain</h4>\n<p>Funziona similmente a una procedura GBDT standard, ma:\n- Se le feature categoriche sono presenti, mantiene $s$ modelli di supporto $M_r$ corrispondenti alle TS basate su $\\sigma_1, \\ldots, \\sigma_s$</p>\n<h3 id=\"scelta-dei-valori-delle-foglie\">Scelta dei Valori delle Foglie</h3>\n<p>Dati tutti gli alberi costruiti, i valori delle foglie del modello finale $F$ sono calcolati dalla procedura standard di gradient boosting, ugualmente per entrambe le modalità:</p>\n<ol>\n<li>Gli esempi di training $i$ sono associati alle foglie $\\text{leaf}_0(i)$</li>\n<li>Si usa la permutazione $\\sigma_0$ per calcolare le TS</li>\n<li>Quando il modello finale $F$ è applicato a un nuovo esempio al tempo di test, si usano TS calcolate sull&rsquo;intero training data</li>\n</ol>\n<h3 id=\"trick-di-complessita\">Trick di Complessità</h3>\n<p>Nell&rsquo;implementazione pratica, si usa un trick importante che riduce significativamente la complessità computazionale.</p>\n<p><strong>Invece di</strong> $O(s \\cdot n^2)$ valori $M_{r,j}(i)$, memorizziamo e aggiorniamo solo i valori:</p>\n<p>$M'_{r,j}(i) := M_{r,2^j}(i)$</p>\n<p>per:\n- $j = 1, \\ldots, \\lceil \\log_2 n \\rceil$\n- Tutti gli $i$ con $\\sigma_r(i) \\leq 2^{j+1}$</p>\n<p><strong>Riduzione</strong>: Questo riduce il numero di predizioni di supporto mantenute a $O(s \\cdot n)$.</p>\n<h3 id=\"complessita-computazionale\">Complessità Computazionale</h3>\n<p>La complessità computazionale per iterazione è mostrata nella seguente tabella:</p>\n<table>\n<thead>\n<tr>\n<th>Procedura</th>\n<th>Complessità</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>CalcGradient</td>\n<td>$O(s \\cdot n)$</td>\n</tr>\n<tr>\n<td>Build $T$</td>\n<td>$O(\\|C\\| \\cdot n)$</td>\n</tr>\n<tr>\n<td>Calc values $b_j^t$</td>\n<td>$O(n)$</td>\n</tr>\n<tr>\n<td>Update $M$</td>\n<td>$O(s \\cdot n)$</td>\n</tr>\n<tr>\n<td>Calc ordered TS</td>\n<td>$O(N_{TS,t} \\cdot n)$</td>\n</tr>\n</tbody>\n</table>\n<p>dove:\n- $C$ è l&rsquo;insieme di split candidati da considerare all&rsquo;iterazione data\n- $N_{TS,t}$ è il numero di TS da calcolare all&rsquo;iterazione $t$</p>\n<p><strong>Conclusione</strong>: L&rsquo;implementazione di ordered boosting con alberi di decisione ha la <strong>stessa complessità asintotica</strong> del GBDT standard con TS ordinate.</p>\n<p>Rispetto ad altri tipi di TS, le ordered TS rallentano di un fattore $s$ le procedure: CalcGradient, aggiornamento modelli $M$, e calcolo delle TS.</p>\n<h3 id=\"combinazioni-di-feature\">Combinazioni di Feature</h3>\n<p>Un dettaglio importante di CatBoost è l&rsquo;uso di <strong>combinazioni di feature categoriche</strong> come feature categoriche aggiuntive.</p>\n<p><strong>Motivazione</strong>: Catturano dipendenze di ordine superiore, come l&rsquo;informazione congiunta di user ID e topic dell&rsquo;annuncio nel task di ad click prediction.</p>\n<p><strong>Problema</strong>: Il numero di combinazioni possibili cresce esponenzialmente con il numero di feature categoriche nel dataset.</p>\n<p><strong>Soluzione greedy di CatBoost</strong>: Per ogni split di un albero, CatBoost combina (concatena):\n- Tutte le feature categoriche (e loro combinazioni) già usate per split precedenti nell&rsquo;albero corrente\n- Con tutte le feature categoriche nel dataset</p>\n<p>Le combinazioni sono convertite in TS al volo.</p>\n<h3 id=\"bayesian-bootstrap\">Bayesian Bootstrap</h3>\n<p>Prima di addestrare un albero, si assegna un peso $w_i = a_i^t$ a ogni esempio $i$, dove $a_i^t$ sono generati secondo la procedura di Bayesian bootstrap.</p>\n<p>Questi pesi sono usati come moltiplicatori per i gradienti quando si calcolano:\n- $\\Delta(i)$\n- Le componenti del vettore $\\Delta - G$ per definire $\\text{loss}(T_c)$</p>\n<p><strong>Motivazione</strong>: Anche se il subsampling da solo non può evitare completamente il problema di prediction shift, si è dimostrato efficace nella pratica.</p>\n<h3 id=\"gestione-degli-esempi-iniziali\">Gestione degli Esempi Iniziali</h3>\n<p>Per esempi $i$ con valori piccoli di $\\sigma_r(i)$, la varianza di $g_{r,\\sigma_r(i)-1}(i)$ può essere alta.</p>\n<p><strong>Soluzione</strong>: Si scartano i $\\Delta(i)$ dall&rsquo;inizio della permutazione quando si calcola la loss. Specificamente, si eliminano le componenti corrispondenti dei vettori $G$ e $\\Delta$ quando si calcola la similarità del coseno.</p>\n<hr />\n<h2 id=\"risultati-sperimentali\">Risultati Sperimentali</h2>\n<h3 id=\"setup-sperimentale\">Setup Sperimentale</h3>\n<p>Gli esperimenti confrontano CatBoost con le librerie open-source più popolari:\n- <strong>XGBoost</strong>\n- <strong>LightGBM</strong></p>\n<p>Su vari task di machine learning ben noti.</p>\n<h4 id=\"preprocessing\">Preprocessing</h4>\n<p>Per XGBoost, LightGBM e il raw setting di CatBoost:\n- Le feature categoriche sono preprocessate calcolando ordered TS basate su una permutazione casuale degli esempi del training set\n- I valori risultanti delle TS sono considerati feature numeriche</p>\n<h4 id=\"tuning-dei-parametri\">Tuning dei Parametri</h4>\n<p>Si usa l&rsquo;algoritmo di ottimizzazione sequenziale <strong>Tree Parzen Estimator</strong> (implementato nella libreria Hyperopt) con 50 step, minimizzando la logloss.</p>\n<h4 id=\"train-test-split\">Train-Test Split</h4>\n<ul>\n<li>80% training set</li>\n<li>20% test set</li>\n<li>Cross-validazione a 5 fold per il tuning dei parametri</li>\n</ul>\n<h3 id=\"dataset-utilizzati\">Dataset Utilizzati</h3>\n<p>Gli esperimenti sono stati condotti su 9 dataset:</p>\n<ol>\n<li><strong>Adult</strong> (48,842 istanze, 15 feature): Previsione se una persona guadagna più di 50K all&rsquo;anno</li>\n<li><strong>Amazon</strong> (32,769 istanze, 10 feature): Kaggle Amazon Employee challenge</li>\n<li><strong>Click Prediction</strong> (399,482 istanze, 12 feature): Previsione click su annunci (KDD Cup 2012)</li>\n<li><strong>Epsilon</strong> (400,000 istanze, 2000 feature): PASCAL Challenge 2008</li>\n<li><strong>KDD Appetency</strong> (50,000 istanze, 231 feature)</li>\n<li><strong>KDD Churn</strong> (50,000 istanze, 231 feature)</li>\n<li><strong>KDD Internet</strong> (10,108 istanze, 69 feature): Versione binarizzata</li>\n<li><strong>KDD Upselling</strong> (50,000 istanze, 231 feature)</li>\n<li><strong>Kick Prediction</strong> (72,983 istanze, 36 feature): Kaggle &ldquo;Don&rsquo;t Get Kicked!&rdquo; challenge</li>\n</ol>\n<h3 id=\"risultati-confronto-con-baseline\">Risultati: Confronto con Baseline</h3>\n<p>CatBoost (modalità Ordered) supera gli altri algoritmi su <strong>tutti</strong> i dataset considerati.</p>\n<p><strong>Significatività statistica</strong>: Eccetto tre dataset (Appetency, Churn e Upselling), i miglioramenti sono statisticamente significativi con p-value $\\ll 0.01$ (paired one-tailed t-test).</p>\n<h4 id=\"risultati-dettagliati-logloss-zero-one-loss\">Risultati Dettagliati (Logloss / Zero-one loss)</h4>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>CatBoost</th>\n<th>LightGBM</th>\n<th>XGBoost</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Adult</td>\n<td><strong>0.270 / 0.127</strong></td>\n<td>+2.4% / +1.9%</td>\n<td>+2.2% / +1.0%</td>\n</tr>\n<tr>\n<td>Amazon</td>\n<td><strong>0.139 / 0.044</strong></td>\n<td>+17% / +21%</td>\n<td>+17% / +21%</td>\n</tr>\n<tr>\n<td>Click</td>\n<td><strong>0.392 / 0.156</strong></td>\n<td>+1.2% / +1.2%</td>\n<td>+1.2% / +1.2%</td>\n</tr>\n<tr>\n<td>Epsilon</td>\n<td><strong>0.265 / 0.109</strong></td>\n<td>+1.5% / +4.1%</td>\n<td>+11% / +12%</td>\n</tr>\n<tr>\n<td>Appetency</td>\n<td><strong>0.072 / 0.018</strong></td>\n<td>+0.4% / +0.2%</td>\n<td>+0.4% / +0.7%</td>\n</tr>\n<tr>\n<td>Churn</td>\n<td><strong>0.232 / 0.072</strong></td>\n<td>+0.1% / +0.6%</td>\n<td>+0.5% / +1.6%</td>\n</tr>\n<tr>\n<td>Internet</td>\n<td><strong>0.209 / 0.094</strong></td>\n<td>+6.8% / +8.6%</td>\n<td>+7.9% / +8.0%</td>\n</tr>\n<tr>\n<td>Upselling</td>\n<td><strong>0.166 / 0.049</strong></td>\n<td>+0.3% / +0.1%</td>\n<td>+0.04% / +0.3%</td>\n</tr>\n<tr>\n<td>Kick</td>\n<td><strong>0.286 / 0.095</strong></td>\n<td>+3.5% / +4.4%</td>\n<td>+3.2% / +4.1%</td>\n</tr>\n</tbody>\n</table>\n<p>I valori nelle colonne LightGBM e XGBoost rappresentano l&rsquo;aumento percentuale relativo rispetto a CatBoost.</p>\n<p><strong>Miglioramenti particolarmente significativi</strong>:\n- Amazon: +17% rispetto ai baseline\n- Internet: +6.8%-7.9% rispetto ai baseline\n- Epsilon: +11% rispetto a XGBoost</p>\n<h3 id=\"confronto-tra-modalita-ordered-e-plain\">Confronto tra Modalità Ordered e Plain</h3>\n<h4 id=\"risultati-generali\">Risultati Generali</h4>\n<p>La modalità Ordered è particolarmente utile su <strong>dataset piccoli</strong>.</p>\n<p>Il beneficio maggiore dall&rsquo;Ordered si osserva su:\n- <strong>Adult</strong>: 40K esempi di training\n- <strong>Internet</strong>: &lt; 40K esempi di training</p>\n<h4 id=\"risultati-dettagliati-plain-vs-ordered\">Risultati Dettagliati (Plain vs Ordered)</h4>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>Plain Logloss</th>\n<th>Plain Zero-one</th>\n<th>Variazione</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Adult</td>\n<td>0.272</td>\n<td>0.127</td>\n<td>+1.1% / -0.1%</td>\n</tr>\n<tr>\n<td>Amazon</td>\n<td>0.139</td>\n<td>0.044</td>\n<td>-0.6% / -1.5%</td>\n</tr>\n<tr>\n<td>Click</td>\n<td>0.392</td>\n<td>0.156</td>\n<td>-0.05% / +0.19%</td>\n</tr>\n<tr>\n<td>Epsilon</td>\n<td>0.266</td>\n<td>0.110</td>\n<td>+0.6% / +0.9%</td>\n</tr>\n<tr>\n<td>Appetency</td>\n<td>0.072</td>\n<td>0.018</td>\n<td>+0.5% / +1.5%</td>\n</tr>\n<tr>\n<td>Churn</td>\n<td>0.232</td>\n<td>0.072</td>\n<td>-0.06% / -0.17%</td>\n</tr>\n<tr>\n<td>Internet</td>\n<td>0.217</td>\n<td>0.099</td>\n<td>+3.9% / +5.4%</td>\n</tr>\n<tr>\n<td>Upselling</td>\n<td>0.166</td>\n<td>0.049</td>\n<td>+0.1% / +0.4%</td>\n</tr>\n<tr>\n<td>Kick</td>\n<td>0.285</td>\n<td>0.095</td>\n<td>-0.2% / -0.1%</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"esperimento-con-dataset-filtrati\">Esperimento con Dataset Filtrati</h4>\n<p>Per validare l&rsquo;ipotesi che il bias sia più grande per dataset più piccoli:\n- Si addestra CatBoost in modalità Ordered e Plain su dataset filtrati casualmente\n- Si confrontano le loss ottenute</p>\n<p><strong>Risultato</strong>: Per dataset più piccoli, la performance relativa della modalità Plain peggiora, confermando l&rsquo;ipotesi che il bias (secondo il Teorema 1) sia più grande per dataset più piccoli.</p>\n<h3 id=\"analisi-delle-target-statistics\">Analisi delle Target Statistics</h3>\n<p>Confronto di diverse TS introdotte nella sezione corrispondente, tutte implementate come opzioni di CatBoost in modalità Ordered:</p>\n<h4 id=\"risultati-variazione-relativa-rispetto-a-ordered-ts\">Risultati (Variazione relativa rispetto a Ordered TS)</h4>\n<table>\n<thead>\n<tr>\n<th>Dataset</th>\n<th>Greedy</th>\n<th>Holdout</th>\n<th>Leave-one-out</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>Adult</td>\n<td>+1.1% / +0.8%</td>\n<td>+2.1% / +2.0%</td>\n<td>+5.5% / +3.7%</td>\n</tr>\n<tr>\n<td>Amazon</td>\n<td>+40% / +32%</td>\n<td>+8.3% / +8.3%</td>\n<td>+4.5% / +5.6%</td>\n</tr>\n<tr>\n<td>Click</td>\n<td>+13% / +6.7%</td>\n<td>+1.5% / +0.5%</td>\n<td>+2.7% / +0.9%</td>\n</tr>\n<tr>\n<td>Appetency</td>\n<td>+24% / +0.7%</td>\n<td>+1.6% / -0.5%</td>\n<td>+8.5% / +0.7%</td>\n</tr>\n<tr>\n<td>Churn</td>\n<td>+12% / +2.1%</td>\n<td>+0.9% / +1.3%</td>\n<td>+1.6% / +1.8%</td>\n</tr>\n<tr>\n<td>Internet</td>\n<td>+33% / +22%</td>\n<td>+2.6% / +1.8%</td>\n<td>+27% / +19%</td>\n</tr>\n<tr>\n<td>Upselling</td>\n<td>+57% / +50%</td>\n<td>+1.6% / +0.9%</td>\n<td>+3.9% / +2.9%</td>\n</tr>\n<tr>\n<td>Kick</td>\n<td>+22% / +28%</td>\n<td>+1.3% / +0.32%</td>\n<td>+3.7% / +3.3%</td>\n</tr>\n</tbody>\n</table>\n<p><strong>Osservazioni</strong>:</p>\n<ol>\n<li><strong>Ordered TS</strong> superano significativamente tutti gli altri approcci</li>\n<li><strong>Holdout TS</strong> è il migliore tra i baseline per la maggior parte dei dataset (non soffre di conditional shift - P1), ma è peggiore di ordered TS (meno uso efficace dei dati - P2)</li>\n<li><strong>Leave-one-out</strong> è solitamente migliore di greedy TS, ma può essere molto peggiore su alcuni dataset (es. Adult)</li>\n<li><strong>Greedy TS</strong> soffre sia delle categorie a bassa frequenza che di quelle ad alta frequenza</li>\n</ol>\n<h3 id=\"combinazioni-di-feature_1\">Combinazioni di Feature</h3>\n<p>Cambiare il numero $c_{max}$ di feature consentite per le combinazioni:\n- Da 1 a 2: <strong>miglioramento medio di 1.86%</strong> (fino a 11.3%)\n- Da 1 a 3: <strong>miglioramento di 2.04%</strong>\n- Ulteriore aumento di $c_{max}$: non influenza significativamente la performance</p>\n<h3 id=\"numero-di-permutazioni\">Numero di Permutazioni</h3>\n<p>Effetto del numero $s$ di permutazioni sulla performance:\n- $s = 3$: diminuzione media di logloss di <strong>0.19%</strong> rispetto a $s = 1$\n- $s = 9$: diminuzione media di logloss di <strong>0.38%</strong> rispetto a $s = 1$</p>\n<p><strong>Conclusione</strong>: Aumentare $s$ diminuisce leggermente la logloss, ma i guadagni diminuiscono.</p>\n<h3 id=\"tempi-di-esecuzione\">Tempi di Esecuzione</h3>\n<p>Confronto dei tempi su dataset Epsilon:</p>\n<table>\n<thead>\n<tr>\n<th>Algoritmo</th>\n<th>Tempo per albero</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>CatBoost Plain</strong></td>\n<td><strong>1.1 s</strong></td>\n</tr>\n<tr>\n<td>CatBoost Ordered</td>\n<td>1.9 s</td>\n</tr>\n<tr>\n<td>XGBoost</td>\n<td>3.9 s</td>\n</tr>\n<tr>\n<td><strong>LightGBM</strong></td>\n<td><strong>1.1 s</strong></td>\n</tr>\n</tbody>\n</table>\n<p><strong>Osservazioni</strong>:\n- CatBoost Plain e LightGBM sono i più veloci\n- Ordered mode è circa <strong>1.7 volte più lento</strong> (come atteso)\n- CatBoost ha anche un&rsquo;implementazione GPU altamente efficiente (dettagli su GitHub)</p>\n<hr />\n<h2 id=\"conclusioni\">Conclusioni</h2>\n<h3 id=\"contributi-principali\">Contributi Principali</h3>\n<ol>\n<li>\n<p><strong>Identificazione e analisi del problema di prediction shift</strong> presente in tutte le implementazioni esistenti di gradient boosting</p>\n</li>\n<li>\n<p><strong>Proposta di una soluzione generale</strong>: ordered boosting con ordered TS</p>\n</li>\n<li>\n<p><strong>Implementazione pratica</strong>: CatBoost, una nuova libreria di gradient boosting</p>\n</li>\n<li>\n<p><strong>Risultati empirici</strong>: CatBoost supera i principali pacchetti GBDT e porta a nuovi risultati state-of-the-art su benchmark comuni</p>\n</li>\n</ol>\n<h3 id=\"innovazioni-algoritmiche\">Innovazioni Algoritmiche</h3>\n<h4 id=\"ordered-target-statistics\">Ordered Target Statistics</h4>\n<ul>\n<li>Evitano il conditional shift (proprietà P1)</li>\n<li>Usano efficientemente tutti i dati di training (proprietà P2)</li>\n<li>Basate sul principio di ordinamento (permutazioni casuali)</li>\n<li>Superiori a greedy TS, holdout TS, e leave-one-out TS</li>\n</ul>\n<h4 id=\"ordered-boosting_1\">Ordered Boosting</h4>\n<ul>\n<li>Elimina il prediction shift causato da target leakage</li>\n<li>Mantiene modelli di supporto multipli</li>\n<li>Usa permutazioni casuali per simulare un &ldquo;tempo artificiale&rdquo;</li>\n<li>Implementazione efficiente con complessità $O(s \\cdot n)$ invece di $O(n^2)$</li>\n</ul>\n<h4 id=\"gestione-delle-feature-categoriche\">Gestione delle Feature Categoriche</h4>\n<ul>\n<li>Conversione diretta a target statistics numeriche</li>\n<li>Combinazioni di feature per catturare interazioni di ordine superiore</li>\n<li>Efficiente per feature ad alta cardinalità</li>\n</ul>\n<h3 id=\"vantaggi-pratici\">Vantaggi Pratici</h3>\n<ol>\n<li><strong>Performance superiore</strong>: Miglioramenti significativi su tutti i dataset testati</li>\n<li><strong>Robustezza</strong>: Particolarmente efficace su dataset piccoli</li>\n<li><strong>Efficienza</strong>: Complessità computazionale comparabile ai metodi standard</li>\n<li><strong>Flessibilità</strong>: Due modalità (Plain e Ordered) per diversi scenari</li>\n<li><strong>Gestione nativa delle categoriche</strong>: Nessun preprocessing manuale necessario</li>\n</ol>\n<h3 id=\"aspetti-teorici-rilevanti\">Aspetti Teorici Rilevanti</h3>\n<p>Il paper fornisce:\n- <strong>Analisi formale</strong> del prediction shift (Teorema 1)\n- <strong>Dimostrazione matematica</strong> del bias introdotto dal riutilizzo dei dati\n- <strong>Garanzie teoriche</strong> che ordered boosting elimina questo bias\n- <strong>Spiegazione</strong> del perché permutazioni identiche $\\sigma_{cat} = \\sigma_{boost}$ sono necessarie</p>\n<h3 id=\"limitazioni-e-considerazioni\">Limitazioni e Considerazioni</h3>\n<ol>\n<li><strong>Ordered mode</strong>: Circa 1.7 volte più lento di Plain mode</li>\n<li><strong>Permutazioni multiple</strong>: Richiedono più memoria ma riducono la varianza</li>\n<li><strong>Trade-off</strong>: Bilanciamento tra accuratezza e velocità</li>\n</ol>\n<h3 id=\"impatto\">Impatto</h3>\n<p>CatBoost rappresenta un avanzamento significativo nel gradient boosting:\n- Risolve problemi teorici fondamentali precedentemente non riconosciuti\n- Fornisce risultati empirici superiori\n- È open-source e ampiamente utilizzato nella pratica</p>\n<p>L&rsquo;identificazione e risoluzione del prediction shift è un contributo importante per la comunità di machine learning, con implicazioni che vanno oltre CatBoost stesso.</p>\n<hr />\n<h2 id=\"riferimenti-e-approfondimenti\">Riferimenti e Approfondimenti</h2>\n<h3 id=\"concetti-chiave-da-ricordare\">Concetti Chiave da Ricordare</h3>\n<ol>\n<li><strong>Target Leakage</strong>: Quando informazioni sul target &ldquo;fuoriescono&rdquo; nel processo di training, causando overfitting</li>\n<li><strong>Conditional Shift</strong>: Quando $P(X|Y)$ differisce tra training e test</li>\n<li><strong>Prediction Shift</strong>: Quando $P(F(\\mathbf{x})|\\mathbf{x})$ differisce tra training e test</li>\n<li><strong>Ordering Principle</strong>: Usare permutazioni casuali per simulare un ordine temporale</li>\n<li><strong>Oblivious Trees</strong>: Alberi che usano lo stesso split criterion su ogni livello</li>\n</ol>\n<h3 id=\"perche-catboost-funziona\">Perché CatBoost Funziona</h3>\n<p>La combinazione di:\n- Ordered boosting (elimina prediction shift)\n- Ordered target statistics (elimina conditional shift)\n- Feature combinations (cattura interazioni complesse)\n- Oblivious trees (riduce overfitting, accelera inferenza)\n- Permutazioni multiple (riduce varianza)</p>\n<p>porta a un algoritmo che è sia teoricamente fondato che empiricamente superiore.</p>\n<h3 id=\"applicazioni-pratiche\">Applicazioni Pratiche</h3>\n<p>CatBoost è particolarmente adatto per:\n- <strong>Click prediction</strong>: Feature categoriche come user ID, region, ad\n- <strong>Recommendation systems</strong>: User-item interactions\n- <strong>Fraud detection</strong>: Transazioni con molte feature categoriche\n- <strong>Ranking problems</strong>: Web search, e-commerce\n- <strong>Qualsiasi problema con feature categoriche ad alta cardinalità</strong></p>"
}