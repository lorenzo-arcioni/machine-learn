{
  "title": "Regressione Ponderata (Weighted Regression)",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n/* Blocchi di codice sempre visibili */\n.code-visible {\n    border: 1px solid #e5e7eb;\n    border-radius: 12px;\n    background: #f9fafb;\n    margin: 16px 0;\n}\n.code-visible .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<p>La <strong>Regressione Ponderata</strong> (Weighted Regression) è un&rsquo;estensione della <a href=\"/theory/supervised-learning/Linear Models/Regressione Lineare\" class=\"text-blue-600 hover:underline\">Regressione Lineare</a> che permette di assegnare <strong>pesi differenti</strong> alle osservazioni durante il processo di stima dei parametri. A differenza della regressione lineare ordinaria dove tutte le osservazioni contribuiscono ugualmente alla funzione di costo, la regressione ponderata riflette l&rsquo;<strong>importanza relativa</strong> o l&rsquo;<strong>affidabilità</strong> di ciascun punto dati.</p>\n<h2 id=\"1-motivazione-e-contesto\"><strong>1. Motivazione e Contesto</strong></h2>\n<h3 id=\"11-problemi-della-regressione-lineare-ordinaria\"><strong>1.1. Problemi della Regressione Lineare Ordinaria</strong></h3>\n<p>Nella regressione lineare classica, l&rsquo;assunzione di <strong>omoschedasticità</strong> (varianza costante degli errori) e <strong>uguale affidabilità</strong> di tutte le osservazioni non sempre riflette la realtà. Situazioni comuni dove queste assunzioni sono violate includono:</p>\n<ol>\n<li><strong>Eteroschedasticità</strong>: La varianza dell&rsquo;errore varia tra le osservazioni</li>\n<li><strong>Affidabilità variabile</strong>: Alcune misurazioni sono intrinsecamente più precise di altre</li>\n<li><strong>Dimensione del campione variabile</strong>: Osservazioni rappresentano gruppi di dimensioni diverse</li>\n<li><strong>Outliers noti</strong>: Alcuni punti sono chiaramente anomali ma non eliminabili</li>\n<li><strong>Precisione strumentale</strong>: Diversi strumenti di misura hanno accuratezze differenti</li>\n</ol>\n<h3 id=\"12-filosofia-della-ponderazione\"><strong>1.2. Filosofia della Ponderazione</strong></h3>\n<p>La regressione ponderata risolve questi problemi assegnando un <strong>peso</strong> $w_i$ a ciascuna osservazione $i$:</p>\n<ul>\n<li><strong>Peso alto</strong> ($w_i$ grande): Osservazione più affidabile/importante → maggiore influenza sulla stima</li>\n<li><strong>Peso basso</strong> ($w_i$ piccolo): Osservazione meno affidabile → minore influenza sulla stima  </li>\n<li><strong>Peso zero</strong> ($w_i = 0$): Osservazione ignorata completamente</li>\n</ul>\n<h2 id=\"2-formulazione-matematica\"><strong>2. Formulazione Matematica</strong></h2>\n<h3 id=\"21-problema-di-ottimizzazione\"><strong>2.1. Problema di Ottimizzazione</strong></h3>\n<p>Dato un dataset $\\mathcal{D} = \\{(\\mathbf{x}_i, y_i, w_i)\\}_{i=1}^n$ dove $w_i > 0$ sono i pesi, il problema di ottimizzazione diventa:</p>\n$$\n\\min_{\\mathbf{w}} \\sum_{i=1}^{n} w_i \\left( y_i - \\mathbf{x}_i^T \\boldsymbol{\\theta} \\right)^2\n$$\n<p>Dove:\n- $\\boldsymbol{\\theta} \\in \\mathbb{R}^{d+1}$ è il vettore dei parametri (incluso il bias)\n- $\\mathbf{x}_i \\in \\mathbb{R}^{d+1}$ è il vettore delle features (con 1 aggiunto per il bias)\n- $w_i > 0$ è il peso dell&rsquo;osservazione $i$\n- $y_i$ è la variabile target</p>\n<h3 id=\"22-interpretazione-probabilistica\"><strong>2.2. Interpretazione Probabilistica</strong></h3>\n<p>La regressione ponderata equivale alla <strong>Maximum Likelihood Estimation</strong> quando gli errori seguono distribuzioni normali con <strong>varianze eterogenee</strong>:</p>\n$$\n\\epsilon_i \\sim \\mathcal{N}(0, \\sigma_i^2)\n$$\n<p>Il peso ottimale è inversamente proporzionale alla varianza:\n$$\nw_i = \\frac{1}{\\sigma_i^2}\n$$</p>\n<p>Questo significa che osservazioni con <strong>varianza più bassa</strong> (più precise) ricevono <strong>peso maggiore</strong>.</p>\n<h3 id=\"23-formulazione-matriciale\"><strong>2.3. Formulazione Matriciale</strong></h3>\n<p>In notazione matriciale, il problema diventa:</p>\n$$\n\\min_{\\boldsymbol{\\theta}} (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta})\n$$\n<p>Dove:\n- $\\mathbf{X} \\in \\mathbb{R}^{n \\times (d+1)}$ è la matrice di design\n- $\\mathbf{y} \\in \\mathbb{R}^{n \\times 1}$ è il vettore target<br />\n- $\\mathbf{W} \\in \\mathbb{R}^{n \\times n}$ è la matrice diagonale dei pesi:</p>\n$$\n\\mathbf{W} = \\begin{bmatrix}\nw_1 & 0 & \\cdots & 0 \\\\\n0 & w_2 & \\cdots & 0 \\\\\n\\vdots & \\vdots & \\ddots & \\vdots \\\\\n0 & 0 & \\cdots & w_n\n\\end{bmatrix}\n$$\n<h2 id=\"3-soluzione-analitica-weighted-least-squares-wls\"><strong>3. Soluzione Analitica: Weighted Least Squares (WLS)</strong></h2>\n<h3 id=\"31-derivazione-della-soluzione\"><strong>3.1. Derivazione della Soluzione</strong></h3>\n<p>La funzione di costo pesata è:\n$$\nJ(\\boldsymbol{\\theta}) = (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta})^T \\mathbf{W} (\\mathbf{y} - \\mathbf{X}\\boldsymbol{\\theta})\n$$</p>\n<p>Espandendo:\n$$\nJ(\\boldsymbol{\\theta}) = \\mathbf{y}^T \\mathbf{W} \\mathbf{y} - 2\\mathbf{y}^T \\mathbf{W} \\mathbf{X} \\boldsymbol{\\theta} + \\boldsymbol{\\theta}^T \\mathbf{X}^T \\mathbf{W} \\mathbf{X} \\boldsymbol{\\theta}\n$$</p>\n<h3 id=\"32-calcolo-del-gradiente\"><strong>3.2. Calcolo del Gradiente</strong></h3>\n$$\n\\frac{\\partial J}{\\partial \\boldsymbol{\\theta}} = -2\\mathbf{X}^T \\mathbf{W} \\mathbf{y} + 2\\mathbf{X}^T \\mathbf{W} \\mathbf{X} \\boldsymbol{\\theta}\n$$\n<h3 id=\"33-soluzione-ottimale\"><strong>3.3. Soluzione Ottimale</strong></h3>\n<p>Ponendo il gradiente uguale a zero:\n$$\n\\mathbf{X}^T \\mathbf{W} \\mathbf{X} \\boldsymbol{\\theta} = \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$</p>\n<p>La soluzione in forma chiusa è:\n$$\n\\boldsymbol{\\theta}^* = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$</p>\n<h3 id=\"34-confronto-con-ols\"><strong>3.4. Confronto con OLS</strong></h3>\n<p>La formula è identica a quella della <a href=\"/theory/supervised-learning/Linear Models/Regressione Lineare\" class=\"text-blue-600 hover:underline\">Regressione Lineare</a>, ma con l&rsquo;aggiunta della matrice dei pesi $\\mathbf{W}$:</p>\n<table>\n<thead>\n<tr>\n<th>Metodo</th>\n<th>Formula</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>OLS</strong></td>\n<td>$\\boldsymbol{\\theta}^* = (\\mathbf{X}^T \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{y}$</td>\n</tr>\n<tr>\n<td><strong>WLS</strong></td>\n<td>$\\boldsymbol{\\theta}^* = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}$</td>\n</tr>\n</tbody>\n</table>\n<p>Quando $\\mathbf{W} = \\mathbf{I}$ (tutti i pesi uguali a 1), WLS si riduce a OLS.</p>\n<h2 id=\"4-proprieta-statistiche\"><strong>4. Proprietà Statistiche</strong></h2>\n<h3 id=\"41-stimatore-blue\"><strong>4.1. Stimatore BLUE</strong></h3>\n<p>Sotto le assunzioni di Gauss-Markov modificate per la regressione ponderata, WLS produce lo stimatore <strong>Best Linear Unbiased Estimator (BLUE)</strong>:</p>\n<ol>\n<li><strong>Linearità</strong>: $\\boldsymbol{\\theta}^*$ è una combinazione lineare di $\\mathbf{y}$</li>\n<li><strong>Non distorsione</strong>: $\\mathbb{E}[\\boldsymbol{\\theta}^*] = \\boldsymbol{\\theta}_{\\text{vero}}$  </li>\n<li><strong>Minima varianza</strong>: Tra tutti gli stimatori lineari non distorti</li>\n</ol>\n<h3 id=\"42-matrice-di-varianza-covarianza\"><strong>4.2. Matrice di Varianza-Covarianza</strong></h3>\n<p>La matrice di varianza-covarianza dello stimatore WLS è:\n$$\n\\text{Var}(\\boldsymbol{\\theta}^*) = \\sigma^2 (\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}\n$$</p>\n<p>Gli errori standard dei coefficienti sono:\n$$\nSE(\\theta_j) = \\sigma \\sqrt{[(\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1}]_{jj}}\n$$</p>\n<h3 id=\"43-stima-della-varianza-residua\"><strong>4.3. Stima della Varianza Residua</strong></h3>\n$$\n\\hat{\\sigma}^2 = \\frac{\\sum_{i=1}^n w_i (y_i - \\hat{y}_i)^2}{n - p - 1}\n$$\n<p>dove $p$ è il numero di predittori (escluso il bias).</p>\n<h2 id=\"5-scelta-dei-pesi\"><strong>5. Scelta dei Pesi</strong></h2>\n<h3 id=\"51-pesi-basati-sulla-varianza\"><strong>5.1. Pesi Basati sulla Varianza</strong></h3>\n<p>Quando la varianza dell&rsquo;errore è nota o stimabile:\n$$\nw_i = \\frac{1}{\\sigma_i^2}\n$$</p>\n<p><strong>Esempi:</strong>\n- Misurazioni con precisione nota\n- Dati aggregati con numerosità diverse per gruppo\n- Strumenti con accuratezza calibrata</p>\n<h3 id=\"52-pesi-basati-sulla-dimensione-del-campione\"><strong>5.2. Pesi Basati sulla Dimensione del Campione</strong></h3>\n<p>Per dati aggregati rappresentanti gruppi di dimensioni $n_i$:\n$$\nw_i = n_i\n$$</p>\n<p>Questo assume che la varianza dell&rsquo;errore sia inversamente proporzionale alla dimensione del gruppo.</p>\n<h3 id=\"53-pesi-per-gestire-outliers\"><strong>5.3. Pesi per Gestire Outliers</strong></h3>\n<h4 id=\"531-pesi-di-huber\"><strong>5.3.1. Pesi di Huber</strong></h4>\n$$\nw_i = \\begin{cases}\n1 & \\text{se } |r_i| \\leq k \\\\\n\\frac{k}{|r_i|} & \\text{se } |r_i| > k\n\\end{cases}\n$$\n<p>dove $r_i$ è il residuo standardizzato e $k$ è una soglia (tipicamente $k = 1.345$).</p>\n<h4 id=\"532-pesi-di-tukey-bisquare\"><strong>5.3.2. Pesi di Tukey (Bisquare)</strong></h4>\n$$\nw_i = \\begin{cases}\n\\left(1 - \\left(\\frac{r_i}{k}\\right)^2\\right)^2 & \\text{se } |r_i| \\leq k \\\\\n0 & \\text{se } |r_i| > k\n\\end{cases}\n$$\n<h3 id=\"54-pesi-adattivi-weighted-iteratively-reweighted-least-squares-irls\"><strong>5.4. Pesi Adattivi: Weighted Iteratively Reweighted Least Squares (IRLS)</strong></h3>\n<p>Un approccio iterativo per stimare automaticamente i pesi:</p>\n<ol>\n<li><strong>Inizializzazione</strong>: Eseguire OLS per ottenere $\\hat{\\boldsymbol{\\theta}}^{(0)}$</li>\n<li><strong>Per $t = 1, 2, \\ldots$ fino a convergenza:</strong></li>\n<li>Calcolare residui: $r_i^{(t-1)} = y_i - \\mathbf{x}_i^T \\hat{\\boldsymbol{\\theta}}^{(t-1)}$</li>\n<li>Aggiornare pesi: $w_i^{(t)} = f(r_i^{(t-1)})$ usando una funzione peso robusta</li>\n<li>Ricalcolare: $\\hat{\\boldsymbol{\\theta}}^{(t)} = (\\mathbf{X}^T \\mathbf{W}^{(t)} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W}^{(t)} \\mathbf{y}$</li>\n</ol>\n<h2 id=\"6-implementazione-pratica\"><strong>6. Implementazione Pratica</strong></h2>\n<h3 id=\"61-implementazione-base\"><strong>6.1. Implementazione Base</strong></h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"kn\">import</span><span class=\"w\"> </span><span class=\"nn\">torch</span>\n\n<span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">weighted_least_squares</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">weights</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Weighted Least Squares implementation</span>\n<span class=\"sd\">    Args:</span>\n<span class=\"sd\">        X: design matrix (n, d+1) with bias column</span>\n<span class=\"sd\">        y: target vector (n, 1)</span>\n<span class=\"sd\">        weights: weight vector (n,)</span>\n<span class=\"sd\">    Returns:</span>\n<span class=\"sd\">        theta: parameter estimates</span>\n<span class=\"sd\">        sigma2: residual variance estimate</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n\n    <span class=\"c1\"># Ensure correct dimensions</span>\n    <span class=\"k\">if</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">dim</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"n\">y</span> <span class=\"o\">=</span> <span class=\"n\">y</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n    <span class=\"k\">if</span> <span class=\"n\">weights</span><span class=\"o\">.</span><span class=\"n\">dim</span><span class=\"p\">()</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">:</span>\n        <span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">weights</span><span class=\"o\">.</span><span class=\"n\">unsqueeze</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Create weight matrix</span>\n    <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">weights</span><span class=\"o\">.</span><span class=\"n\">squeeze</span><span class=\"p\">())</span>\n\n    <span class=\"c1\"># WLS solution: θ = (X^T W X)^(-1) X^T W y</span>\n    <span class=\"n\">XTW</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">W</span>\n    <span class=\"n\">XTWX</span> <span class=\"o\">=</span> <span class=\"n\">XTW</span> <span class=\"o\">@</span> <span class=\"n\">X</span>\n    <span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">inverse</span><span class=\"p\">(</span><span class=\"n\">XTWX</span><span class=\"p\">)</span> <span class=\"o\">@</span> <span class=\"n\">XTW</span> <span class=\"o\">@</span> <span class=\"n\">y</span>\n\n    <span class=\"c1\"># Residuals and variance estimate</span>\n    <span class=\"n\">y_pred</span> <span class=\"o\">=</span> <span class=\"n\">X</span> <span class=\"o\">@</span> <span class=\"n\">theta</span>\n    <span class=\"n\">residuals</span> <span class=\"o\">=</span> <span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">y_pred</span>\n    <span class=\"n\">weighted_residuals</span> <span class=\"o\">=</span> <span class=\"n\">weights</span> <span class=\"o\">*</span> <span class=\"n\">residuals</span><span class=\"o\">**</span><span class=\"mi\">2</span>\n    <span class=\"n\">sigma2</span> <span class=\"o\">=</span> <span class=\"n\">weighted_residuals</span><span class=\"o\">.</span><span class=\"n\">sum</span><span class=\"p\">()</span> <span class=\"o\">/</span> <span class=\"p\">(</span><span class=\"n\">n</span> <span class=\"o\">-</span> <span class=\"n\">d</span><span class=\"p\">)</span>\n\n    <span class=\"c1\"># Covariance matrix</span>\n    <span class=\"n\">cov_matrix</span> <span class=\"o\">=</span> <span class=\"n\">sigma2</span> <span class=\"o\">*</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">inverse</span><span class=\"p\">(</span><span class=\"n\">XTWX</span><span class=\"p\">)</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">theta</span><span class=\"p\">,</span> <span class=\"n\">sigma2</span><span class=\"p\">,</span> <span class=\"n\">cov_matrix</span>\n</code></pre></div>\n</div>\n</div>\n\n<h3 id=\"62-implementazione-irls-per-robustezza\"><strong>6.2. Implementazione IRLS per Robustezza</strong></h3>\n<div class=\"code-visible\">\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code><span class=\"k\">def</span><span class=\"w\"> </span><span class=\"nf\">irls_robust_regression</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"p\">,</span> <span class=\"n\">y</span><span class=\"p\">,</span> <span class=\"n\">max_iter</span><span class=\"o\">=</span><span class=\"mi\">10</span><span class=\"p\">,</span> <span class=\"n\">tol</span><span class=\"o\">=</span><span class=\"mf\">1e-6</span><span class=\"p\">,</span> <span class=\"n\">c</span><span class=\"o\">=</span><span class=\"mf\">1.345</span><span class=\"p\">):</span>\n<span class=\"w\">    </span><span class=\"sd\">&quot;&quot;&quot;</span>\n<span class=\"sd\">    Iteratively Reweighted Least Squares with Huber weights</span>\n<span class=\"sd\">    &quot;&quot;&quot;</span>\n    <span class=\"n\">n</span><span class=\"p\">,</span> <span class=\"n\">d</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">shape</span>\n\n    <span class=\"c1\"># Initialize with OLS</span>\n    <span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">inverse</span><span class=\"p\">(</span><span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">X</span><span class=\"p\">)</span> <span class=\"o\">@</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">y</span>\n\n    <span class=\"k\">for</span> <span class=\"n\">iteration</span> <span class=\"ow\">in</span> <span class=\"nb\">range</span><span class=\"p\">(</span><span class=\"n\">max_iter</span><span class=\"p\">):</span>\n        <span class=\"c1\"># Calculate residuals</span>\n        <span class=\"n\">residuals</span> <span class=\"o\">=</span> <span class=\"n\">y</span> <span class=\"o\">-</span> <span class=\"n\">X</span> <span class=\"o\">@</span> <span class=\"n\">theta</span>\n\n        <span class=\"c1\"># Calculate robust scale (MAD-based)</span>\n        <span class=\"n\">mad</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">median</span><span class=\"p\">(</span><span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">residuals</span> <span class=\"o\">-</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">median</span><span class=\"p\">(</span><span class=\"n\">residuals</span><span class=\"p\">)))</span>\n        <span class=\"n\">scale</span> <span class=\"o\">=</span> <span class=\"mf\">1.4826</span> <span class=\"o\">*</span> <span class=\"n\">mad</span>  <span class=\"c1\"># Convert MAD to standard deviation estimate</span>\n\n        <span class=\"c1\"># Standardized residuals</span>\n        <span class=\"n\">std_residuals</span> <span class=\"o\">=</span> <span class=\"n\">residuals</span> <span class=\"o\">/</span> <span class=\"n\">scale</span>\n\n        <span class=\"c1\"># Huber weights</span>\n        <span class=\"n\">weights</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">ones_like</span><span class=\"p\">(</span><span class=\"n\">std_residuals</span><span class=\"p\">)</span>\n        <span class=\"n\">mask</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">std_residuals</span><span class=\"p\">)</span> <span class=\"o\">&gt;</span> <span class=\"n\">c</span>\n        <span class=\"n\">weights</span><span class=\"p\">[</span><span class=\"n\">mask</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"n\">c</span> <span class=\"o\">/</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">abs</span><span class=\"p\">(</span><span class=\"n\">std_residuals</span><span class=\"p\">[</span><span class=\"n\">mask</span><span class=\"p\">])</span>\n\n        <span class=\"c1\"># WLS step</span>\n        <span class=\"n\">W</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">diag</span><span class=\"p\">(</span><span class=\"n\">weights</span><span class=\"o\">.</span><span class=\"n\">squeeze</span><span class=\"p\">())</span>\n        <span class=\"n\">XTW</span> <span class=\"o\">=</span> <span class=\"n\">X</span><span class=\"o\">.</span><span class=\"n\">T</span> <span class=\"o\">@</span> <span class=\"n\">W</span>\n        <span class=\"n\">XTWX</span> <span class=\"o\">=</span> <span class=\"n\">XTW</span> <span class=\"o\">@</span> <span class=\"n\">X</span>\n        <span class=\"n\">theta_new</span> <span class=\"o\">=</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">inverse</span><span class=\"p\">(</span><span class=\"n\">XTWX</span><span class=\"p\">)</span> <span class=\"o\">@</span> <span class=\"n\">XTW</span> <span class=\"o\">@</span> <span class=\"n\">y</span>\n\n        <span class=\"c1\"># Check convergence</span>\n        <span class=\"k\">if</span> <span class=\"n\">torch</span><span class=\"o\">.</span><span class=\"n\">norm</span><span class=\"p\">(</span><span class=\"n\">theta_new</span> <span class=\"o\">-</span> <span class=\"n\">theta</span><span class=\"p\">)</span> <span class=\"o\">&lt;</span> <span class=\"n\">tol</span><span class=\"p\">:</span>\n            <span class=\"k\">break</span>\n\n        <span class=\"n\">theta</span> <span class=\"o\">=</span> <span class=\"n\">theta_new</span>\n\n    <span class=\"k\">return</span> <span class=\"n\">theta</span><span class=\"p\">,</span> <span class=\"n\">weights</span>\n</code></pre></div>\n</div>\n</div>\n\n<h2 id=\"7-diagnostica-e-valutazione\"><strong>7. Diagnostica e Valutazione</strong></h2>\n<h3 id=\"71-metriche-ponderate\"><strong>7.1. Metriche Ponderate</strong></h3>\n<p>Le metriche di performance devono essere adattate per riflettere la ponderazione:</p>\n<h4 id=\"mean-weighted-squared-error-mwse\"><strong>Mean Weighted Squared Error (MWSE)</strong></h4>\n$$\nMWSE = \\frac{\\sum_{i=1}^n w_i (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^n w_i}\n$$\n<h4 id=\"weighted-r-squared\"><strong>Weighted R-squared</strong></h4>\n$$\nR_w^2 = 1 - \\frac{\\sum_{i=1}^n w_i (y_i - \\hat{y}_i)^2}{\\sum_{i=1}^n w_i (y_i - \\bar{y}_w)^2}\n$$\n<p>dove $\\bar{y}_w = \\frac{\\sum_{i=1}^n w_i y_i}{\\sum_{i=1}^n w_i}$ è la media ponderata.</p>\n<h3 id=\"72-analisi-dei-residui-ponderati\"><strong>7.2. Analisi dei Residui Ponderati</strong></h3>\n<p>I residui standardizzati ponderati sono:\n$$\nr_{i,\\text{std}} = \\frac{r_i}{\\hat{\\sigma} \\sqrt{1 - h_{ii}}} \\sqrt{w_i}\n$$</p>\n<p>dove $h_{ii}$ è l&rsquo;elemento diagonale della hat matrix: $\\mathbf{H} = \\mathbf{X}(\\mathbf{X}^T \\mathbf{W} \\mathbf{X})^{-1} \\mathbf{X}^T \\mathbf{W}$.</p>\n<h3 id=\"73-test-di-significativita\"><strong>7.3. Test di Significatività</strong></h3>\n<p>I test statistici (test t per i coefficienti, test F globale) rimangono validi usando gli errori standard corretti dalla matrice di varianza-covarianza ponderata.</p>\n<h2 id=\"8-confronto-con-metodi-correlati\"><strong>8. Confronto con Metodi Correlati</strong></h2>\n<h3 id=\"81-regressione-ponderata-vs-regressione-lineare\"><strong>8.1. Regressione Ponderata vs <a href=\"/theory/supervised-learning/Linear Models/Regressione Lineare\" class=\"text-blue-600 hover:underline\">Regressione Lineare</a></strong></h3>\n<table>\n<thead>\n<tr>\n<th>Aspetto</th>\n<th>OLS</th>\n<th>WLS</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Assunzioni sui pesi</strong></td>\n<td>Tutti uguali ($w_i = 1$)</td>\n<td>Possono variare</td>\n</tr>\n<tr>\n<td><strong>Trattamento eteroschedasticità</strong></td>\n<td>Inadeguato</td>\n<td>Appropriato</td>\n</tr>\n<tr>\n<td><strong>Robustezza agli outliers</strong></td>\n<td>Bassa</td>\n<td>Configurabile</td>\n</tr>\n<tr>\n<td><strong>Complessità implementativa</strong></td>\n<td>Bassa</td>\n<td>Moderata</td>\n</tr>\n<tr>\n<td><strong>Efficienza computazionale</strong></td>\n<td>Alta</td>\n<td>Leggermente inferiore</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"82-regressione-ponderata-vs-locally-weighted-linear-regression\"><strong>8.2. Regressione Ponderata vs <a href=\"/theory/supervised-learning/Non-Linear Models/Locally Weighted Linear Regression\" class=\"text-blue-600 hover:underline\">Locally Weighted Linear Regression</a></strong></h3>\n<table>\n<thead>\n<tr>\n<th>Aspetto</th>\n<th>Weighted Regression</th>\n<th>LWLR</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td><strong>Natura dei pesi</strong></td>\n<td>Fissi per dataset</td>\n<td>Adattivi per ogni query</td>\n</tr>\n<tr>\n<td><strong>Numero di modelli</strong></td>\n<td>Uno globale</td>\n<td>Uno per ogni predizione</td>\n</tr>\n<tr>\n<td><strong>Capacità non-lineare</strong></td>\n<td>Nessuna</td>\n<td>Elevata</td>\n</tr>\n<tr>\n<td><strong>Costo computazionale</strong></td>\n<td>$O(d^3)$ una volta</td>\n<td>$O(d^3)$ per query</td>\n</tr>\n<tr>\n<td><strong>Interpretabilità</strong></td>\n<td>Alta</td>\n<td>Moderata</td>\n</tr>\n<tr>\n<td><strong>Memoria richiesta</strong></td>\n<td>Bassa</td>\n<td>Alta (tutto il training set)</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"83-posizionamento-nel-continuum\"><strong>8.3. Posizionamento nel Continuum</strong></h3>\n<details class=\"code-container\">\n<summary>Code</summary>\n<div class=\"code-wrapper\">\n<button class=\"copy-button\" onclick=\"\n                const code = this.parentElement.querySelector('pre');\n                if (code) {\n                    navigator.clipboard.writeText(code.innerText);\n                    this.textContent = 'Copied!';\n                    setTimeout(() => this.textContent = 'Copy', 2000);\n                }\n            \">Copy</button>\n<div class=\"codehilite\"><pre><span></span><code>OLS → Weighted Regression → LWLR → Kernel Regression\n ↑           ↑                ↑            ↑\nRigido    Pesi fissi    Pesi adattivi  Completamente\n                                       non-parametrico\n</code></pre></div>\n</div>\n</details>\n\n<p>La regressione ponderata occupa una posizione intermedia, mantenendo la semplicità parametrica della regressione lineare mentre introducendo flessibilità nella gestione dell&rsquo;affidabilità dei dati.</p>\n<h2 id=\"9-applicazioni-pratiche\"><strong>9. Applicazioni Pratiche</strong></h2>\n<h3 id=\"91-econometria\"><strong>9.1. Econometria</strong></h3>\n<ul>\n<li><strong>Studi panel</strong>: Pesi basati sulla precisione delle stime per paese/anno</li>\n<li><strong>Sondaggi</strong>: Pesi per correggere bias di campionamento</li>\n<li><strong>Dati aggregati</strong>: Pesi proporzionali alla popolazione rappresentata</li>\n</ul>\n<h3 id=\"92-ingegneria\"><strong>9.2. Ingegneria</strong></h3>\n<ul>\n<li><strong>Calibrazione strumenti</strong>: Pesi basati sulla precisione di misura</li>\n<li><strong>Controllo qualità</strong>: Pesi per riflettere l&rsquo;importanza di specifiche caratteristiche</li>\n<li><strong>Modellazione fisica</strong>: Pesi per dati da esperimenti con condizioni diverse</li>\n</ul>\n<h3 id=\"93-medicina-e-biologia\"><strong>9.3. Medicina e Biologia</strong></h3>\n<ul>\n<li><strong>Meta-analisi</strong>: Pesi basati sulla dimensione degli studi</li>\n<li><strong>Dati clinici</strong>: Pesi per pazienti con follow-up di durata diversa  </li>\n<li><strong>Farmacocinetrica</strong>: Pesi per concentrazioni misurate a tempi diversi</li>\n</ul>\n<h3 id=\"94-machine-learning\"><strong>9.4. Machine Learning</strong></h3>\n<ul>\n<li><strong>Class imbalancing</strong>: Pesi inversamente proporzionali alla frequenza delle classi</li>\n<li><strong>Active learning</strong>: Pesi maggiori per campioni informativi</li>\n<li><strong>Transfer learning</strong>: Pesi per bilanciare domini sorgente e target</li>\n</ul>\n<h2 id=\"10-limitazioni-e-considerazioni\"><strong>10. Limitazioni e Considerazioni</strong></h2>\n<h3 id=\"101-scelta-dei-pesi\"><strong>10.1. Scelta dei Pesi</strong></h3>\n<p>La performance della regressione ponderata dipende criticamente dalla scelta appropriata dei pesi:</p>\n<ul>\n<li><strong>Pesi ottimali</strong>: Richiedono conoscenza della vera varianza degli errori</li>\n<li><strong>Pesi errati</strong>: Possono peggiorare le prestazioni rispetto a OLS</li>\n<li><strong>Soggettività</strong>: Spesso la scelta dei pesi contiene elementi arbitrari</li>\n</ul>\n<h3 id=\"102-problemi-numerici\"><strong>10.2. Problemi Numerici</strong></h3>\n<ul>\n<li><strong>Condizionamento</strong>: $\\mathbf{X}^T \\mathbf{W} \\mathbf{X}$ può essere mal condizionata se alcuni pesi sono molto grandi</li>\n<li><strong>Stabilità</strong>: Pesi vicini a zero possono causare instabilità numerica</li>\n<li><strong>Scalabilità</strong>: La costruzione della matrice $\\mathbf{W}$ può essere costosa per $n$ grande</li>\n</ul>\n<h3 id=\"103-interpretazione\"><strong>10.3. Interpretazione</strong></h3>\n<ul>\n<li>I coefficienti WLS non sono direttamente confrontabili con quelli OLS</li>\n<li>L&rsquo;interpretazione deve considerare l&rsquo;effetto della ponderazione</li>\n<li>Le metriche di performance standard (R², MSE) richiedono adattamento</li>\n</ul>\n<h2 id=\"11-estensioni-e-varianti\"><strong>11. Estensioni e Varianti</strong></h2>\n<h3 id=\"111-weighted-ridge-regression\"><strong>11.1. Weighted Ridge Regression</strong></h3>\n<p>Combinazione di ponderazione e regolarizzazione L2:\n$$\n\\min_{\\boldsymbol{\\theta}} \\sum_{i=1}^n w_i (y_i - \\mathbf{x}_i^T \\boldsymbol{\\theta})^2 + \\lambda \\|\\boldsymbol{\\theta}\\|_2^2\n$$</p>\n<p>Soluzione:\n$$\n\\boldsymbol{\\theta}^* = (\\mathbf{X}^T \\mathbf{W} \\mathbf{X} + \\lambda \\mathbf{I})^{-1} \\mathbf{X}^T \\mathbf{W} \\mathbf{y}\n$$</p>\n<h3 id=\"112-weighted-elastic-net\"><strong>11.2. Weighted Elastic Net</strong></h3>\n<p>Estende elastic net con ponderazione:\n$$\n\\min_{\\boldsymbol{\\theta}} \\sum_{i=1}^n w_i (y_i - \\mathbf{x}_i^T \\boldsymbol{\\theta})^2 + \\lambda_1 \\|\\boldsymbol{\\theta}\\|_1 + \\lambda_2 \\|\\boldsymbol{\\theta}\\|_2^2\n$$</p>\n<h3 id=\"113-generalized-least-squares-gls\"><strong>11.3. Generalized Least Squares (GLS)</strong></h3>\n<p>Estensione a matrici di covarianza complete (non necessariamente diagonali):\n$$\n\\boldsymbol{\\theta}^* = (\\mathbf{X}^T \\boldsymbol{\\Omega}^{-1} \\mathbf{X})^{-1} \\mathbf{X}^T \\boldsymbol{\\Omega}^{-1} \\mathbf{y}\n$$</p>\n<p>dove $\\boldsymbol{\\Omega}$ è la matrice di covarianza completa degli errori.</p>\n<h2 id=\"12-conclusioni\"><strong>12. Conclusioni</strong></h2>\n<p>La regressione ponderata rappresenta un&rsquo;estensione naturale e potente della <a href=\"/theory/supervised-learning/Linear Models/Regressione Lineare\" class=\"text-blue-600 hover:underline\">Regressione Lineare</a> che mantiene la semplicità concettuale e computazionale del modello lineare incorporando flessibilità nella gestione dell&rsquo;affidabilità e importanza dei dati.</p>\n<h3 id=\"121-punti-di-forza\"><strong>12.1. Punti di Forza</strong></h3>\n<ul>\n<li><strong>Semplicità</strong>: Modifica minimale della regressione lineare standard</li>\n<li><strong>Flessibilità</strong>: Adatta a molteplici scenari pratici</li>\n<li><strong>Fondamento teorico</strong>: Stimatore BLUE sotto assunzioni appropriate</li>\n<li><strong>Implementazione</strong>: Richiede modifiche minime agli algoritmi esistenti</li>\n</ul>\n<h3 id=\"122-quando-utilizzarla\"><strong>12.2. Quando Utilizzarla</strong></h3>\n<p>La regressione ponderata è particolarmente indicata quando:\n- Le osservazioni hanno affidabilità/precisione nota e variabile\n- Si vuole gestire l&rsquo;eteroschedasticità senza perdere la semplicità lineare\n- È necessario un controllo esplicito sull&rsquo;influenza di specifiche osservazioni<br />\n- Il dataset contiene outliers identificabili ma non eliminabili</p>\n<h3 id=\"123-posizionamento-nel-panorama-ml\"><strong>12.3. Posizionamento nel Panorama ML</strong></h3>\n<p>Collocandosi tra la rigidità della regressione lineare ordinaria e la flessibilità della <a href=\"/theory/supervised-learning/Non-Linear Models/Locally Weighted Linear Regression\" class=\"text-blue-600 hover:underline\">Locally Weighted Linear Regression</a>, la regressione ponderata offre un equilibrio ottimale per molte applicazioni pratiche dove è necessario mantenere interpretabilità e semplicità computazionale pur adattandosi alle caratteristiche variabili dei dati.</p>"
}