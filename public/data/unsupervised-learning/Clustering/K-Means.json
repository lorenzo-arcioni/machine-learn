{
  "title": "Untitled",
  "content": "<style>pre { line-height: 125%; }\ntd.linenos .normal { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\nspan.linenos { color: inherit; background-color: transparent; padding-left: 5px; padding-right: 5px; }\ntd.linenos .special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\nspan.linenos.special { color: #000000; background-color: #ffffc0; padding-left: 5px; padding-right: 5px; }\n.codehilite .hll { background-color: #ffffcc }\n.codehilite { background: #f8f8f8; }\n.codehilite .c { color: #3D7B7B; font-style: italic } /* Comment */\n.codehilite .err { border: 1px solid #F00 } /* Error */\n.codehilite .k { color: #008000; font-weight: bold } /* Keyword */\n.codehilite .o { color: #666 } /* Operator */\n.codehilite .ch { color: #3D7B7B; font-style: italic } /* Comment.Hashbang */\n.codehilite .cm { color: #3D7B7B; font-style: italic } /* Comment.Multiline */\n.codehilite .cp { color: #9C6500 } /* Comment.Preproc */\n.codehilite .cpf { color: #3D7B7B; font-style: italic } /* Comment.PreprocFile */\n.codehilite .c1 { color: #3D7B7B; font-style: italic } /* Comment.Single */\n.codehilite .cs { color: #3D7B7B; font-style: italic } /* Comment.Special */\n.codehilite .gd { color: #A00000 } /* Generic.Deleted */\n.codehilite .ge { font-style: italic } /* Generic.Emph */\n.codehilite .ges { font-weight: bold; font-style: italic } /* Generic.EmphStrong */\n.codehilite .gr { color: #E40000 } /* Generic.Error */\n.codehilite .gh { color: #000080; font-weight: bold } /* Generic.Heading */\n.codehilite .gi { color: #008400 } /* Generic.Inserted */\n.codehilite .go { color: #717171 } /* Generic.Output */\n.codehilite .gp { color: #000080; font-weight: bold } /* Generic.Prompt */\n.codehilite .gs { font-weight: bold } /* Generic.Strong */\n.codehilite .gu { color: #800080; font-weight: bold } /* Generic.Subheading */\n.codehilite .gt { color: #04D } /* Generic.Traceback */\n.codehilite .kc { color: #008000; font-weight: bold } /* Keyword.Constant */\n.codehilite .kd { color: #008000; font-weight: bold } /* Keyword.Declaration */\n.codehilite .kn { color: #008000; font-weight: bold } /* Keyword.Namespace */\n.codehilite .kp { color: #008000 } /* Keyword.Pseudo */\n.codehilite .kr { color: #008000; font-weight: bold } /* Keyword.Reserved */\n.codehilite .kt { color: #B00040 } /* Keyword.Type */\n.codehilite .m { color: #666 } /* Literal.Number */\n.codehilite .s { color: #BA2121 } /* Literal.String */\n.codehilite .na { color: #687822 } /* Name.Attribute */\n.codehilite .nb { color: #008000 } /* Name.Builtin */\n.codehilite .nc { color: #00F; font-weight: bold } /* Name.Class */\n.codehilite .no { color: #800 } /* Name.Constant */\n.codehilite .nd { color: #A2F } /* Name.Decorator */\n.codehilite .ni { color: #717171; font-weight: bold } /* Name.Entity */\n.codehilite .ne { color: #CB3F38; font-weight: bold } /* Name.Exception */\n.codehilite .nf { color: #00F } /* Name.Function */\n.codehilite .nl { color: #767600 } /* Name.Label */\n.codehilite .nn { color: #00F; font-weight: bold } /* Name.Namespace */\n.codehilite .nt { color: #008000; font-weight: bold } /* Name.Tag */\n.codehilite .nv { color: #19177C } /* Name.Variable */\n.codehilite .ow { color: #A2F; font-weight: bold } /* Operator.Word */\n.codehilite .w { color: #BBB } /* Text.Whitespace */\n.codehilite .mb { color: #666 } /* Literal.Number.Bin */\n.codehilite .mf { color: #666 } /* Literal.Number.Float */\n.codehilite .mh { color: #666 } /* Literal.Number.Hex */\n.codehilite .mi { color: #666 } /* Literal.Number.Integer */\n.codehilite .mo { color: #666 } /* Literal.Number.Oct */\n.codehilite .sa { color: #BA2121 } /* Literal.String.Affix */\n.codehilite .sb { color: #BA2121 } /* Literal.String.Backtick */\n.codehilite .sc { color: #BA2121 } /* Literal.String.Char */\n.codehilite .dl { color: #BA2121 } /* Literal.String.Delimiter */\n.codehilite .sd { color: #BA2121; font-style: italic } /* Literal.String.Doc */\n.codehilite .s2 { color: #BA2121 } /* Literal.String.Double */\n.codehilite .se { color: #AA5D1F; font-weight: bold } /* Literal.String.Escape */\n.codehilite .sh { color: #BA2121 } /* Literal.String.Heredoc */\n.codehilite .si { color: #A45A77; font-weight: bold } /* Literal.String.Interpol */\n.codehilite .sx { color: #008000 } /* Literal.String.Other */\n.codehilite .sr { color: #A45A77 } /* Literal.String.Regex */\n.codehilite .s1 { color: #BA2121 } /* Literal.String.Single */\n.codehilite .ss { color: #19177C } /* Literal.String.Symbol */\n.codehilite .bp { color: #008000 } /* Name.Builtin.Pseudo */\n.codehilite .fm { color: #00F } /* Name.Function.Magic */\n.codehilite .vc { color: #19177C } /* Name.Variable.Class */\n.codehilite .vg { color: #19177C } /* Name.Variable.Global */\n.codehilite .vi { color: #19177C } /* Name.Variable.Instance */\n.codehilite .vm { color: #19177C } /* Name.Variable.Magic */\n.codehilite .il { color: #666 } /* Literal.Number.Integer.Long */\n\n/* Styling per blocchi di codice */\n.codehilite {\n    background: transparent !important;\n    border-radius: 8px;\n    overflow: hidden;\n}\n.codehilite pre {\n    background: transparent !important;\n    margin: 0 !important;\n    padding: 20px !important;\n    font-family: 'Monaco', 'Menlo', 'Consolas', monospace !important;\n    font-size: 14px !important;\n    line-height: 1.5 !important;\n    white-space: pre !important;\n    overflow-x: auto !important;\n    color: inherit !important;\n}\n.codehilite code {\n    background: transparent !important;\n    padding: 0 !important;\n    font-family: inherit !important;\n}\n\n\n.code-wrapper { \n    position: relative; \n}\n.copy-button {\n    position: absolute; \n    top: 12px; \n    right: 12px; \n    padding: 6px 12px; \n    font-size: 12px;\n    cursor: pointer; \n    border: none; \n    border-radius: 4px; \n    background: rgba(255,255,255,0.9);\n    color: #374151; \n    transition: all 0.2s ease;\n    font-weight: 500;\n}\n.copy-button:hover { \n    background: rgba(255,255,255,1);\n    transform: translateY(-1px);\n}\n\n\ndetails.code-container {\n    border: 1px solid #e5e7eb; \n    border-radius: 12px; \n    background: #f9fafb;\n    margin: 16px 0;\n    transition: all 0.3s ease;\n}\ndetails.code-container summary {\n    padding: 12px 16px;\n    font-size: 14px; \n    color: #6b7280; \n    cursor: pointer; \n    outline: none; \n    user-select: none;\n    font-weight: 500;\n}\ndetails.code-container[open] summary::after { \n    content: \" (Hide Code)\"; \n    color: #9ca3af; \n}\ndetails.code-container:not([open]) summary::after { \n    content: \" (Show Code)\"; \n    color: #d1d5db; \n}\ndetails.code-container .code-wrapper {\n    padding: 0;\n    margin: 0;\n}\n</style>\n<h2 id=\"introduzione\">Introduzione</h2>\n<p>L&rsquo;algoritmo <strong>K-Means</strong> è uno dei metodi più comuni e semplici per eseguire il clustering. Esso cerca di partizionare un set di $N$ punti in $K$ cluster, minimizzando la varianza interna ai cluster (sum of square distances). </p>\n<p>Il K-means fa parte della tipologia <a href=\"/theory/unsupervised-learning/Clustering/Partitioning-based Clustering\" class=\"text-blue-600 hover:underline\">Partitioning-based Clustering</a>.</p>\n<p>In questo caso, il rappresentante di ogni cluster $\\vec \\Theta_k$ è il suo centro di massa (i.e., il centroide). Il centroide di un cluster è la media data point assegnati ad ogni cluster.</p>\n<h2 id=\"setup\">Setup</h2>\n<p>Basandoci sul framework generale del <a href=\"/theory/unsupervised-learning/Clustering/Partitioning-based Clustering\" class=\"text-blue-600 hover:underline\">Partitioning-based Clustering</a>, definiamo\n$$\n\\vec \\Theta_k = \\frac{\\sum_{n=1}^N \\alpha_{n, k} \\cdot \\vec x_{n}}{\\sum_{n=1}^N \\alpha_{n, k}} = \\mu_k = \\frac{1}{|C_k|} \\sum_{n \\in C_k} \\vec x_{n}\n$$</p>\n<p>where $|C_k| = \\sum_{n=1}^N \\alpha_{n, k}$</p>\n<p>Assumiamo ora che la nostra funzione di distanza $\\delta$ sia il quadrato della norma $L^2$ applicata al vettore differenza $\\vec x_n - \\vec \\Theta_k$:\n$$\n\\delta(\\vec x_n, \\vec \\Theta_k) = ||\\vec x_n - \\vec \\Theta_k||_2^2 = (\\vec x_n - \\vec \\Theta_k)^2.\n$$\nLa nostra funzione obiettivo $L$ diventa\n$$\nL(A, \\Theta) = \\sum_{n=1}^N \\sum_{k=1}^K \\alpha_{n, k} \\cdot (\\vec x_n - \\vec \\Theta_k)^2.\n$$\nProcediamo ora con i due steps:</p>\n<ul>\n<li><strong>Assegnazione</strong>\n    $$\n\t\\alpha_{n, k} = \\begin{cases}\n\t1 \\quad \\text{se } (\\vec x_n - \\vec \\Theta_k)^2 = \\min_{1 \\leq j \\leq K} \\{(\\vec x_n - \\vec \\Theta_j)^2\\}\\\\\n\t0 \\quad \\text{altrimenti}\n\t\\end{cases}\n\t$$</li>\n<li><strong>Ottimizzazione</strong>\n    Minimizziamo $L$ rispetto a $\\Theta$ fissando $A$, quindi\n    $$\n\t\\DeclareMathOperator*{\\argmin}{argmin}\n\t\\DeclareMathOperator*{\\argmax}{argmax}\n\t\\Theta^* = \\argmin_{\\Theta} \\left\\{ \\underbrace{\\sum_{n=1}^N \\sum_{k=1}^K \\alpha_{n, k} \\cdot (\\vec x_n - \\vec \\Theta_k)^2}_{L(\\Theta; A)} \\right\\}\n\t$$\n    Calcoliamo ora il gradiente di $L$, poniamolo $=0$ e risolviamo per $\\Theta$.\n    Dal framework generale <a href=\"/theory/unsupervised-learning/Clustering/Partitioning-based Clustering\" class=\"text-blue-600 hover:underline\">Partitioning-based Clustering</a> sappiamo che se vogliamo trovare il gradiente di $L$, ci basta calcolare\n    $$\n\t\\begin{align}\n\t\\frac{\\partial L(\\Theta; A)}{\\partial \\vec \\Theta_k} &= \\frac{\\partial}{\\partial \\vec \\Theta_k} \\sum_{n=1}^N \\alpha_{n, k} \\cdot (\\vec x_n - \\vec \\Theta_k)^2\\\\\n\t\\\\\n\t&\\text{dato che ora } \\alpha_{n, k} \\text{ è una costante}\\\\\n\t\\\\\n\t&= \\sum_{n=1}^N \\alpha_{n, k} \\cdot \\frac{\\partial}{\\partial \\vec \\Theta_k} (\\vec x_n - \\vec \\Theta_k)^2\n\t\\end{align}\n\t$$\n    Calcoliamo ora\n    $$\\begin{align}\n\t\\frac{\\partial}{\\partial \\vec \\Theta_k} (\\vec x_n - \\vec \\Theta_k)^2 &= \\frac{\\partial}{\\partial \\vec \\Theta_k} (\\vec x_n - \\vec \\Theta_k)^T (\\vec x_n - \\vec \\Theta_k)\\\\\n\t&= \\frac{\\partial}{\\partial \\vec \\Theta_k} \\left [\\vec x_n^T \\vec x_n \\underbrace{- \\vec \\Theta^T \\vec x_n - \\vec x_n^T \\vec \\Theta_k}_\\text{sono uguali} + \\vec \\Theta_k^T \\vec \\Theta_k \\right]\\\\\n\t&= \\frac{\\partial}{\\partial \\vec \\Theta_k} \\vec x_n^T \\vec x_n - \\frac{\\partial}{\\partial \\vec \\Theta_k} 2 \\cdot \\vec \\Theta^T \\vec x_n + \\frac{\\partial}{\\partial \\vec \\Theta_k} \\vec \\Theta_k^T \\vec \\Theta_k \\\\\n\t&= 0 \\ - 2 \\vec x_n + 2 \\vec \\Theta_k\\\\\n\t&= -2(\\vec x_n - \\vec \\Theta_k)\n\t\\end{align}\n\t$$\n    Ora non ci resta altro che porre \n    $$\\begin{align}\n\t\\sum_{n=1}^N \\alpha_{n, k} \\cdot -2(\\vec x_n - \\vec \\Theta_k) &= 0\\\\\n\t2 \\sum_{n=1}^N \\alpha_{n, k} \\vec \\Theta_k &= 2 \\sum_{n=1}^N \\alpha_{n, k} \\vec x_n\\\\\n\t\\sum_{n=1}^N \\alpha_{n, k} \\vec \\Theta_k &= \\sum_{n=1}^N \\alpha_{n, k} \\vec x_n\\\\\n\t\\vec \\Theta_k &= \\frac{\\sum_{n=1}^N \\alpha_{n, k} \\vec x_n}{\\sum_{n=1}^N \\alpha_{n, k}} = \\mu_k = \\frac{1}{|C_k|} \\sum_{n \\in C_k} \\vec x_n.\n\t\\end{align}\n\t$$\n    Quindi il centroide del cluster $k$ (quindi la media dei suoi data points) minimizza la funzione obiettivo (con una matrice $A$ fissata).</li>\n</ul>\n<h2 id=\"recap\">Recap</h2>\n<p>Quindi, ricapitolando:\n1. Scegliere il valore di $K$.\n2. Selezionare randomicamente i $K$ centroidi tra gli $N$ data points a disposizione.\n3. Assegnazione: assegnare ogni osservazione al più vicino centroide basandoci sulla funzione di distanza $\\delta$. \n4. Ottimizzazione: per ogni cluster, aggiorniamo il centroide calcolando la nuova media di tutti i data points attualmente nel cluster.\n5. Ripetere iterativamente i punti 3-5 finché non viene raggiunta la condizione di uscita.\n    Abbiamo varie condizioni di uscita:\n    - Numero fisso di iterazioni.\n    - Gli assegnamenti dei clusters non cambiano più (con un certo threshold).\n    - I centroidi rimangono sempre gli stessi.</p>\n<h2 id=\"convergenza\">Convergenza</h2>\n<p>In entrambi i casi di assegnazione e ottimizzazione (aggiornamento) o miglioriamo la funzione obiettivo oppure no. In generale, questo algoritmo è un caso particolare dell&rsquo;<span class=\"text-gray-600\">Expectation Maximization Algorithm</span>, del quale è dimostrata la convergenza.</p>\n<h2 id=\"complessita-time\">Complessità (time)</h2>\n<p>Calcolare la distanza tra due vettori di dimensione $d$ ha un costo di $O(d)$. </p>\n<p>Lo step di assegnazione quindi ha un costo di $O(NKd)$, in quanto per ogni data point, cerchiamo il centroide più vicino (calcolando per ognuno la distanza).</p>\n<p>Nello step di ottimizzazione (aggiornamento dei centroidi) calcoliamo la media una volta per ogni punto in ogni cluster. Dato che ogni punto è in un solo cluster, e che per calcolare la media per tutte le dimensioni ha un costo di $O(d)$, in totale abbiamo $O(Nd)$.</p>\n<p>Assumendo che l&rsquo;algoritmo termini in $R$ iterazioni, abbiamo una complessità totale di $O(R(KNd + Nd))$ e quindi $O(RKNd)$.</p>\n<h2 id=\"vantaggi\">✅ Vantaggi:</h2>\n<ol>\n<li><strong>Semplicità ed Efficienza</strong> – Facile da implementare e computazionalmente efficiente, soprattutto per grandi dataset.</li>\n<li><strong>Scalabilità</strong> – Può gestire grandi volumi di dati con una complessità computazionale relativamente bassa.</li>\n<li><strong>Velocità di Convergenza</strong> – Generalmente converge rapidamente rispetto ad altri algoritmi di clustering.</li>\n</ol>\n<h2 id=\"svantaggi\">❌ Svantaggi:</h2>\n<ol>\n<li><strong>Necessità di specificare K</strong> – Il numero di cluster deve essere definito a priori, il che può essere difficile senza conoscenza preliminare dei dati.</li>\n<li><strong>Sensibilità agli outlier</strong> – Gli outlier possono influenzare significativamente i centroidi, distorcendo il clustering.</li>\n<li><strong>Dipendenza dall’inizializzazione</strong> – L&rsquo;algoritmo può convergere a soluzioni sub-ottimali a seconda della scelta iniziale dei centroidi.</li>\n</ol>\n<h2 id=\"conclusioni\">Conclusioni</h2>\n<p>Il fatto che all&rsquo;inizio vengano scelti i centroidi in modo casuale, può comportare un clustering non sempre sub-ottimale. Per mitigare il problema, si esegue l&rsquo;algoritmo K-means più volte, in modo da avere diverse versioni di assegnazione iniziale dei centroidi, potendo scegliere la migliore. Un approccio che cerca di mitigare il problema della scelta randomica iniziale dei centroidi è il <a href=\"/theory/unsupervised-learning/Clustering/K-means++\" class=\"text-blue-600 hover:underline\">K-means++</a>.</p>"
}